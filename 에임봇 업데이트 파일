local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local Vector2new = Vector2.new
local Color3new = Color3.new
local Color3fromRGB = Color3.fromRGB
local mathfloor = math.floor
local mathclamp = math.clamp
local mathmax = math.max
local mathabs = math.abs
local tick = tick
local pairs = pairs
local ipairs = ipairs

local AllDrawings = {}
local UnlockConnection
local Locking = false
local CurrentTarget = nil
local GuiVisible = true
local showPlayerList = false
local Connections = {}
local JerkAnims = {}
local R15Track = nil
local SavedCameraState = nil
local spectating = false
local spectateTarget = nil
local restoreCameraState = nil
local AllChams = {}

local cachedParts = {}
local lastNoclipUpdate = 0

local AimKeyButton = nil
local TrigKeyButton = nil
local TrigFOVToggle = nil
local Trig180Toggle = nil
local TypeCamToggle = nil
local TypeMouseToggle = nil
local CheckMouseToggle = nil
local CheckWorldToggle = nil
local AimbotToggleKeyButton = nil
local AimbotEnabledToggle = nil

local fovNotifyTask = nil
local smoothNotifyTask = nil
local triggerDelayNotifyTask = nil
local distanceLimitNotifyTask = nil
local espDistanceNotifyTask = nil
local espUpdateFreqNotifyTask = nil
local espTextSizeNotifyTask = nil
local lodDistanceNotifyTask = nil
local walkSpeedNotifyTask = nil
local jumpPowerNotifyTask = nil
local flySpeedNotifyTask = nil
local tpWalkSpeedNotifyTask = nil
local cameraFOVNotifyTask = nil

local ScreenGui = Instance.new("ScreenGui", game.CoreGui)
ScreenGui.Name = "DShubV3"
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
ScreenGui.ResetOnSpawn = false

local TargetCham = Instance.new("Highlight")
TargetCham.Name = "TargetHighlight"
TargetCham.Parent = ScreenGui 
TargetCham.FillColor = Color3.fromRGB(255, 50, 50)
TargetCham.OutlineColor = Color3.fromRGB(255, 255, 255)
TargetCham.FillTransparency = 0.2
TargetCham.OutlineTransparency = 0
TargetCham.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
TargetCham.Enabled = false

local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Thickness = 1.5
FOVCircle.Radius = 150
table.insert(AllDrawings, FOVCircle)

local NotificationContainer = Instance.new("Frame", ScreenGui)
NotificationContainer.Name = "NotificationContainer"
NotificationContainer.Size = UDim2.new(0, 300, 0, 300)
NotificationContainer.AnchorPoint = Vector2.new(1, 1)
NotificationContainer.Position = UDim2.new(1, -20, 1, -20)
NotificationContainer.BackgroundTransparency = 1
NotificationContainer.ClipsDescendants = false

local UIList = Instance.new("UIListLayout", NotificationContainer)
UIList.Padding = UDim.new(0, 8)
UIList.SortOrder = Enum.SortOrder.LayoutOrder
UIList.VerticalAlignment = Enum.VerticalAlignment.Bottom

local layoutOrderCounter = 0
local maxNotifications = 10

local function cleanupOldNotifications()
    local frames = {}
    for _, child in ipairs(NotificationContainer:GetChildren()) do
        if child:IsA("Frame") then table.insert(frames, child) end
    end
    if #frames <= maxNotifications then return end
    table.sort(frames, function(a,b) return (a.LayoutOrder or 0) < (b.LayoutOrder or 0) end)
    while #frames > maxNotifications do
        local oldest = table.remove(frames, 1)
        if oldest and oldest.Parent then oldest:Destroy() end
    end
end

local function ShowMenuNotification(text)
    if not getgenv().DShub.Aimbot.Settings.NotificationsEnabled then return end
    if not text then return end
    layoutOrderCounter = layoutOrderCounter + 1

    local notif = Instance.new("Frame", NotificationContainer)
    notif.Size = UDim2.new(0, 300, 0, 50)
    notif.BackgroundTransparency = 1
    notif.BorderSizePixel = 0
    notif.LayoutOrder = layoutOrderCounter
    notif.ZIndex = 1000
    notif.ClipsDescendants = false

    local bg = Instance.new("Frame", notif)
    bg.Size = UDim2.new(1, 0, 1, 0)
    bg.Position = UDim2.new(0, 0, 0, 0)
    bg.BackgroundColor3 = Color3.new(0, 0, 0)
    bg.BackgroundTransparency = 0.2
    bg.BorderSizePixel = 0
    bg.ZIndex = 999
    local bgCorner = Instance.new("UICorner", bg)
    bgCorner.CornerRadius = UDim.new(0, 8)

    local NotificationLabel = Instance.new("TextLabel", notif)
    NotificationLabel.Size = UDim2.new(1, -20, 1, 0)
    NotificationLabel.Position = UDim2.new(0, 10, 0, 0)
    NotificationLabel.BackgroundTransparency = 1
    NotificationLabel.TextColor3 = Color3.new(1, 1, 1)
    NotificationLabel.TextXAlignment = Enum.TextXAlignment.Left
    NotificationLabel.Font = Enum.Font.GothamBold
    NotificationLabel.TextSize = 16
    NotificationLabel.Text = text
    NotificationLabel.TextWrapped = true
    NotificationLabel.ZIndex = 1001

    notif.Size = UDim2.new(0, 300, 0, 0)
    notif:TweenSize(UDim2.new(0, 300, 0, 50), "Out", "Quad", 0.2, true, function()
        cleanupOldNotifications()
    end)

    task.delay(3, function()
        if notif and notif.Parent then
            notif:TweenSize(UDim2.new(0, 300, 0, 0), "Out", "Quad", 0.2, true, function()
                notif:Destroy()
            end)
        end
    end)
end

getgenv().DShub = {}
local Aimbot = { Settings = {}, FOVSettings = {} }
local WallHack = { Settings = {}, Visuals = {}, Crosshair = { Settings = {} } }
getgenv().DShub.Aimbot = Aimbot
getgenv().DShub.WallHack = WallHack
local Teleport = { Settings = {} }
getgenv().DShub.Teleport = Teleport
local PlayerLib = { Settings = {} }
getgenv().DShub.Player = PlayerLib

local ok, LibrarySource = pcall(function()
    return game:GetObjects("rbxassetid://7657867786")[1].Source
end)
local Library
if ok and typeof(LibrarySource) == "string" then
    Library = loadstring(LibrarySource)()
else
    Library = {}
    function Library:CreateWindow(_) 
        local dummy = {}
        function dummy:CreateTab(_) return { CreateSection = function() return {} end } end
        dummy.UnloadCallback = nil
        function dummy.ResetAll() end
        function dummy.Unload() end
        return dummy
    end
end

Library.UnloadCallback = function()
    for _, conn in ipairs(Connections) do if conn then conn:Disconnect() end end
    Connections = {}
    for _, drawing in ipairs(AllDrawings) do if drawing then drawing:Remove() end end
    AllDrawings = {}
    for _, cham in ipairs(AllChams) do if cham then cham:Destroy() end end
    AllChams = {}
    if ScreenGui then ScreenGui:Destroy() end
    StopJerk()
    if flyVelocity then flyVelocity:Destroy() end
    stopSpectatingLogic()
    if TargetCham then TargetCham:Destroy() end
    if FOVCircle then FOVCircle:Remove() end
    getgenv().DShub = nil
end

local MainFrame = Library:CreateWindow({
    Name = "DShub V4",
    Themeable = {
        Image = "7059346386",
        Info = "This Script is made by Dosi",
        Credit = false
    },
    Background = ""
})

local AimbotTab = MainFrame:CreateTab({ Name = "Aimbot" })
local VisualsTab = MainFrame:CreateTab({ Name = "Visuals" })
local PlayerTab = MainFrame:CreateTab({ Name = "Player" })
local TeleportTab = MainFrame:CreateTab({ Name = "Teleport" })

local Settings = getgenv().DShub.Aimbot.Settings

Settings.AimbotEnabled = true
Settings.TargetPart = "Head"
Settings.LockKey = Enum.UserInputType.MouseButton2
Settings.ToggleKey = Enum.KeyCode.RightShift
Settings.TriggerToggleKey = Enum.KeyCode.T
Settings.AimbotToggleKey = Enum.KeyCode.Y
Settings.AimbotType = "Camera" 
Settings.FOV = 150
Settings.FOVCircleColor = Color3.fromRGB(255, 255, 255)
Settings.FOVCircleVisible = true
Settings.Smoothing = 5
Settings.WallCheck = true
Settings.TeamCheck = false
Settings.DeadCheck = true
Settings.Sticky = true
Settings.ForceFieldCheck = true
Settings.TriggerBotMode = "None"
Settings.LastTriggerMode = "FOV"
Settings.TriggerDelay = 150
Settings.TriggerDistance = 1000
Settings.TargetHighlightEnabled = false
Settings.SkeletonEnabled = false
Settings.SkeletonOutlineEnabled = false
Settings.BoxEnabled = false
Settings.BoxOutlineEnabled = false
Settings.NameEnabled = false
Settings.NameOutlineEnabled = false
Settings.HeadDotEnabled = false
Settings.ChamsEnabled = false
Settings.HealthMode = "None"
Settings.ESPDistance = 5000
Settings.LODDistance = 500
Settings.ESPUpdateFrequency = 1
Settings.ESPTextSize = 16
Settings.ESPMaxTargets = 5
Settings.ESPDetailThreshold = 10
Settings.WalkSpeed = 16
Settings.JumpPower = 50
Settings.LockFOV = false
Settings.FlyEnabled = false
Settings.FlySpeed = 50
Settings.NoclipEnabled = false
Settings.TpWalkEnabled = false
Settings.TpWalkInterval = 2000
Settings.TpWalkStep = 3
Settings.TpWalkSpeed = Settings.TpWalkStep
Settings.InfiniteJumpEnabled = false
Settings.JerkEnabled = false
Settings.JerkR15Enabled = false
Settings.CameraFOV = 70
Settings.ThirdPersonEnabled = false
Settings.NotificationsEnabled = true
Settings.SkeletonESPColor = Color3.fromRGB(255, 255, 255)
Settings.SkeletonOutlineColor = Color3.fromRGB(0, 0, 0)
Settings.HeadDotESPColor = Color3.fromRGB(255, 0, 0)
Settings.ChamsTeamColor = Color3.fromRGB(0, 0, 255)
Settings.ChamsEnemyColor = Color3.fromRGB(255, 0, 0)
Settings.ChamsOccludedColor = Color3.fromRGB(0, 255, 0)
Settings.NameESPTeamColor = Color3.fromRGB(0, 150, 255)
Settings.NameESPEnemyColor = Color3.fromRGB(255, 0, 0)
Settings.NameESPOccludedColor = Color3.fromRGB(0, 255, 0)
Settings.NameOutlineColor = Color3.fromRGB(0, 0, 0)
Settings.BoxESPTeamColor = Color3.fromRGB(0, 150, 255)
Settings.BoxESPEnemyColor = Color3.fromRGB(255, 0, 0)
Settings.BoxESPOccludedColor = Color3.fromRGB(0, 255, 0)
Settings.BoxOutlineColor = Color3.fromRGB(0, 0, 0)
Settings.TargetDistanceCheck = "Mouse"
Settings.DistanceESPEnabled = false
Settings.DistanceESPColor = Color3.fromRGB(255, 255, 255)
Settings.DistanceESPOutlineEnabled = true
Settings.PredictionEnabled = false
Settings.PredictionRange = 28

FOVCircle.Visible = Settings.AimbotEnabled and Settings.FOVCircleVisible
FOVCircle.Radius = Settings.FOV
FOVCircle.Color = Settings.FOVCircleColor

local AimSection = AimbotTab:CreateSection({ Name = "Aimbot" })
AimbotEnabledToggle = AimSection:AddToggle({ Name = "Enabled", Flag = "Aimbot_Enabled", Value = Settings.AimbotEnabled, Callback = function(val) Settings.AimbotEnabled = val end })
AimKeyButton = AimSection:AddButton({ Name = "Aimbot Key: " .. tostring(Settings.LockKey.Name), Callback = function() Settings.IsBindingLock = true; ShowMenuNotification("Press any key to bind Aimbot Lock..."); if AimKeyButton then AimKeyButton:SetText("Press Any Key...") end end })
AimbotToggleKeyButton = AimSection:AddButton({ Name = "Aimbot Toggle Key: " .. tostring(Settings.AimbotToggleKey.Name), Callback = function() Settings.IsBindingAimbotToggle = true; ShowMenuNotification("Press any key to bind Aimbot Toggle..."); if AimbotToggleKeyButton then AimbotToggleKeyButton:SetText("Press Any Key...") end end })
AimSection:AddToggle({ Name = "Hard Sticky", Flag = "Aimbot_Sticky", Value = Settings.Sticky, Callback = function(val) Settings.Sticky = val; ShowMenuNotification("Hard Sticky " .. (val and "Enabled" or "Disabled")) end })
AimSection:AddToggle({ Name = "Dead Check", Flag = "Aimbot_DeadCheck", Value = Settings.DeadCheck, Callback = function(val) Settings.DeadCheck = val; ShowMenuNotification("Dead Check " .. (val and "Enabled" or "Disabled")) end })
AimSection:AddToggle({ Name = "Wall Check", Flag = "Aimbot_WallCheck", Value = Settings.WallCheck, Callback = function(val) Settings.WallCheck = val; ShowMenuNotification("Wall Check " .. (val and "Enabled" or "Disabled")) end })
AimSection:AddToggle({ Name = "Team Check", Flag = "Aimbot_TeamCheck", Value = Settings.TeamCheck, Callback = function(val) Settings.TeamCheck = val; ShowMenuNotification("Team Check " .. (val and "Enabled" or "Disabled")) end })
AimSection:AddToggle({ Name = "FF Check", Flag = "Aimbot_FFCheck", Value = Settings.ForceFieldCheck, Callback = function(val) Settings.ForceFieldCheck = val; ShowMenuNotification("FF Check " .. (val and "Enabled" or "Disabled")) end })
AimSection:AddToggle({ Name = "Target Highlight", Flag = "Aimbot_Highlight", Value = Settings.TargetHighlightEnabled, Callback = function(val) Settings.TargetHighlightEnabled = val; ShowMenuNotification("Target Highlight " .. (val and "Enabled" or "Disabled")) end })

local TrigSection = AimbotTab:CreateSection({ Name = "TriggerBot" })
TrigKeyButton = TrigSection:AddButton({ Name = "Trigger Key: " .. tostring(Settings.TriggerToggleKey.Name), Callback = function() Settings.IsBindingTrigger = true; ShowMenuNotification("Press any key to bind TriggerBot..."); if TrigKeyButton then TrigKeyButton:SetText("Press Any Key...") end end })
TrigFOVToggle = TrigSection:AddToggle({ Name = "Trigger: FOV Mode", Flag = "Trigger_FOV", Value = (Settings.TriggerBotMode == "FOV"), Callback = function(val) if val then Settings.TriggerBotMode = "FOV"; Settings.LastTriggerMode = "FOV"; if Trig180Toggle then Trig180Toggle:Set(false) end else if Settings.TriggerBotMode == "FOV" then Settings.TriggerBotMode = "None" end end; ShowMenuNotification("Trigger FOV Mode " .. (val and "Enabled" or "Disabled")) end })
Trig180Toggle = TrigSection:AddToggle({ Name = "Trigger: 180 Mode", Flag = "Trigger_180", Value = (Settings.TriggerBotMode == "180"), Callback = function(val) if val then Settings.TriggerBotMode = "180"; Settings.LastTriggerMode = "180"; if TrigFOVToggle then TrigFOVToggle:Set(false) end else if Settings.TriggerBotMode == "180" then Settings.TriggerBotMode = "None" end end; ShowMenuNotification("Trigger 180 Mode " .. (val and "Enabled" or "Disabled")) end })
TrigSection:AddSlider({ Name = "Trigger Delay (ms)", Flag = "Aimbot_TriggerDelay", Value = Settings.TriggerDelay, Min = 0, Max = 5000, Increment = 1, Callback = function(val) Settings.TriggerDelay = math.floor(val); if triggerDelayNotifyTask then task.cancel(triggerDelayNotifyTask) end; triggerDelayNotifyTask = task.delay(0.5, function() ShowMenuNotification("Trigger Delay set to " .. Settings.TriggerDelay .. " ms") end) end })

local TypeSection = AimbotTab:CreateSection({ Name = "Aimbot Type", Side = "Right" })
TypeCamToggle = TypeSection:AddToggle({ Name = "Type: Camera (Screen)", Flag = "Type_Camera", Value = (Settings.AimbotType == "Camera"), Callback = function(val) if val then Settings.AimbotType = "Camera"; if TypeMouseToggle then TypeMouseToggle:Set(false) end else if not (TypeMouseToggle and TypeMouseToggle:Get()) then Settings.AimbotType = "Camera"; TypeCamToggle:Set(true) end end; ShowMenuNotification("Aimbot Type set to Camera") end })
TypeMouseToggle = TypeSection:AddToggle({ Name = "Type: Mouse (Cursor)", Flag = "Type_Mouse", Value = (Settings.AimbotType == "Mouse"), Callback = function(val) if val then Settings.AimbotType = "Mouse"; if TypeCamToggle then TypeCamToggle:Set(false) end else if not (TypeCamToggle and TypeCamToggle:Get()) then Settings.AimbotType = "Camera"; TypeCamToggle:Set(true) end end; ShowMenuNotification("Aimbot Type set to Mouse") end })

local DistSection = AimbotTab:CreateSection({ Name = "Aimbot Distance Check", Side = "Right" })
CheckMouseToggle = DistSection:AddToggle({ Name = "Check: Mouse Distance", Flag = "Check_Mouse", Value = (Settings.TargetDistanceCheck == "Mouse"), Callback = function(val) if val then Settings.TargetDistanceCheck = "Mouse"; if CheckWorldToggle then CheckWorldToggle:Set(false) end else if not (CheckWorldToggle and CheckWorldToggle:Get()) then Settings.TargetDistanceCheck = "Mouse"; CheckMouseToggle:Set(true) end end; ShowMenuNotification("Distance Check set to Mouse") end })
CheckWorldToggle = DistSection:AddToggle({ Name = "Check: World Distance", Flag = "Check_World", Value = (Settings.TargetDistanceCheck == "World"), Callback = function(val) if val then Settings.TargetDistanceCheck = "World"; if CheckMouseToggle then CheckMouseToggle:Set(false) end else if not (CheckMouseToggle and CheckMouseToggle:Get()) then Settings.TargetDistanceCheck = "Mouse"; CheckMouseToggle:Set(true) end end; ShowMenuNotification("Distance Check set to World") end })
if CheckMouseToggle then CheckMouseToggle:Set(true) end

local AimMiscSection = AimbotTab:CreateSection({ Name = "Aimbot Misc", Side = "Right" })
AimMiscSection:AddToggle({ Name = "FOV Circle Visible", Flag = "Aimbot_FOVCircle", Value = Settings.FOVCircleVisible, Callback = function(val) Settings.FOVCircleVisible = val; if FOVCircle then FOVCircle.Visible = Settings.AimbotEnabled and val end; ShowMenuNotification("FOV Circle " .. (val and "Visible" or "Hidden")) end })
AimMiscSection:AddSlider({ Name = "FOV", Flag = "Aimbot_FOV", Value = Settings.FOV, Min = 0, Max = 800, Increment = 1, Callback = function(val) Settings.FOV = val; if FOVCircle then FOVCircle.Radius = val end; if fovNotifyTask then task.cancel(fovNotifyTask) end; fovNotifyTask = task.delay(0.5, function() ShowMenuNotification("FOV set to " .. val) end) end })
AimMiscSection:AddSlider({ Name = "Smooth", Flag = "Aimbot_Smooth", Value = Settings.Smoothing, Min = 0, Max = 20, Increment = 1, Callback = function(val) Settings.Smoothing = val; if smoothNotifyTask then task.cancel(smoothNotifyTask) end; smoothNotifyTask = task.delay(0.5, function() ShowMenuNotification("Smooth set to " .. val) end) end })
AimMiscSection:AddSlider({ Name = "Aimbot Distance Limit", Flag = "Aimbot_TriggerDistance", Value = Settings.TriggerDistance, Min = 10, Max = 10000, Increment = 1, Callback = function(val) Settings.TriggerDistance = val; if distanceLimitNotifyTask then task.cancel(distanceLimitNotifyTask) end; distanceLimitNotifyTask = task.delay(0.5, function() ShowMenuNotification("Aimbot Distance Limit set to " .. val) end) end })
AimMiscSection:AddColorPicker({ Name = "FOV Circle Color", Flag = "Aimbot_FOVCircleColor", Value = Settings.FOVCircleColor, Callback = function(val) Settings.FOVCircleColor = val; if FOVCircle then FOVCircle.Color = val end end })

local PredictionSection = AimbotTab:CreateSection({ Name = "Prediction Setting" })
local PredictionToggle = PredictionSection:AddToggle({ Name = "Enabled", Flag = "Prediction_Enabled", Value = Settings.PredictionEnabled, Callback = function(val) Settings.PredictionEnabled = val; ShowMenuNotification("Prediction " .. (val and "Enabled" or "Disabled")) end })
PredictionSection:AddSlider({ Name = "Prediction Range", Flag = "Prediction_Range", Value = Settings.PredictionRange, Min = 0, Max = 100, Increment = 1, Callback = function(val) Settings.PredictionRange = val; if predictionRangeNotifyTask then task.cancel(predictionRangeNotifyTask) end; predictionRangeNotifyTask = task.delay(0.5, function() ShowMenuNotification("Prediction Range set to " .. val) end) end })

local VisualsSection = VisualsTab:CreateSection({ Name = "Visuals Settings" })
VisualsSection:AddToggle({ Name = "Skeleton ESP", Flag = "ESP_Skeleton", Value = Settings.SkeletonEnabled, Callback = function(val) Settings.SkeletonEnabled = val; ShowMenuNotification("Skeleton ESP " .. (val and "Enabled" or "Disabled")) end })
VisualsSection:AddToggle({ Name = "Skeleton ESP Outlines", Flag = "ESP_SkeletonOutlines", Value = Settings.SkeletonOutlineEnabled, Callback = function(val) Settings.SkeletonOutlineEnabled = val; ShowMenuNotification("Skeleton ESP Outlines " .. (val and "Enabled" or "Disabled")) end })
VisualsSection:AddToggle({ Name = "Box ESP", Flag = "ESP_Box", Value = Settings.BoxEnabled, Callback = function(val) Settings.BoxEnabled = val; ShowMenuNotification("Box ESP " .. (val and "Enabled" or "Disabled")) end })
VisualsSection:AddToggle({ Name = "Box ESP Outlines", Flag = "ESP_BoxOutlines", Value = Settings.BoxOutlineEnabled, Callback = function(val) Settings.BoxOutlineEnabled = val; ShowMenuNotification("Box ESP Outlines " .. (val and "Enabled" or "Disabled")) end })
VisualsSection:AddToggle({ Name = "Name ESP", Flag = "ESP_Name", Value = Settings.NameEnabled, Callback = function(val) Settings.NameEnabled = val; ShowMenuNotification("Name ESP " .. (val and "Enabled" or "Disabled")) end })
VisualsSection:AddToggle({ Name = "Name ESP Outlines", Flag = "ESP_NameOutlines", Value = Settings.NameOutlineEnabled, Callback = function(val) Settings.NameOutlineEnabled = val; ShowMenuNotification("Name ESP Outlines " .. (val and "Enabled" or "Disabled")) end })
VisualsSection:AddToggle({ Name = "Head Dot", Flag = "ESP_HeadDot", Value = Settings.HeadDotEnabled, Callback = function(val) Settings.HeadDotEnabled = val; ShowMenuNotification("Head Dot " .. (val and "Enabled" or "Disabled")) end })
VisualsSection:AddToggle({ Name = "Chams", Flag = "ESP_Chams", Value = Settings.ChamsEnabled, Callback = function(val) Settings.ChamsEnabled = val; ShowMenuNotification("Chams " .. (val and "Enabled" or "Disabled")) end })

local healthBarToggle = false
local healthTextToggle = false
VisualsSection:AddToggle({
    Name = "Health Bars", Flag = "ESP_HealthBars", Value = (Settings.HealthMode == "Bar" or Settings.HealthMode == "Both"),
    Callback = function(val) healthBarToggle = val; if healthBarToggle and healthTextToggle then Settings.HealthMode = "Both" elseif healthBarToggle then Settings.HealthMode = "Bar" elseif healthTextToggle then Settings.HealthMode = "Text" else Settings.HealthMode = "None" end; ShowMenuNotification("Health Bars " .. (val and "Enabled" or "Disabled")) end
})
VisualsSection:AddToggle({
    Name = "Health Text", Flag = "ESP_HealthText", Value = (Settings.HealthMode == "Text" or Settings.HealthMode == "Both"),
    Callback = function(val) healthTextToggle = val; if healthBarToggle and healthTextToggle then Settings.HealthMode = "Both" elseif healthBarToggle then Settings.HealthMode = "Bar" elseif healthTextToggle then Settings.HealthMode = "Text" else Settings.HealthMode = "None" end; ShowMenuNotification("Health Text " .. (val and "Enabled" or "Disabled")) end
})
VisualsSection:AddToggle({ Name = "Distance ESP(Studs)", Flag = "ESP_DistanceESP", Value = Settings.DistanceESPEnabled, Callback = function(val) Settings.DistanceESPEnabled = val; ShowMenuNotification("Distance ESP " .. (val and "Enabled" or "Disabled")) end })
VisualsSection:AddToggle({ Name = "Distance ESP Outlines", Flag = "ESP_DistanceESPOutlines", Value = Settings.DistanceESPOutlineEnabled, Callback = function(val) Settings.DistanceESPOutlineEnabled = val; ShowMenuNotification("Distance ESP Outlines " .. (val and "Enabled" or "Disabled")) end })
VisualsSection:AddSlider({ Name = "ESP Distance", Flag = "ESP_Distance", Value = Settings.ESPDistance, Min = 10, Max = 15000, Increment = 1, Callback = function(val) Settings.ESPDistance = val; if espDistanceNotifyTask then task.cancel(espDistanceNotifyTask) end; espDistanceNotifyTask = task.delay(0.5, function() ShowMenuNotification("ESP Distance set to " .. val) end) end })
VisualsSection:AddSlider({ Name = "ESP Text Size", Flag = "ESP_TextSize", Value = Settings.ESPTextSize, Min = 10, Max = 50, Increment = 1, Callback = function(val) Settings.ESPTextSize = val; if espTextSizeNotifyTask then task.cancel(espTextSizeNotifyTask) end; espTextSizeNotifyTask = task.delay(0.5, function() ShowMenuNotification("ESP Text Size set to " .. val) end) end })
VisualsSection:AddSlider({ Name = "LOD Distance", Flag = "ESP_LODDistance", Value = Settings.LODDistance, Min = 100, Max = 5000, Increment = 10, Callback = function(val) Settings.LODDistance = val; if lodDistanceNotifyTask then task.cancel(lodDistanceNotifyTask) end; lodDistanceNotifyTask = task.delay(0.5, function() ShowMenuNotification("LOD Distance set to " .. val) end) end })
VisualsSection:AddSlider({ Name = "ESP Update Frequency", Flag = "ESP_UpdateFrequency", Value = Settings.ESPUpdateFrequency, Min = 1, Max = 20, Increment = 1, Callback = function(val) Settings.ESPUpdateFrequency = val; if espUpdateFreqNotifyTask then task.cancel(espUpdateFreqNotifyTask) end; espUpdateFreqNotifyTask = task.delay(0.5, function() ShowMenuNotification("ESP Update Frequency set to " .. val) end) end })


local VisualsMiscSection = VisualsTab:CreateSection({ Name = "Visuals Misc", Side = "Right" })
VisualsMiscSection:AddColorPicker({ Name = "Name ESP Team Color", Flag = "ESP_NameTeamColor", Value = Settings.NameESPTeamColor, Callback = function(val) Settings.NameESPTeamColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Name ESP Enemy Color", Flag = "ESP_NameEnemyColor", Value = Settings.NameESPEnemyColor, Callback = function(val) Settings.NameESPEnemyColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Name ESP Occluded Color", Flag = "ESP_NameOccludedColor", Value = Settings.NameESPOccludedColor, Callback = function(val) Settings.NameESPOccludedColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Name ESP Outlines Color", Flag = "ESP_NameOutlinesColor", Value = Settings.NameOutlineColor, Callback = function(val) Settings.NameOutlineColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Box ESP Team Color", Flag = "ESP_BoxTeamColor", Value = Settings.BoxESPTeamColor, Callback = function(val) Settings.BoxESPTeamColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Box ESP Enemy Color", Flag = "ESP_BoxEnemyColor", Value = Settings.BoxESPEnemyColor, Callback = function(val) Settings.BoxESPEnemyColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Box ESP Occluded Color", Flag = "ESP_BoxOccludedColor", Value = Settings.BoxESPOccludedColor, Callback = function(val) Settings.BoxESPOccludedColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Box ESP Outlines Color", Flag = "ESP_BoxOutlinesColor", Value = Settings.BoxOutlineColor, Callback = function(val) Settings.BoxOutlineColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Skeleton ESP Color", Flag = "ESP_SkeletonColor", Value = Settings.SkeletonESPColor, Callback = function(val) Settings.SkeletonESPColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Skeleton ESP Outlines Color", Flag = "ESP_SkeletonOutlinesColor", Value = Settings.SkeletonOutlineColor, Callback = function(val) Settings.SkeletonOutlineColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Head Dot Color", Flag = "ESP_HeadDotColor", Value = Settings.HeadDotESPColor, Callback = function(val) Settings.HeadDotESPColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Chams Team Color", Flag = "ESP_ChamsTeamColor", Value = Settings.ChamsTeamColor, Callback = function(val) Settings.ChamsTeamColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Chams Enemy Color", Flag = "ESP_ChamsEnemyColor", Value = Settings.ChamsEnemyColor, Callback = function(val) Settings.ChamsEnemyColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Chams Occluded Color", Flag = "ESP_ChamsOccludedColor", Value = Settings.ChamsOccludedColor, Callback = function(val) Settings.ChamsOccludedColor = val end })
VisualsMiscSection:AddColorPicker({ Name = "Distance Esp Color", Flag = "ESP_DistanceColor", Value = Settings.DistanceESPColor, Callback = function(val) Settings.DistanceESPColor = val end })

local function StopJerk()
    for _, conn in pairs(JerkAnims) do conn:Disconnect() end
    JerkAnims = {}
    if R15Track then R15Track:Stop(); R15Track = nil end
end

local function PlayJerkAnim(id, startPos, endPos)
    local char = LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if hum then
        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://" .. id
        local track = hum:LoadAnimation(anim)
        local conn = RunService.RenderStepped:Connect(function()
            if Settings.JerkEnabled then
                if endPos <= track.TimePosition or not track.IsPlaying then
                    track:Play()
                    track.TimePosition = startPos
                end
            else track:Stop() end
        end)
        table.insert(JerkAnims, conn)
        track:Play()
        track.TimePosition = startPos
    end
end

local function PlayJerkR15()
    local char = LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if hum then
        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://698251653"
        R15Track = hum:LoadAnimation(anim)
        R15Track.Looped = false
        R15Track:Play()
        R15Track.TimePosition = 0.58
        R15Track:AdjustSpeed(0.4)
        task.spawn(function()
            while R15Track and R15Track.IsPlaying and Settings.JerkR15Enabled do
                if R15Track.TimePosition >= 0.63 then R15Track.TimePosition = 0.58 end
                task.wait()
            end
            if R15Track then R15Track:Stop() end
        end)
    end
end

local PlayerSection = PlayerTab:CreateSection({ Name = "Character Settings" })
PlayerSection:AddToggle({
    Name = "Third Person", Flag = "Player_ThirdPerson", Value = Settings.ThirdPersonEnabled,
    Callback = function(val)
        Settings.ThirdPersonEnabled = val
        if val then
            if not SavedCameraState then
                pcall(function() if LocalPlayer then SavedCameraState = { Mode = LocalPlayer.CameraMode, MaxZoom = LocalPlayer.CameraMaxZoomDistance, MinZoom = LocalPlayer.CameraMinZoomDistance } end end)
            end
            if not UnlockConnection then
                UnlockConnection = RunService.RenderStepped:Connect(function()
                    if LocalPlayer then
                        LocalPlayer.CameraMode = Enum.CameraMode.Classic
                        if LocalPlayer.CameraMaxZoomDistance < 128 then LocalPlayer.CameraMaxZoomDistance = 128 end
                        if LocalPlayer.CameraMinZoomDistance > 0.5 then LocalPlayer.CameraMinZoomDistance = 0.5 end
                    end
                end)
            end
        else
            if UnlockConnection then pcall(function() UnlockConnection:Disconnect() end); UnlockConnection = nil end
            if SavedCameraState then
                pcall(function() LocalPlayer.CameraMode = SavedCameraState.Mode; LocalPlayer.CameraMaxZoomDistance = SavedCameraState.MaxZoom; LocalPlayer.CameraMinZoomDistance = SavedCameraState.MinZoom end)
                SavedCameraState = nil
            else LocalPlayer.CameraMode = Enum.CameraMode.Classic; LocalPlayer.CameraMaxZoomDistance = 128; LocalPlayer.CameraMinZoomDistance = 0.5 end
        end
        ShowMenuNotification("Third Person " .. (val and "Enabled" or "Disabled"))
    end
})
PlayerSection:AddToggle({ Name = "Jerk R6 Mode", Flag = "Player_JerkR6", Value = Settings.JerkEnabled, Callback = function(val) Settings.JerkEnabled = val; if val then Settings.JerkR15Enabled = false; StopJerk(); PlayJerkAnim("72042024", 0.5, 0.9); PlayJerkAnim("168268306", 1, 1.001) else StopJerk() end; ShowMenuNotification("Jerk R6 Mode " .. (val and "Enabled" or "Disabled")) end })
PlayerSection:AddToggle({ Name = "Jerk R15 Mode", Flag = "Player_JerkR15", Value = Settings.JerkR15Enabled, Callback = function(val) Settings.JerkR15Enabled = val; if val then Settings.JerkEnabled = false; StopJerk(); PlayJerkR15() else StopJerk() end; ShowMenuNotification("Jerk R15 Mode " .. (val and "Enabled" or "Disabled")) end })
PlayerSection:AddSlider({ Name = "WalkSpeed", Flag = "Player_WalkSpeed", Value = Settings.WalkSpeed, Min = 1, Max = 200, Increment = 1, Callback = function(val) Settings.WalkSpeed = val; if walkSpeedNotifyTask then task.cancel(walkSpeedNotifyTask) end; walkSpeedNotifyTask = task.delay(0.5, function() ShowMenuNotification("WalkSpeed set to " .. val) end) end })
PlayerSection:AddSlider({ Name = "JumpPower", Flag = "Player_JumpPower", Value = Settings.JumpPower, Min = 1, Max = 500, Increment = 1, Callback = function(val) Settings.JumpPower = val; if jumpPowerNotifyTask then task.cancel(jumpPowerNotifyTask) end; jumpPowerNotifyTask = task.delay(0.5, function() ShowMenuNotification("JumpPower set to " .. val) end) end })
PlayerSection:AddToggle({ Name = "Lock Speed & JumpPower", Flag = "Player_LockSpeed", Value = Settings.LockSpeedJump, Callback = function(val) Settings.LockSpeedJump = val; ShowMenuNotification("Lock Speed & JumpPower " .. (val and "Enabled" or "Disabled")) end })
PlayerSection:AddToggle({ Name = "Fly Enabled", Flag = "Player_Fly", Value = Settings.FlyEnabled, Callback = function(val) Settings.FlyEnabled = val; ShowMenuNotification("Fly " .. (val and "Enabled" or "Disabled")) end })
PlayerSection:AddSlider({ Name = "Fly Speed", Flag = "Player_FlySpeed", Value = Settings.FlySpeed, Min = 10, Max = 500, Increment = 1, Callback = function(val) Settings.FlySpeed = val; if flySpeedNotifyTask then task.cancel(flySpeedNotifyTask) end; flySpeedNotifyTask = task.delay(0.5, function() ShowMenuNotification("Fly Speed set to " .. val) end) end })
PlayerSection:AddToggle({ Name = "Noclip", Flag = "Player_Noclip", Value = Settings.NoclipEnabled, Callback = function(val) Settings.NoclipEnabled = val; ShowMenuNotification("Noclip " .. (val and "Enabled" or "Disabled")) end })
PlayerSection:AddToggle({ Name = "TpWalk Enabled", Flag = "Player_TpWalk", Value = Settings.TpWalkEnabled, Callback = function(val) Settings.TpWalkEnabled = val; ShowMenuNotification("TpWalk " .. (val and "Enabled" or "Disabled")) end })
PlayerSection:AddSlider({ Name = "TpWalk Speed (stud/s)", Flag = "Player_TpWalkSpeed", Value = Settings.TpWalkStep, Min = 1, Max = 300, Increment = 1, Callback = function(val) Settings.TpWalkStep = math.floor(val * 10) / 10; Settings.TpWalkSpeed = Settings.TpWalkStep; if tpWalkSpeedNotifyTask then task.cancel(tpWalkSpeedNotifyTask) end; tpWalkSpeedNotifyTask = task.delay(0.5, function() ShowMenuNotification("TpWalk Speed set to " .. Settings.TpWalkStep) end) end })
PlayerSection:AddToggle({ Name = "Infinite Jump", Flag = "Player_InfiniteJump", Value = Settings.InfiniteJumpEnabled, Callback = function(val) Settings.InfiniteJumpEnabled = val; ShowMenuNotification("Infinite Jump " .. (val and "Enabled" or "Disabled")) end })
PlayerSection:AddSlider({ Name = "Camera FOV", Flag = "Player_CameraFOV", Value = Settings.CameraFOV, Min = 1, Max = 120, Increment = 1, Callback = function(val) Settings.CameraFOV = val; Camera.FieldOfView = val; if cameraFOVNotifyTask then task.cancel(cameraFOVNotifyTask) end; cameraFOVNotifyTask = task.delay(0.5, function() ShowMenuNotification("Camera FOV set to " .. val) end) end })
PlayerSection:AddToggle({ Name = "Lock FOV", Flag = "Player_LockFOV", Value = Settings.LockFOV, Callback = function(val) Settings.LockFOV = val; ShowMenuNotification("Lock FOV " .. (val and "Enabled" or "Disabled")) end })

local ServerLagSection = PlayerTab:CreateSection({ Name = "Player Misc", Side = "Right" })
ServerLagSection:AddButton({ Name = "Enable Server Lag", Callback = function() loadstring(game:HttpGet("https://raw.githubusercontent.com/dosi1100-cmyk/script/refs/heads/main/Crasher"))() end })
ServerLagSection:AddButton({ Name = "Rejoin", Callback = function() game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId) end })

local TeleportSection = TeleportTab:CreateSection({ Name = "Teleport Settings" })
local SelectedPlayer = nil
local TeleportFrontToggle = nil
local TeleportBackToggle = nil
local TeleportLeftToggle = nil
local TeleportRightToggle = nil

local function checkAllOff()
    return not ((TeleportFrontToggle and TeleportFrontToggle:Get()) or (TeleportBackToggle and TeleportBackToggle:Get()) or (TeleportLeftToggle and TeleportLeftToggle:Get()) or (TeleportRightToggle and TeleportRightToggle:Get()))
end

local function GetPlayerListFormatted()
    local list = {}
    for _, p in pairs(Players:GetPlayers()) do if p ~= LocalPlayer then table.insert(list, p.DisplayName .. " (@" .. p.Name .. ")") end end
    return list
end

local PlayerListFrame = Instance.new("Frame", ScreenGui)
PlayerListFrame.Name = "PlayerListFrame"
PlayerListFrame.Size = UDim2.new(0, 300, 0, 460)
PlayerListFrame.Position = UDim2.new(0.8, -300, 0.2, 0)
PlayerListFrame.BackgroundColor3 = Color3.new(0, 0, 0)
PlayerListFrame.BackgroundTransparency = 0.3
PlayerListFrame.BorderSizePixel = 2
PlayerListFrame.BorderColor3 = Color3.new(1, 1, 1)
PlayerListFrame.Visible = false
PlayerListFrame.Active = true

local TitleBar = Instance.new("Frame", PlayerListFrame)
TitleBar.Name = "TitleBar"
TitleBar.Size = UDim2.new(1, 0, 0, 30)
TitleBar.BackgroundColor3 = Color3.new(0.1, 0.1, 0.1)
TitleBar.BorderSizePixel = 0

local TitleLabel = Instance.new("TextLabel", TitleBar)
TitleLabel.Name = "TitleLabel"
TitleLabel.Size = UDim2.new(1, 0, 1, 0)
TitleLabel.BackgroundTransparency = 1
TitleLabel.TextColor3 = Color3.new(1, 1, 1)
TitleLabel.Text = "Player List"
TitleLabel.Font = Enum.Font.SourceSansBold
TitleLabel.TextSize = 18
TitleLabel.TextXAlignment = Enum.TextXAlignment.Center

local dragging, dragStart, startPos = false, nil, nil
TitleBar.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = true; dragStart = input.Position; startPos = PlayerListFrame.Position; input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dragging = false end end) end end)
TitleBar.InputChanged:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement and dragging then local delta = input.Position - dragStart; PlayerListFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y) end end)

local ScrollingFrame = Instance.new("ScrollingFrame", PlayerListFrame)
ScrollingFrame.Name = "ScrollingFrame"
ScrollingFrame.Size = UDim2.new(1, 0, 0, 400)
ScrollingFrame.Position = UDim2.new(0, 0, 0, 30)
ScrollingFrame.BackgroundTransparency = 1
ScrollingFrame.ScrollBarThickness = 10
ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)

local ListLabel = Instance.new("TextLabel", ScrollingFrame)
ListLabel.Name = "ListLabel"
ListLabel.Size = UDim2.new(1, -10, 0, 0)
ListLabel.BackgroundTransparency = 1
ListLabel.TextColor3 = Color3.new(1, 1, 1)
ListLabel.Text = ""
ListLabel.TextWrapped = true
ListLabel.Font = Enum.Font.SourceSans
ListLabel.TextSize = 18
ListLabel.TextXAlignment = Enum.TextXAlignment.Left
ListLabel.TextYAlignment = Enum.TextYAlignment.Top
ListLabel.AutomaticSize = Enum.AutomaticSize.Y

local SelectTextBox = Instance.new("TextBox", PlayerListFrame)
SelectTextBox.Name = "SelectTextBox"
SelectTextBox.Size = UDim2.new(1, 0, 0, 30)
SelectTextBox.Position = UDim2.new(0, 0, 0, 430)
SelectTextBox.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
SelectTextBox.TextColor3 = Color3.new(1, 1, 1)
SelectTextBox.PlaceholderText = "Enter number or name"
SelectTextBox.Font = Enum.Font.SourceSans
SelectTextBox.TextSize = 16
SelectTextBox.TextXAlignment = Enum.TextXAlignment.Center

SelectTextBox.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        local input = SelectTextBox.Text
        if input == "" then return end
        local num = tonumber(input)
        local list = {}
        for _, p in pairs(Players:GetPlayers()) do if p ~= LocalPlayer then table.insert(list, p) end end
        if num and list[num] then
            SelectedPlayer = list[num]
            ShowMenuNotification("Selected: " .. list[num].DisplayName .. " (@" .. list[num].Name .. ")")
        else
            local inputLower = input:lower()
            local matches = {}
            for _, p in pairs(list) do if p.Name:lower():find(inputLower, 1, true) or p.DisplayName:lower():find(inputLower, 1, true) then table.insert(matches, p) end end
            if #matches == 1 then SelectedPlayer = matches[1]; ShowMenuNotification("Selected: " .. matches[1].DisplayName .. " (@" .. matches[1].Name .. ")")
            elseif #matches > 1 then ShowMenuNotification("Same name Detected. Type Longer")
            else ShowMenuNotification("No player found with that name!") end
        end
    end
end)

local function updatePlayerList()
    local list = {}
    for _, p in pairs(Players:GetPlayers()) do if p ~= LocalPlayer then table.insert(list, p.DisplayName .. " (@" .. p.Name .. ")") end end
    local text = ""
    for i, name in ipairs(list) do text = text .. string.format("%d-  -%s\n", i, name) end
    ListLabel.Text = text
    ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, ListLabel.TextBounds.Y)
end

TeleportSection:AddButton({
    Name = "Teleport To Selected",
    Callback = function()
        if not SelectedPlayer then ShowMenuNotification("No player selected!"); return end
        if not SelectedPlayer.Character then ShowMenuNotification("Player has no character!"); return end
        local targetHRP = SelectedPlayer.Character:FindFirstChild("HumanoidRootPart") or SelectedPlayer.Character:FindFirstChild("Torso")
        local myChar = LocalPlayer.Character
        local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if targetHRP and myHRP then
             local offset = CFrame.new(0,0,5)
            if Settings.TeleportDirection == "Front" then offset = CFrame.new(0,0,-5)
            elseif Settings.TeleportDirection == "Left" then offset = CFrame.new(-5,0,0)
            elseif Settings.TeleportDirection == "Right" then offset = CFrame.new(5,0,0) end
            pcall(function() myChar:PivotTo(targetHRP.CFrame * offset) end)
            ShowMenuNotification("Teleported to " .. SelectedPlayer.DisplayName)
        end
    end
})

local function stopSpectatingLogic()
    if not spectating then return end
    spectating = false
    spectateTarget = nil
    if restoreCameraState then
        if restoreCameraState.CameraSubject then Camera.CameraSubject = restoreCameraState.CameraSubject end
        if restoreCameraState.CameraType then Camera.CameraType = restoreCameraState.CameraType end
        if restoreCameraState.PlayerCameraMode then LocalPlayer.CameraMode = restoreCameraState.PlayerCameraMode end
        if restoreCameraState.MinZoom then LocalPlayer.CameraMinZoomDistance = restoreCameraState.MinZoom end
        if restoreCameraState.MaxZoom then LocalPlayer.CameraMaxZoomDistance = restoreCameraState.MaxZoom end
    else
        if LocalPlayer and LocalPlayer.Character then
            local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if hum then Camera.CameraSubject = hum end
        end
        Camera.CameraType = Enum.CameraType.Custom
    end
    restoreCameraState = nil
end

local function startSpectatingLogic(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return end
    local targetHum = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not targetHum then return end
    restoreCameraState = { CameraSubject = Camera.CameraSubject, CameraType = Camera.CameraType, PlayerCameraMode = (LocalPlayer and LocalPlayer.CameraMode) or nil, MinZoom = LocalPlayer.CameraMinZoomDistance, MaxZoom = LocalPlayer.CameraMaxZoomDistance }
    pcall(function()
        Camera.CameraSubject = targetHum; Camera.CameraType = Enum.CameraType.Custom
        if LocalPlayer then LocalPlayer.CameraMode = Enum.CameraMode.Classic; LocalPlayer.CameraMinZoomDistance = 10; LocalPlayer.CameraMaxZoomDistance = 100 end
    end)
    spectating = true
    spectateTarget = targetPlayer
end

TeleportSection:AddToggle({
    Name = "Spectate Selected", Flag = "Teleport_Spectate", Value = false,
    Callback = function(val)
        if val then
            if SelectedPlayer then startSpectatingLogic(SelectedPlayer); ShowMenuNotification("Spectating Started") else ShowMenuNotification("Select a player first!") end
        else stopSpectatingLogic(); ShowMenuNotification("Spectating Stopped") end
    end
})

TeleportFrontToggle = TeleportSection:AddToggle({
    Name = "Front (Teleport)", Flag = "Teleport_Front", Value = (Settings.TeleportDirection == "Front"),
    Callback = function(val) if val then Settings.TeleportDirection = "Front"; if TeleportBackToggle then TeleportBackToggle:Set(false) end; if TeleportLeftToggle then TeleportLeftToggle:Set(false) end; if TeleportRightToggle then TeleportRightToggle:Set(false) end; ShowMenuNotification("Teleport Direction set to Front") else if checkAllOff() then Settings.TeleportDirection = "Back"; if TeleportBackToggle then TeleportBackToggle:Set(true) end end end end
})
TeleportBackToggle = TeleportSection:AddToggle({
    Name = "Back (Teleport)", Flag = "Teleport_Back", Value = (Settings.TeleportDirection == "Back"),
    Callback = function(val) if val then Settings.TeleportDirection = "Back"; if TeleportFrontToggle then TeleportFrontToggle:Set(false) end; if TeleportLeftToggle then TeleportLeftToggle:Set(false) end; if TeleportRightToggle then TeleportRightToggle:Set(false) end; ShowMenuNotification("Teleport Direction set to Back") else if checkAllOff() then Settings.TeleportDirection = "Back"; if TeleportBackToggle then TeleportBackToggle:Set(true) end end end end
})
if TeleportBackToggle then TeleportBackToggle:Set(true) end
TeleportLeftToggle = TeleportSection:AddToggle({
    Name = "Left (Teleport)", Flag = "Teleport_Left", Value = (Settings.TeleportDirection == "Left"),
    Callback = function(val) if val then Settings.TeleportDirection = "Left"; if TeleportFrontToggle then TeleportFrontToggle:Set(false) end; if TeleportBackToggle then TeleportBackToggle:Set(false) end; if TeleportRightToggle then TeleportRightToggle:Set(false) end; ShowMenuNotification("Teleport Direction set to Left") else if checkAllOff() then Settings.TeleportDirection = "Back"; if TeleportBackToggle then TeleportBackToggle:Set(true) end end end end
})
TeleportRightToggle = TeleportSection:AddToggle({
    Name = "Right (Teleport)", Flag = "Teleport_Right", Value = (Settings.TeleportDirection == "Right"),
    Callback = function(val) if val then Settings.TeleportDirection = "Right"; if TeleportFrontToggle then TeleportFrontToggle:Set(false) end; if TeleportBackToggle then TeleportBackToggle:Set(false) end; if TeleportLeftToggle then TeleportLeftToggle:Set(false) end; ShowMenuNotification("Teleport Direction set to Right") else if checkAllOff() then Settings.TeleportDirection = "Back"; if TeleportBackToggle then TeleportBackToggle:Set(true) end end end end
})

local PlayerListSection = TeleportTab:CreateSection({ Name = "Player List", Side = "Right" })
PlayerListSection:AddToggle({
    Name = "Show Player List", Flag = "Teleport_ShowPlayerList", Value = false,
    Callback = function(val) showPlayerList = val; if val then GuiVisible = true; MainFrame.Visible = true; PlayerListFrame.Visible = true; updatePlayerList() else PlayerListFrame.Visible = false end; ShowMenuNotification("Player List " .. (val and "Shown" or "Hidden")) end
})

Players.PlayerAdded:Connect(function(player) if PlayerListFrame.Visible then updatePlayerList() end end)
Players.PlayerRemoving:Connect(function(player) if PlayerListFrame.Visible then updatePlayerList() end end)

local function AutoDetectStats()
    pcall(function() if Camera and Camera.FieldOfView then Settings.CameraFOV = Camera.FieldOfView or Settings.CameraFOV end end)
    pcall(function()
        local char = LocalPlayer and LocalPlayer.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hum then if hum.WalkSpeed then Settings.WalkSpeed = hum.WalkSpeed end; if hum.JumpPower then Settings.JumpPower = hum.JumpPower end end
    end)
    pcall(function() if Camera and Settings.CameraFOV then Camera.FieldOfView = Settings.CameraFOV end end)
end

pcall(function()
    AutoDetectStats()
    if LocalPlayer and (not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChildOfClass("Humanoid")) then
        LocalPlayer.CharacterAdded:Connect(function() task.wait(0.5); pcall(AutoDetectStats) end)
    end
end)

UserInputService.JumpRequest:Connect(function()
    if Settings.InfiniteJumpEnabled then
        local char = LocalPlayer.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
    end
end)

table.insert(Connections, RunService.Heartbeat:Connect(function()
    if Settings.LockFOV then Camera.FieldOfView = Settings.CameraFOV end
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum and Settings.LockSpeedJump then hum.WalkSpeed = Settings.WalkSpeed; hum.JumpPower = Settings.JumpPower end
    if Settings.NoclipEnabled then
        local now = tick()
        if now - lastNoclipUpdate > 0.2 then
            cachedParts = {}
            for _, v in pairs(char:GetDescendants()) do if v:IsA("BasePart") then table.insert(cachedParts, v) end end
            lastNoclipUpdate = now
        end
        for _, v in ipairs(cachedParts) do if v and v.Parent then v.CanCollide = false end end
    end
end))

table.insert(Connections, RunService.Heartbeat:Connect(function(dt)
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    local hrp = char.HumanoidRootPart
    if Settings.FlyEnabled then
        if not flyVelocity then flyVelocity = Instance.new("BodyVelocity", hrp); flyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge) end
        local moveDir = Vector3.new(0,0,0)
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveDir = moveDir + Camera.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveDir = moveDir - Camera.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveDir = moveDir - Camera.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveDir = moveDir + Camera.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then moveDir = moveDir + Vector3.new(0,1,0) end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then moveDir = moveDir - Vector3.new(0,1,0) end
        flyVelocity.Velocity = moveDir * Settings.FlySpeed
    else
        if flyVelocity then flyVelocity:Destroy(); flyVelocity = nil end
    end
    if Settings.TpWalkEnabled then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum and hum.MoveDirection.Magnitude > 0 then
            local dir = hum.MoveDirection.Unit
            if dir and dir.Magnitude > 0 then local speed = (Settings.TpWalkStep or 3); hrp.CFrame = hrp.CFrame + (dir * (speed * dt)) end
        end
    end
end))

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5); AutoDetectStats()
    if Settings.JerkEnabled then StopJerk(); PlayJerkAnim("72042024", 0.5, 0.9); PlayJerkAnim("168268306", 1, 1.001)
    elseif Settings.JerkR15Enabled then StopJerk(); PlayJerkR15() end
end)

local cachedTarget = nil
local lastTargetUpdate = 0
local targetVelocities = {} --   
local lastTargetPositions = {} --    

local function Validate(p)
    if not p or not p.Character then return false end
    local char = p.Character
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not char:FindFirstChild(Settings.TargetPart) then
        local altPart = (Settings.TargetPart == "LeftHand" and (char:FindFirstChild("LeftHand") or char:FindFirstChild("Left Arm"))) or (Settings.TargetPart == "RightHand" and (char:FindFirstChild("RightHand") or char:FindFirstChild("Right Arm")))
        if not altPart then return false end
    end
    if Settings.DeadCheck and (not hum or hum.Health <= 0) then return false end
    if Settings.TeamCheck and p.Team == LocalPlayer.Team then return false end
    if Settings.ForceFieldCheck and char:FindFirstChildOfClass("ForceField") then return false end
    return true
end

local function IsVisible(part, char)
    if not Settings.WallCheck then return true end
    local rayParam = RaycastParams.new()
    rayParam.FilterDescendantsInstances = {LocalPlayer.Character, char}
    rayParam.FilterType = Enum.RaycastFilterType.Exclude
    local res = workspace:Raycast(Camera.CFrame.Position, (part.Position - Camera.CFrame.Position), rayParam)
    return res == nil
end

local function GetTarget(mode)
    local now = tick()
    if now - lastTargetUpdate < 0.1 then return cachedTarget end
    lastTargetUpdate = now
    local target = nil
    local closestValue = math.huge
    local mLoc = UserInputService:GetMouseLocation()
    local myHrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myHrp then return nil end
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and Validate(p) then
            local part = p.Character:FindFirstChild(Settings.TargetPart) or (Settings.TargetPart == "LeftHand" and (p.Character:FindFirstChild("LeftHand") or p.Character:FindFirstChild("Left Arm"))) or (Settings.TargetPart == "RightHand" and (p.Character:FindFirstChild("RightHand") or p.Character:FindFirstChild("Right Arm")))
            if part then
                local dist = (myHrp.Position - part.Position).Magnitude
                if dist <= Settings.TriggerDistance then
                    local pos, vis = Camera:WorldToViewportPoint(part.Position)
                    if mode == "180" then
                        if vis and IsVisible(part, p.Character) then if dist < closestValue then closestValue = dist; target = p end end
                    else
                        if vis and IsVisible(part, p.Character) then
                            local screenMag = (Vector2.new(pos.X, pos.Y) - mLoc).Magnitude
                            if screenMag <= Settings.FOV then
                                if Settings.TargetDistanceCheck == "Mouse" then if screenMag < closestValue then closestValue = screenMag; target = p end
                                else if dist < closestValue then closestValue = dist; target = p end end
                            end
                        end
                    end
                end
            end
        end
    end
    cachedTarget = target
    return target
end

local lastTriggerTime = 0
table.insert(Connections, RunService.RenderStepped:Connect(function()
    if FOVCircle then
        FOVCircle.Position = UserInputService:GetMouseLocation()
        FOVCircle.Visible = Settings.AimbotEnabled and (Settings.TriggerBotMode ~= "180") and Settings.FOVCircleVisible
    end
    
    local ActiveTarget = nil
    if Settings.AimbotEnabled then
        if Locking then
            if Settings.Sticky then
                if not CurrentTarget or not Validate(CurrentTarget) then CurrentTarget = GetTarget("Lock") end
                ActiveTarget = CurrentTarget
            else ActiveTarget = GetTarget("Lock") end
        elseif Settings.TriggerBotMode ~= "None" then
            if Settings.TriggerBotMode == "180" then ActiveTarget = GetTarget("180") else ActiveTarget = GetTarget("Lock") end
        end
    end

    local VisualTarget = ActiveTarget
    if not VisualTarget and Settings.TargetHighlightEnabled then VisualTarget = GetTarget("Lock") end
    local HighlightChar = (VisualTarget and VisualTarget.Character)
    if Settings.TargetHighlightEnabled and HighlightChar then TargetCham.Adornee = HighlightChar; TargetCham.Enabled = true
    else TargetCham.Enabled = false; TargetCham.Adornee = nil end

    if ActiveTarget and ActiveTarget.Character then
        local part = ActiveTarget.Character:FindFirstChild(Settings.TargetPart) or (Settings.TargetPart == "LeftHand" and (ActiveTarget.Character:FindFirstChild("LeftHand") or ActiveTarget.Character:FindFirstChild("Left Arm"))) or (Settings.TargetPart == "RightHand" and (ActiveTarget.Character:FindFirstChild("RightHand") or ActiveTarget.Character:FindFirstChild("Right Arm")))
        if part then
            if ActiveTarget ~= CurrentTarget then CurrentTarget = ActiveTarget; lastTriggerTime = tick() end
            if IsVisible(part, ActiveTarget.Character) then
                --  :     
                local currentPos = part.Position
                local lastPos = lastTargetPositions[ActiveTarget]
                local velocity = Vector3.new(0, 0, 0)
                
                if lastPos then
                    velocity = (currentPos - lastPos) / 0.016 --     
                    targetVelocities[ActiveTarget] = velocity
                else
                    velocity = targetVelocities[ActiveTarget] or Vector3.new(0, 0, 0)
                end
                
                lastTargetPositions[ActiveTarget] = currentPos
                
                --   
                local predictedPos = currentPos
                if Settings.PredictionEnabled and velocity.Magnitude > 0.1 then
                    predictedPos = currentPos + (velocity * (Settings.PredictionRange / 100))
                end
                
                local mouseLoc = UserInputService:GetMouseLocation()
                local pos, vis = Camera:WorldToViewportPoint(predictedPos)
                if (Locking or Settings.TriggerBotMode ~= "None") then
                    if Settings.AimbotType == "Camera" then
                        local alpha = 1 / (Settings.Smoothing + 1)
                        Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, predictedPos), alpha)
                    else
                        if mousemoverel and vis then
                            local targetPos = Vector2.new(pos.X, pos.Y)
                            local diff = (targetPos - mouseLoc)
                            local smoothValue = math.max(Settings.Smoothing, 0) + 1
                            local moveX = diff.X / smoothValue
                            local moveY = diff.Y / smoothValue
                            if math.abs(diff.X) > 0.1 and math.abs(moveX) < 1 then moveX = (diff.X > 0 and 1 or -1) end
                            if math.abs(diff.Y) > 0.1 and math.abs(moveY) < 1 then moveY = (diff.Y > 0 and 1 or -1) end
                            mousemoverel(moveX, moveY)
                        end
                    end
                end
                if Settings.TriggerBotMode ~= "None" then
                    if (tick() - lastTriggerTime) >= (Settings.TriggerDelay / 1000) then
                        if vis then
                            local distToCenter = (Vector2.new(pos.X, pos.Y) - mouseLoc).Magnitude
                            if Settings.TriggerBotMode == "180" or distToCenter < 25 then
                                if mouse1click then mouse1click(); lastTriggerTime = tick() end
                            end
                        end
                    end
                end
            end
        end
    else CurrentTarget = nil 
        --     
        for player, _ in pairs(lastTargetPositions) do
            if not player or not player.Character then
                lastTargetPositions[player] = nil
                targetVelocities[player] = nil
            end
        end
    end
end))

UserInputService.InputBegan:Connect(function(input)
    if Settings.IsBindingLock then
        Settings.LockKey = (input.KeyCode ~= Enum.KeyCode.Unknown and input.KeyCode or input.UserInputType)
        Settings.IsBindingLock = false
        ShowMenuNotification("Aimbot Key Bound to: " .. tostring(Settings.LockKey.Name))
        if AimKeyButton then AimKeyButton:SetText("Aimbot Key: " .. tostring(Settings.LockKey.Name)) end
        return
    elseif Settings.IsBindingToggle then
        if input.KeyCode ~= Enum.KeyCode.Unknown then Settings.ToggleKey = input.KeyCode end
        Settings.IsBindingToggle = false
        return
    elseif Settings.IsBindingTrigger then
        if input.KeyCode ~= Enum.KeyCode.Unknown then Settings.TriggerToggleKey = input.KeyCode end
        Settings.IsBindingTrigger = false
        ShowMenuNotification("TriggerBot Key Bound to: " .. tostring(Settings.TriggerToggleKey.Name))
        if TrigKeyButton then TrigKeyButton:SetText("Trigger Key: " .. tostring(Settings.TriggerToggleKey.Name)) end
        return
    elseif Settings.IsBindingAimbotToggle then
        if input.KeyCode ~= Enum.KeyCode.Unknown then Settings.AimbotToggleKey = input.KeyCode end
        Settings.IsBindingAimbotToggle = false
        ShowMenuNotification("Aimbot Toggle Key Bound to: " .. tostring(Settings.AimbotToggleKey.Name))
        if AimbotToggleKeyButton then AimbotToggleKeyButton:SetText("Aimbot Toggle Key: " .. tostring(Settings.AimbotToggleKey.Name)) end
        return
    end

    if input.KeyCode == Settings.ToggleKey then
        if not UserInputService:GetFocusedTextBox() then
            GuiVisible = not GuiVisible
            MainFrame.Visible = GuiVisible
            if showPlayerList then PlayerListFrame.Visible = GuiVisible; if GuiVisible then updatePlayerList() end else PlayerListFrame.Visible = false end
        end
    elseif input.KeyCode == Settings.LockKey or input.UserInputType == Settings.LockKey then
        if not UserInputService:GetFocusedTextBox() then Locking = true; if Settings.Sticky then CurrentTarget = GetTarget("Lock") end end
    elseif input.KeyCode == Settings.TriggerToggleKey then
        if not UserInputService:GetFocusedTextBox() then
            if Settings.TriggerBotMode == "None" then
                local modeToSet = (Settings.LastTriggerMode == "180") and "180" or "FOV"
                Settings.TriggerBotMode = modeToSet
                if modeToSet == "FOV" then if TrigFOVToggle then TrigFOVToggle:Set(true) end; if Trig180Toggle then Trig180Toggle:Set(false) end
                else if Trig180Toggle then Trig180Toggle:Set(true) end; if TrigFOVToggle then TrigFOVToggle:Set(false) end end
            else
                Settings.LastTriggerMode = Settings.TriggerBotMode; Settings.TriggerBotMode = "None"
                if TrigFOVToggle then TrigFOVToggle:Set(false) end; if Trig180Toggle then Trig180Toggle:Set(false) end
            end
        end
    elseif input.KeyCode == Settings.AimbotToggleKey then
        if not UserInputService:GetFocusedTextBox() then
            Settings.AimbotEnabled = not Settings.AimbotEnabled
            if AimbotEnabledToggle then AimbotEnabledToggle:Set(Settings.AimbotEnabled) end
            FOVCircle.Visible = Settings.AimbotEnabled and (Settings.TriggerBotMode ~= "180") and Settings.FOVCircleVisible
            ShowMenuNotification("Aimbot " .. (Settings.AimbotEnabled and "Enabled" or "Disabled"))
        end
    elseif input.KeyCode == Enum.KeyCode.F1 then
        if not UserInputService:GetFocusedTextBox() then Settings.ESPDistance = math.min(Settings.ESPDistance + 100, 15000); ShowMenuNotification("ESP Distance increased to " .. Settings.ESPDistance) end
    elseif input.KeyCode == Enum.KeyCode.F2 then
        if not UserInputService:GetFocusedTextBox() then Settings.ESPDistance = math.max(Settings.ESPDistance - 100, 10); ShowMenuNotification("ESP Distance decreased to " .. Settings.ESPDistance) end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Settings.LockKey or input.UserInputType == Settings.LockKey then Locking = false; CurrentTarget = nil end
end)

local visibilityCache = {}
local function IsVisibleESP(part, char, isFar)
    if not part then return false end
    local key = part
    local now = tick()
    local cache = visibilityCache[key]
    local cacheDuration = isFar and 0.5 or 0.2
    
    if cache and (now - cache.t) < cacheDuration then return cache.v end
    
    local rayParam = RaycastParams.new()
    rayParam.FilterDescendantsInstances = {LocalPlayer.Character, char}
    rayParam.FilterType = Enum.RaycastFilterType.Exclude
    local res = workspace:Raycast(Camera.CFrame.Position, (part.Position - Camera.CFrame.Position), rayParam)
    local visible = res == nil
    visibilityCache[key] = {v = visible, t = now}
    return visible
end

local function IsAnyPartVisible(char, isFar)
    if not char then return false end
    local partsToCheck = {
        char:FindFirstChild("Head"),
        char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso")
    }
    if not isFar then
        table.insert(partsToCheck, char:FindFirstChild("RightHand") or char:FindFirstChild("Right Arm"))
        table.insert(partsToCheck, char:FindFirstChild("LeftHand") or char:FindFirstChild("Left Arm"))
    end
    
    for _, p in ipairs(partsToCheck) do
        if p and IsVisibleESP(p, char, isFar) then return true end
    end
    return false
end

local EspDrawings = {}

local function CreateDrawingSet(plr)
    local set = {}
    set.limbs = {}
    set.box = Drawing.new("Square")
    set.boxOutline = Drawing.new("Square")
    set.nameTag = Drawing.new("Text")
    set.healthTag = Drawing.new("Text")
    set.healthBarOutline = Drawing.new("Square")
    set.healthBar = Drawing.new("Square")
    set.headDot = Drawing.new("Circle")
    set.distanceTag = Drawing.new("Text")
    set.cham = Instance.new("Highlight")
    set.cham.Name = "ESP_Cham"
    set.cham.Parent = ScreenGui
    set.cham.Enabled = false
    table.insert(AllDrawings, set.box); table.insert(AllDrawings, set.boxOutline)
    table.insert(AllDrawings, set.nameTag); table.insert(AllDrawings, set.healthTag)
    table.insert(AllDrawings, set.healthBarOutline); table.insert(AllDrawings, set.healthBar)
    table.insert(AllDrawings, set.headDot); table.insert(AllDrawings, set.distanceTag)
    table.insert(AllChams, set.cham)
    set.box.Thickness = 1; set.box.Filled = false; set.box.ZIndex = 2
    set.boxOutline.Thickness = 1; set.boxOutline.Filled = false; set.boxOutline.Color = Color3new(0,0,0); set.boxOutline.ZIndex = 1
    set.nameTag.Center = true; set.nameTag.Outline = true; set.nameTag.ZIndex = 3
    set.healthTag.Center = true; set.healthTag.Outline = true; set.healthTag.Color = Color3new(0,1,0); set.healthTag.ZIndex = 3
    set.healthBarOutline.Thickness = 1; set.healthBarOutline.Filled = true; set.healthBarOutline.Color = Color3new(0,0,0)
    set.healthBar.Thickness = 1; set.healthBar.Filled = true
    set.headDot.Radius = 4; set.headDot.Filled = true; set.headDot.ZIndex = 3
    set.distanceTag.Center = true; set.distanceTag.Outline = true; set.distanceTag.ZIndex = 3
    EspDrawings[plr] = set
    return set
end

local function DrawLineForSet()
    local l = Drawing.new("Line"); l.Visible = false; l.Transparency = 1; table.insert(AllDrawings, l); return l
end

local function BuildLimbsForSet(set, rigType)
    if next(set.limbs) then return end
    local jointNames = { "Head_UpperTorso", "UpperTorso_LowerTorso", "UpperTorso_LeftUpperArm", "LeftUpperArm_LeftLowerArm", "LeftLowerArm_LeftHand", "UpperTorso_RightUpperArm", "RightUpperArm_RightLowerArm", "RightLowerArm_RightHand", "LowerTorso_LeftUpperLeg", "LeftUpperLeg_LeftLowerLeg", "LeftLowerLeg_LeftFoot", "LowerTorso_RightUpperLeg", "RightUpperLeg_RightLowerLeg", "RightLowerLeg_RightFoot", "Head_Spine", "Spine_LeftArm", "Spine_RightArm", "Spine_LeftLeg", "Spine_RightLeg", "LeftArm_Bone", "RightArm_Bone", "LeftLeg_Bone", "RightLeg_Bone" }
    for _, name in ipairs(jointNames) do set.limbs[name] = {line = DrawLineForSet(), outline = DrawLineForSet()} end
end

local function RemoveDrawingSet(plr)
    local set = EspDrawings[plr]; if not set then return end
    if set.limbs then for _, parts in pairs(set.limbs) do if parts.line then parts.line:Remove() end; if parts.outline then parts.outline:Remove() end end end
    set.box:Remove(); set.boxOutline:Remove(); set.nameTag:Remove(); set.healthTag:Remove()
    set.healthBarOutline:Remove(); set.healthBar:Remove(); set.headDot:Remove(); set.distanceTag:Remove()
    if set.cham then set.cham:Destroy() end
    EspDrawings[plr] = nil
end

Players.PlayerRemoving:Connect(function(p) RemoveDrawingSet(p); visibilityCache[p] = nil end)

local function HideAll(set)
    set.box.Visible = false; set.boxOutline.Visible = false
    set.nameTag.Visible = false; set.healthTag.Visible = false
    set.healthBarOutline.Visible = false; set.healthBar.Visible = false
    set.headDot.Visible = false; set.distanceTag.Visible = false
    if set.limbs then for _, v in pairs(set.limbs) do v.line.Visible = false; v.outline.Visible = false end end
    if set.cham then set.cham.Enabled = false end
end

local function ConnectLimb(set, limbName, p1, p2)
    local limbObj = set.limbs[limbName]; if not limbObj then return end
    local pos1, vis1 = Camera:WorldToViewportPoint(p1)
    local pos2, vis2 = Camera:WorldToViewportPoint(p2)
    if vis1 and vis2 then
        limbObj.line.Visible = true; limbObj.line.From = Vector2new(pos1.X, pos1.Y); limbObj.line.To = Vector2new(pos2.X, pos2.Y)
        if Settings.SkeletonOutlineEnabled then
            limbObj.outline.Visible = true; limbObj.outline.From = Vector2new(pos1.X, pos1.Y); limbObj.outline.To = Vector2new(pos2.X, pos2.Y); limbObj.outline.Thickness = 3
        else limbObj.outline.Visible = false end
    else limbObj.line.Visible = false; limbObj.outline.Visible = false end
end

local function isAnyEspEnabled()
    return Settings.BoxEnabled or Settings.NameEnabled or Settings.HealthMode ~= "None" or Settings.SkeletonEnabled or Settings.HeadDotEnabled or Settings.DistanceESPEnabled or Settings.ChamsEnabled
end

local espAccumulator = 0
local espCleanedUp = false

table.insert(Connections, RunService.Heartbeat:Connect(function(dt)
    if not isAnyEspEnabled() then
        if not espCleanedUp then
            for _, set in pairs(EspDrawings) do HideAll(set) end
            espCleanedUp = true
        end
        return
    end
    
    espCleanedUp = false
    espAccumulator = espAccumulator + dt
    local interval = (Settings.ESPUpdateFrequency <= 1) and 0 or (Settings.ESPUpdateFrequency / 60)
    if espAccumulator < interval then return end
    espAccumulator = 0
    
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local char = plr.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            local head = char and char:FindFirstChild("Head")
            local set = EspDrawings[plr] or CreateDrawingSet(plr)
            
            if char and hrp and hum and hum.Health > 0 then
                local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
                
                local isLowDetail = distance > Settings.LODDistance
                
                if distance > Settings.ESPDistance or (Settings.TeamCheck and plr.Team == LocalPlayer.Team) then
                    HideAll(set)
                else
                    local pos, vis = Camera:WorldToViewportPoint(hrp.Position)
                    
                    if vis then
                        local isVis = false
                        if plr.Team ~= LocalPlayer.Team then
                            isVis = IsAnyPartVisible(char, isLowDetail)
                        end

                        local sizeY = 3000 / pos.Z; local sizeX = 1800 / pos.Z
                        local xPos = pos.X - sizeX/2; local yPos = pos.Y - sizeY/2
                        
                        if Settings.BoxEnabled then
                            set.box.Size = Vector2new(sizeX, sizeY); set.box.Position = Vector2new(xPos, yPos); set.box.Visible = true
                            if Settings.BoxOutlineEnabled then 
                                set.boxOutline.Size = Vector2new(sizeX + 2, sizeY + 2); set.boxOutline.Position = Vector2new(xPos - 1, yPos - 1); set.boxOutline.Visible = true 
                            else 
                                set.boxOutline.Visible = false 
                            end
                            if plr.Team == LocalPlayer.Team then set.box.Color = Settings.BoxESPTeamColor else set.box.Color = isVis and Settings.BoxESPEnemyColor or Settings.BoxESPOccludedColor end
                        else set.box.Visible = false; set.boxOutline.Visible = false end

                        if Settings.NameEnabled then
                            set.nameTag.Visible = true; set.nameTag.Position = Vector2new(pos.X, yPos - 16); set.nameTag.Text = plr.Name
                            set.nameTag.Outline = Settings.NameOutlineEnabled 
                            set.nameTag.OutlineColor = Settings.NameOutlineColor; set.nameTag.Size = Settings.ESPTextSize
                            if plr.Team == LocalPlayer.Team then set.nameTag.Color = Settings.NameESPTeamColor else set.nameTag.Color = isVis and Settings.NameESPEnemyColor or Settings.NameESPOccludedColor end
                        else set.nameTag.Visible = false end
                        
                        if Settings.DistanceESPEnabled then 
                            set.distanceTag.Visible = true; set.distanceTag.Position = Vector2new(pos.X, yPos + sizeY + 2); set.distanceTag.Text = string.format("[%d]", mathfloor(distance)) 
                            set.distanceTag.Outline = Settings.DistanceESPOutlineEnabled
                            set.distanceTag.Color = Settings.DistanceESPColor; set.distanceTag.Size = Settings.ESPTextSize
                        else set.distanceTag.Visible = false end
                
                        if not isLowDetail then
                            if Settings.ChamsEnabled then
                                set.cham.Adornee = char; set.cham.Enabled = true; set.cham.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop; set.cham.FillTransparency = 0.5; set.cham.OutlineTransparency = 0
                                if plr.Team == LocalPlayer.Team then set.cham.FillColor = Settings.ChamsTeamColor
                                else set.cham.FillColor = isVis and Settings.ChamsEnemyColor or Settings.ChamsOccludedColor end
                            else set.cham.Enabled = false end

                            if (Settings.HealthMode == "Bar" or Settings.HealthMode == "Both") then
                                local healthPercent = mathclamp(hum.Health / hum.MaxHealth, 0, 1)
                                local barHeight = sizeY * healthPercent
                                set.healthBarOutline.Visible = true; set.healthBar.Visible = true
                                set.healthBarOutline.Size = Vector2new(4, sizeY + 2); set.healthBarOutline.Position = Vector2new(xPos - 6, yPos - 1)
                                set.healthBar.Size = Vector2new(2, barHeight); set.healthBar.Position = Vector2new(xPos - 5, yPos + sizeY - barHeight)
                                set.healthBar.Color = Color3.fromHSV(healthPercent * 0.3, 1, 1)
                            else set.healthBarOutline.Visible = false; set.healthBar.Visible = false end

                            if (Settings.HealthMode == "Text" or Settings.HealthMode == "Both") then
                                set.healthTag.Visible = true; set.healthTag.Text = tostring(mathfloor(hum.Health))
                                local offset = (Settings.NameEnabled and 30 or 16)
                                set.healthTag.Position = Vector2new(pos.X, yPos - offset)
                            else set.healthTag.Visible = false end
                            
                            if Settings.HeadDotEnabled and head then
                                local hPos = Camera:WorldToViewportPoint(head.Position)
                                set.headDot.Visible = true; set.headDot.Position = Vector2new(hPos.X, hPos.Y)
                                set.headDot.Color = Settings.HeadDotESPColor
                            else set.headDot.Visible = false end

                            if Settings.SkeletonEnabled then
                                if set.limbs then for _, parts in pairs(set.limbs) do parts.line.Color = Settings.SkeletonESPColor; parts.outline.Color = Settings.SkeletonOutlineColor end end
                                BuildLimbsForSet(set, hum.RigType)
                                if hum.RigType == Enum.HumanoidRigType.R15 then
                                    local p = {H=char:FindFirstChild("Head"),UT=char:FindFirstChild("UpperTorso"),LT=char:FindFirstChild("LowerTorso"),LUA=char:FindFirstChild("LeftUpperArm"),LLA=char:FindFirstChild("LeftLowerArm"),LH=char:FindFirstChild("LeftHand"),RUA=char:FindFirstChild("RightUpperArm"),RLA=char:FindFirstChild("RightLowerArm"),RH=char:FindFirstChild("RightHand"),LUL=char:FindFirstChild("LeftUpperLeg"),LLL=char:FindFirstChild("LeftLowerLeg"),LF=char:FindFirstChild("LeftFoot"),RUL=char:FindFirstChild("RightUpperLeg"),RLL=char:FindFirstChild("RightLowerLeg"),RF=char:FindFirstChild("RightFoot")}
                                    if p.H and p.UT then ConnectLimb(set,"Head_UpperTorso",p.H.Position,p.UT.Position) end
                                    if p.UT and p.LT then ConnectLimb(set,"UpperTorso_LowerTorso",p.UT.Position,p.LT.Position) end
                                    if p.UT and p.LUA then ConnectLimb(set,"UpperTorso_LeftUpperArm",p.UT.Position,p.LUA.Position) end
                                    if p.LUA and p.LLA then ConnectLimb(set,"LeftUpperArm_LeftLowerArm",p.LUA.Position,p.LLA.Position) end
                                    if p.LLA and p.LH then ConnectLimb(set,"LeftLowerArm_LeftHand",p.LLA.Position,p.LH.Position) end
                                    if p.UT and p.RUA then ConnectLimb(set,"UpperTorso_RightUpperArm",p.UT.Position,p.RUA.Position) end
                                    if p.RUA and p.RLA then ConnectLimb(set,"RightUpperArm_RightLowerArm",p.RUA.Position,p.RLA.Position) end
                                    if p.RLA and p.RH then ConnectLimb(set,"RightLowerArm_RightHand",p.RLA.Position,p.RH.Position) end
                                    if p.LT and p.LUL then ConnectLimb(set,"LowerTorso_LeftUpperLeg",p.LT.Position,p.LUL.Position) end
                                    if p.LUL and p.LLL then ConnectLimb(set,"LeftUpperLeg_LeftLowerLeg",p.LUL.Position,p.LLL.Position) end
                                    if p.LLL and p.LF then ConnectLimb(set,"LeftLowerLeg_LeftFoot",p.LLL.Position,p.LF.Position) end
                                    if p.LT and p.RUL then ConnectLimb(set,"LowerTorso_RightUpperLeg",p.LT.Position,p.RUL.Position) end
                                    if p.RUL and p.RLL then ConnectLimb(set,"RightUpperLeg_RightLowerLeg",p.RUL.Position,p.RLL.Position) end
                                    if p.RLL and p.RF then ConnectLimb(set,"RightLowerLeg_RightFoot",p.RLL.Position,p.RF.Position) end
                                elseif hum.RigType == Enum.HumanoidRigType.R6 then
                                    local T,H,LA,RA,LL,RL = char:FindFirstChild("Torso"),char:FindFirstChild("Head"),char:FindFirstChild("Left Arm"),char:FindFirstChild("Right Arm"),char:FindFirstChild("Left Leg"),char:FindFirstChild("Right Leg")
                                    if T and H then
                                        local hh = T.Size.Y/2 - 0.2; local uT = (T.CFrame*CFrame.new(0,hh,0)).p; local lT = (T.CFrame*CFrame.new(0,-hh,0)).p
                                        ConnectLimb(set,"Head_Spine",H.Position,uT)
                                        if LA then local p1=(LA.CFrame*CFrame.new(0,LA.Size.Y/2,0)).p; local p2=(LA.CFrame*CFrame.new(0,-LA.Size.Y/2,0)).p; ConnectLimb(set,"Spine_LeftArm",uT,p1); ConnectLimb(set,"LeftArm_Bone",p1,p2) end
                                        if RA then local p1=(RA.CFrame*CFrame.new(0,RA.Size.Y/2,0)).p; local p2=(RA.CFrame*CFrame.new(0,-RA.Size.Y/2,0)).p; ConnectLimb(set,"Spine_RightArm",uT,p1); ConnectLimb(set,"RightArm_Bone",p1,p2) end
                                        if LL then local p1=(LL.CFrame*CFrame.new(0,LL.Size.Y/2,0)).p; local p2=(LL.CFrame*CFrame.new(0,-LL.Size.Y/2,0)).p; ConnectLimb(set,"Spine_LeftLeg",lT,p1); ConnectLimb(set,"LeftLeg_Bone",p1,p2) end
                                        if RL then local p1=(RL.CFrame*CFrame.new(0,RL.Size.Y/2,0)).p; local p2=(RL.CFrame*CFrame.new(0,-RL.Size.Y/2,0)).p; ConnectLimb(set,"Spine_RightLeg",lT,p1); ConnectLimb(set,"RightLeg_Bone",p1,p2) end
                                    end
                                end
                            else if set.limbs then for _, v in pairs(set.limbs) do v.line.Visible = false; v.outline.Visible = false end end end
                        
                        else
                            set.cham.Enabled = false
                            set.healthBar.Visible = false; set.healthBarOutline.Visible = false
                            set.healthTag.Visible = false
                            set.headDot.Visible = false
                            if set.limbs then for _, v in pairs(set.limbs) do v.line.Visible = false; v.outline.Visible = false end end
                        end
                        
                    else 
                        HideAll(set)
                    end
                end
            else HideAll(set) end
        end
    end
end))
