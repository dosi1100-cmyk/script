Players = game:GetService("Players")
plr = game.Players.LocalPlayer
cam = workspace.CurrentCamera
mouse = plr:GetMouse()
uis = game:GetService("UserInputService")
inv = workspace:WaitForChild(plr.Name.."SpawnedInToys")
rs = game:GetService("ReplicatedStorage")
RepStorage = game:GetService("ReplicatedStorage")
rs2 = game:GetService("RunService")
deb = game:GetService("Debris")

SetNetworkOwner = rs.GrabEvents.SetNetworkOwner
DestroyGrabLine = rs.GrabEvents.DestroyGrabLine

Auto = syn and syn.queue_on_teleport or fluxus and fluxus.queue_on_teleport or queue_on_teleport

Whitelist = {}
playersInLoop1V = {} -- List
playersInLoop2V = {} -- Loop

PPs = workspace:WaitForChild("PlotItems"):WaitForChild("PlayersInPlots")

----------------------------------------------------------------------------------------- [ ê¸°ë³¸ ì„¤ì • ]
function PcldOwner()
    task.spawn(function()
        while task.wait(0.1) do
            usedNames = {}

            for _, pcld in pairs(workspace:GetChildren()) do
                if pcld.Name == "PlayerCharacterLocationDetector" then
                    if pcld.CFrame == CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) then
                        continue
                    end

                    hasOwner = false
                    existingBoolValues = {}

                    for _, child in pairs(pcld:GetChildren()) do
                        if child:IsA("BoolValue") then
                            table.insert(existingBoolValues, child)
                        end
                    end

                    if #existingBoolValues >= 2 then
                        for _, boolValue in pairs(existingBoolValues) do
                            boolValue:Destroy()
                        end
                    elseif #existingBoolValues == 1 then
                        hasOwner = true
                    end

                    if hasOwner then
                        continue
                    end

                    closestPlayer = nil
                    closestDist = 30
                    candidates = {}

                    for _, player in pairs(Players:GetPlayers()) do
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            hrp = player.Character.HumanoidRootPart
                            dist = (pcld.Position - hrp.Position).Magnitude

                            if dist < closestDist then
                                table.insert(candidates, {
                                    player = player,
                                    dist = dist,
                                    hrp = hrp
                                })
                            end
                        end
                    end

                    table.sort(candidates, function(a, b)
                        return a.dist < b.dist
                    end)

                    for _, candidate in pairs(candidates) do
                        ownerName = string.format("[ %s ] ( @%s )",
                            candidate.player.DisplayName,
                            candidate.player.Name)

                        if not usedNames[ownerName] then
                            closestPlayer = candidate.player
                            closestDist = candidate.dist
                            usedNames[ownerName] = true
                            break
                        end
                    end

                    if closestPlayer then
                        ownerName = string.format("[ %s ] ( @%s )",
                            closestPlayer.DisplayName,
                            closestPlayer.Name)

                         boolValue = nil
                        for _, child in pairs(pcld:GetChildren()) do
                            if child:IsA("BoolValue") then
                                boolValue = child
                                boolValue.Name = ownerName
                                break
                            end
                        end

                        if not boolValue then
                            boolValue = Instance.new("BoolValue")
                            boolValue.Name = ownerName
                            boolValue.Parent = pcld
                        end

                        task.spawn(function(player, value)
                            while value.Parent do
                                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                     hrp = player.Character.HumanoidRootPart
                                    
                                    if hrp.Massless == true then
                                        if not value.Value then
                                            value.Value = true
                                        end
                                    else
                                        if value.Value then
                                            value.Value = false
                                        end
                                    end

                                    if not Players:FindFirstChild(player.Name) or 
                                       not player.Character or 
                                       player.Character:FindFirstChild("Humanoid") and 
                                       player.Character.Humanoid.Health <= 0 then
                                        value:Destroy()
                                        break
                                    end
                                else
                                    value:Destroy()
                                    break
                                end

                                task.wait(0.1)
                            end
                        end, closestPlayer, boolValue)
                    end
                end
            end
        end
    end)
end

PcldOwner()

function SpawnCFrame()
    local camPart
    myDisplayName = plr.DisplayName
    myUserName = plr.Name
    myPOIdentifier = string.format("[ %s ] ( @%s )", myDisplayName, myUserName)

    function findMyPO()
        for _, obj in pairs(workspace:GetChildren()) do
            if obj.Name == "PlayerCharacterLocationDetector" then
                for _, child in pairs(obj:GetChildren()) do
                    if child:IsA("BoolValue") and child.Name == myPOIdentifier then
                        return obj
                    end
                end
            end
        end
        return nil
    end

    if not workspace:FindFirstChild("CamPart") or workspace:FindFirstChild("CamPart"):FindFirstChild("CamPart") then
         char = plr.Character or plr.CharacterAdded:Wait()
        camPart = char:FindFirstChild("CamPart"):Clone()
        camPart.Name = "CamPart"
        camPart.Parent = workspace
        camPart.Transparency = 0.9
    else
        camPart = workspace.CamPart
    end

     lastHRPVelocity = Vector3.new(0, 0, 0)

    task.spawn(function()
         rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Exclude

        while true do
             ping = plr:GetNetworkPing()
             myPO = findMyPO()
             char = plr.Character
             hrp = char and char:FindFirstChild("HumanoidRootPart")

            if hrp then
                lastHRPVelocity = hrp.Velocity
            end

            if myPO and hrp then
                rayParams.FilterDescendantsInstances = {char, camPart, myPO}

                 offset = myPO.Position + (lastHRPVelocity * (ping + 0.15))

                 rayOrigin = offset
                 rayDirection = Vector3.new(0, 23, 0)
                 rayResult = workspace:Raycast(rayOrigin, rayDirection, rayParams)

                local targetPosition

                if rayResult then
                    targetPosition = rayResult.Position - Vector3.new(0, 0.5, 0)
                else
                    targetPosition = offset + rayDirection
                end

                 originalRotation = myPO.CFrame.Rotation * CFrame.Angles(math.rad(-90), 0, 0)
                camPart.CFrame = CFrame.new(targetPosition) * originalRotation

                camPart.Name = "SpawnCF"
            elseif hrp then
                rayParams.FilterDescendantsInstances = {char, camPart}

                 offset = hrp.Position + (lastHRPVelocity * (ping + 0.15))
                
                 rayOrigin = offset
                 rayDirection = Vector3.new(0, 20, 0)
                 rayResult = workspace:Raycast(rayOrigin, rayDirection, rayParams)

                local targetPosition

                if rayResult then
                    targetPosition = rayResult.Position - Vector3.new(0, 0.5, 0)
                else
                    targetPosition = offset + rayDirection
                end

                 originalRotation = (hrp.CFrame * CFrame.Angles(math.rad(-90), 0, 0)).Rotation
                camPart.CFrame = CFrame.new(targetPosition) * originalRotation
                camPart.Name = "SpawnCF"
            end
            task.wait()
        end
    end)

    return camPart
end

SpawnCFrame()
 SCF = workspace.SpawnCF

local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/NP01223/NP/refs/heads/main/RayField'))()



loadstring(game:HttpGet('https://raw.githubusercontent.com/dosi1100-cmyk/script/refs/heads/main/kk'))()

G = rs.GrabEvents
G:WaitForChild("EndGrabEarly"):Destroy()
Instance.new("RemoteEvent", G).Name = "EndGrabEarly"

local NP = {
    TextColor = Color3.fromRGB(255,255,255),

    Background = Color3.fromRGB(20,20,20),
    Topbar = Color3.fromRGB(30,30,30),
    Shadow = Color3.fromRGB(15,15,15),

    NotificationBackground = Color3.fromRGB(25,25,25),
    NotificationActionsBackground = Color3.fromRGB(40,40,40),

    TabBackground = Color3.fromRGB(40,40,40),
    TabStroke = Color3.fromRGB(70,70,70),
    TabBackgroundSelected = Color3.fromRGB(60,60,60),
    TabTextColor = Color3.fromRGB(255,255,255),
    SelectedTabTextColor = Color3.fromRGB(255,0,0),

    ElementBackground = Color3.fromRGB(35,35,35),
    ElementBackgroundHover = Color3.fromRGB(50,50,50),
    SecondaryElementBackground = Color3.fromRGB(25,25,25),
    ElementStroke = Color3.fromRGB(60,60,60),
    SecondaryElementStroke = Color3.fromRGB(45,45,45),

    SliderBackground = Color3.fromRGB(60,60,60),
    SliderProgress = Color3.fromRGB(0,170,255),
    SliderStroke = Color3.fromRGB(0,120,200),

    ToggleBackground = Color3.fromRGB(30,30,30),

    ToggleEnabled = Color3.fromRGB(185,0,0),
    ToggleEnabledStroke = Color3.fromRGB(255,255,255),
    ToggleEnabledOuterStroke = Color3.fromRGB(255,255,255),

    ToggleDisabled = Color3.fromRGB(100, 100, 100),
    ToggleDisabledStroke = Color3.fromRGB(125, 125, 125),
    ToggleDisabledOuterStroke = Color3.fromRGB(65, 65, 65),

    DropdownSelected = Color3.fromRGB(50,50,50),
    DropdownUnselected = Color3.fromRGB(30,30,30),

    InputBackground = Color3.fromRGB(25,25,25),
    InputStroke = Color3.fromRGB(45,45,45),
    PlaceholderColor = Color3.fromRGB(150,150,150),
}

----------------------------------------------------------------------------------------- [ ê¸°ëŠ¥ë“¤ ]
function ForWhiteList(enable)
    WhiteListMode = enable

    task.spawn(function()
        while WhiteListMode do
            task.wait()
            for i, name in ipairs(Whitelist) do
            end
        end
    end)
end

function House()
    char = plr.Character
    if not char then
        Plot = nil
        return
    end

    if char.Parent and char.Parent.Name == "PlayersInPlots" then
        for _, plot in workspace.Plots:GetChildren() do
            for _, owner in plot.PlotSign.ThisPlotsOwners:GetChildren() do
                if owner.Value == plr.Name then
                    if plot.Name == "Plot1" then
                        Plot = 1
                    elseif plot.Name == "Plot2" then
                        Plot = 2
                    elseif plot.Name == "Plot3" then
                        Plot = 3
                    elseif plot.Name == "Plot4" then
                        Plot = 4
                    elseif plot.Name == "Plot5" then
                        Plot = 5
                    end
                    return
                end
            end
        end
        Plot = nil
        return
    end

    if char.Parent == workspace or char.Parent == inv then
        for _, plot in workspace.Plots:GetChildren() do
            for _, owner in plot.PlotSign.ThisPlotsOwners:GetChildren() do
                if owner.Value == plr.Name then
                    if plot.Name == "Plot1" then
                        Plot = 1
                    elseif plot.Name == "Plot2" then
                        Plot = 2
                    elseif plot.Name == "Plot3" then
                        Plot = 3
                    elseif plot.Name == "Plot4" then
                        Plot = 4
                    elseif plot.Name == "Plot5" then
                        Plot = 5
                    end
                    return
                end
            end
        end
        Plot = nil
    else
        Plot = nil
    end
end

function UpdateCurrentBlobman()
	char = plr.Character
	hrp = char and char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	for _, blobs in workspace:GetDescendants() do
		if blobs.Name ~= "CreatureBlobman" then continue end
		 seat = blobs:FindFirstChild("VehicleSeat")
		if not seat then continue end
		 weld = seat:FindFirstChild("SeatWeld")
		if not weld then continue end
		if weld.Part1 == hrp then
			currentBlobS = blobs
		end
	end
end

function BlobRelease(blob, target, side) -- ë¦´ë¦¬ìŠ¤
     args = {
        [1] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        [2] = target,
        }
        blob.BlobmanSeatAndOwnerScript.CreatureRelease:FireServer(unpack(args))
end

function BlobGrab(blob, target, side)
     args = {
        [1] = blob:FindFirstChild(side.."Detector"),
        [2] = target,
        [3] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        }
        blob.BlobmanSeatAndOwnerScript.CreatureGrab:FireServer(unpack(args))
end

function BlobDrop(blob, target, side)
     args = {
        [1] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        [2] = target,
        }
        blob.BlobmanSeatAndOwnerScript.CreatureDrop:FireServer(unpack(args))
end

function BlobMassless(blob, target, side)
     args = {
        [1] = blob:FindFirstChild(side.."Detector"),
        [2] = target,
        [3] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        }

		 args2 = {
        [1] = blob:FindFirstChild(side.."Detector"),
        [2] = hrp,
        [3] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        }

     args3 = {
        [1] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        [2] = target,
        }

        blob.BlobmanSeatAndOwnerScript.CreatureGrab:FireServer(unpack(args2))
		blob.BlobmanSeatAndOwnerScript.CreatureGrab:FireServer(unpack(args))
		blob.BlobmanSeatAndOwnerScript.CreatureDrop:FireServer(unpack(args3))
end

function flingF()
    workspace.ChildAdded:Connect(function(model)
        if model.Name == "GrabParts" then
             part_to_impulse = model["GrabPart"]["WeldConstraint"].Part1
            if part_to_impulse then
                model:GetPropertyChangedSignal("Parent"):Connect(function()
                    if not model.Parent and flingT then
                        local connection
                        connection = uis.InputBegan:Connect(function(inp, char)
                            if inp.UserInputType == Enum.UserInputType.MouseButton2 then
                                 velocityObj = Instance.new("BodyVelocity")
                                velocityObj.Parent = part_to_impulse
                                velocityObj.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                                velocityObj.Velocity = cam.CFrame.lookVector * strengthV
                                
                                wait(0.1)
                                velocityObj.Parent = workspace
                                velocityObj:Destroy()

                                connection:Disconnect()
                            end
                        end)
                    end
                end)
            end
        end
    end)
end

function infLineExtendF()
    uis.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseWheel then
            if lineDistanceV < 11 then
                lineDistanceV = 11
            end
    
            if input.Position.Z > 0 then
                lineDistanceV = lineDistanceV + increaseLineExtendV
            elseif input.Position.Z < 0 then
                lineDistanceV = lineDistanceV - increaseLineExtendV
            end
        end
    end)
    
    workspace.ChildAdded:Connect(function(child)
        if child.Name == "GrabParts" and child:IsA("Model") then
            if infLineExtendT and uis.MouseEnabled then
                 grabPartsModel = child

                grabPartsModel:WaitForChild("GrabPart")
                grabPartsModel:WaitForChild("DragPart")
                    
                 clonedDragPart = grabPartsModel.DragPart:Clone()
                clonedDragPart.Name = "DragPart1"
                clonedDragPart.AlignPosition.Attachment1 = clonedDragPart.DragAttach
                clonedDragPart.Parent = grabPartsModel
                
                lineDistanceV = (clonedDragPart.Position - cam.CFrame.Position).Magnitude
    
                clonedDragPart.AlignOrientation.Enabled = false
                grabPartsModel.DragPart.AlignPosition.Enabled = false

                if MasslessGrabT then
                     alignOrientation = clonedDragPart:FindFirstChildOfClass("AlignOrientation")
                    if alignOrientation then
                        alignOrientation.MaxAngularVelocity = math.huge
                        alignOrientation.MaxTorque = math.huge
                        alignOrientation.Responsiveness = 200
                    end
                    
                     alignPosition = clonedDragPart:FindFirstChildOfClass("AlignPosition")
                    if alignPosition then
                        alignPosition.MaxAxesForce = Vector3.new(math.huge, math.huge, math.huge)
                        alignPosition.MaxForce = math.huge
                        alignPosition.MaxVelocity = math.huge
                        alignPosition.Responsiveness = 200
                    end
                end
    
                task.spawn(function()
                    while grabPartsModel.Parent do
                        clonedDragPart.Position = cam.CFrame.Position + cam.CFrame.LookVector * lineDistanceV
                        task.wait()
                    end
            
                    lineDistanceV = 0
                end)
            end
        end
    end)
end

function BlobMasslessR()
    UpdateCurrentBlobman()
    for i, e in ipairs(playersInLoop2V) do
         player = game.Players:FindFirstChild(e)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		BlobMassless(currentBlobS, player.Character.HumanoidRootPart, "Right")
        end
    end
end

function BlobReleaseR()
    UpdateCurrentBlobman()
    for i, e in ipairs(playersInLoop2V) do
         player = game.Players:FindFirstChild(e)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		BlobGrab(currentBlobS, player.Character.HumanoidRootPart, "Right")
		BlobRelease(currentBlobS, player.Character.HumanoidRootPart, "Right")
        end
    end
end

function BlobGrabR()
    UpdateCurrentBlobman()
    for i, e in ipairs(playersInLoop2V) do
         player = game.Players:FindFirstChild(e)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			BlobGrab(currentBlobS, player.Character.HumanoidRootPart, "Right")
        end
    end
end

function BlobDropR()
    UpdateCurrentBlobman()
    for i, e in ipairs(playersInLoop2V) do
         player = game.Players:FindFirstChild(e)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			BlobDrop(currentBlobS, player.Character.HumanoidRootPart, "Right")
        end
    end
end


function updateWalkSpeedF()
     function apply(char)
         hum = char:WaitForChild("Humanoid")

        if walkSpeedT then
            hum.WalkSpeed = walkSpeedV
            hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
                if walkSpeedT then
                    hum.WalkSpeed = walkSpeedV
                end
            end)
        else
            hum.WalkSpeed = 16
        end
    end

    if plr.Character then
        apply(plr.Character)
    end

    plr.CharacterAdded:Connect(apply)
end

function updateJumpPowerF()
     function apply(char)
         hum = char:WaitForChild("Humanoid")

        if jumpPowerT then
            hum.JumpPower = jumpPowerV
            hum:GetPropertyChangedSignal("JumpPower"):Connect(function()
                if jumpPowerT then
                    hum.JumpPower = jumpPowerV
                end
            end)
        else
            hum.JumpPower = 24
        end
    end

    if plr.Character then
        apply(plr.Character)
    end

    plr.CharacterAdded:Connect(apply)
end

 RunService = game:GetService("RunService")

 NO_CLIP_PARTS = {
    "Head",
    "Torso",
    "Left Arm", 
    "Left Leg",
    "Right Arm",
    "Right Leg"
}

function updateNoClipF()
     char = plr.Character
    if not char then return end

    if noClipConnection then
        noClipConnection:Disconnect()
        noClipConnection = nil
    end

    if not noClipT then
        restoreCollision(char)
        return
    end
    
     hrp = char:WaitForChild("HumanoidRootPart")
     hum = char:WaitForChild("Humanoid")

    noClipConnection = RunService.Stepped:Connect(function()
        if not noClipT or not char or not char.Parent then
            if noClipConnection then
                noClipConnection:Disconnect()
                noClipConnection = nil
            end
            return
        end

        for _, partName in ipairs(NO_CLIP_PARTS) do
             part = char:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
end

function restoreCollision(char)
    if char then
        for _, partName in ipairs(NO_CLIP_PARTS) do
             part = char:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

plr.CharacterAdded:Connect(function(char)
    char:WaitForChild("HumanoidRootPart")
    task.wait(0.5)
    
    if noClipT then
        updateNoClipF()
    end
end)

if plr.Character then
    task.wait(1)
    if noClipT then
        updateNoClipF()
    end
end

function updateInfJumpF()
     char = plr.Character
    if not char then return end
    
     hrp = char:WaitForChild("HumanoidRootPart")
     hum = char:WaitForChild("Humanoid")
    
    if infJumpConnection then
        infJumpConnection:Disconnect()
    end
    
    infJumpConnection = uis.JumpRequest:Connect(function()
        if infJumpT and not infJumpD then
            infJumpD = true
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
            task.wait()
            infJumpD = false
        end
    end)
end

plr.CharacterAdded:Connect(function(char)
    char:WaitForChild("HumanoidRootPart")
    char:WaitForChild("Humanoid")
    task.wait(0.5)
    
    if infJumpT then
        updateInfJumpF()
    end
end)

if plr.Character then
    task.wait(1)
    updateInfJumpF()
end

function masslessF()
    function applyMassless(char)
         hrp = char:WaitForChild("HumanoidRootPart")
         hum = char:WaitForChild("Humanoid")

        if masslessT then
            task.spawn(function()
                while masslessT and char.Parent do
                    for i, e in ipairs(char:GetChildren()) do
                        if e:IsA("BasePart") then
                            e.Massless = false
                        end
                    end
                    task.wait()
                end
            end)
        end
    end

    if plr.Character then
        applyMassless(plr.Character)
    end

    plr.CharacterAdded:Connect(function(char)
        task.wait(1)
        applyMassless(char)
    end)
end

function setRagdollF(state)
    char = plr.Character
    hrp = char:WaitForChild("HumanoidRootPart")
    if char and char:FindFirstChild("HumanoidRootPart") then
        rs.CharacterEvents.RagdollRemote:FireServer(hrp, state and 1 or 0)
    end
end

function permRagdollLoopF()
    if permRagdollRunningS then return end
    permRagdollRunningS = true
    while permRagdollT do
        setRagdollF(true)
        task.wait(0.001) 
    end
    permRagdollRunningS = false
    setRagdollF(false)
end

function ragdollLegExplodeF()
	function attemptDelete()
		 char = plr.Character
		if not char then return false end

		 targets = {}
		if selectedAutoDeletePart == "Arm/Leg" then
			targets = {
				char:FindFirstChild("Left Leg"),
				char:FindFirstChild("Right Leg"),
				char:FindFirstChild("Left Arm"),
				char:FindFirstChild("Right Arm"),
			}
		elseif selectedAutoDeletePart == "All/Leg" then
			targets = {char:FindFirstChild("Left Leg"), char:FindFirstChild("Right Leg")}
		elseif selectedAutoDeletePart == "Leg/ì™¼ìª½" then
			targets = {char:FindFirstChild("Left Leg")}
		elseif selectedAutoDeletePart == "Leg/ì˜¤ë¥¸ìª½" then
			targets = {char:FindFirstChild("Right Leg")}
		elseif selectedAutoDeletePart == "All/Arm" then
			targets = {char:FindFirstChild("Left Arm"), char:FindFirstChild("Right Arm")}
		elseif selectedAutoDeletePart == "Arm/ì™¼ìª½" then
			targets = {char:FindFirstChild("Left Arm")}
		elseif selectedAutoDeletePart == "Arm/ì˜¤ë¥¸ìª½" then
			targets = {char:FindFirstChild("Right Arm")}
		end

		setRagdollF(true)
		task.wait(0.3)

		 success = false
		for _, part in ipairs(targets) do
			if part then
				part.CFrame = CFrame.new(0, -99999, 0)
				success = true
			end
		end

		task.wait(0.3)
		 torso = char:FindFirstChild("Torso")
		if torso then torso.CFrame = CFrame.new(0, -99999, 0) end

		return success
	end

	task.spawn(function()
		while autoDeleteLegs do
			 success = false
			 startTime = tick()

			while tick() - startTime < 4 and not success do
				success = attemptDelete()
				if success then break end
				task.wait(0.5)
			end

			 humanoid = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.Died:Wait()
			end

			plr.CharacterAdded:Wait()
			task.wait(1)
		end
	end)
end

Pline = rs.GrabEvents.CreateGrabLine.OnClientEvent
fireCount = {}
function AntiLagF()
    Pline:Connect(function(fromPlr, ...)
        if not antiLagEnabled then return end
        if typeof(fromPlr) ~= "Instance" or not fromPlr:IsA("Player") then return end
        if fromPlr == plr then return end

        local now = os.clock()

        if not fireCount[fromPlr] then 
            fireCount[fromPlr] = {count = 0, start = now} 
        end

        local data = fireCount[fromPlr]

        if now - data.start > 1 then
            data.count = 0
            data.start = now
        end

        data.count += 1

        if data.count >= AntiLagV and not data.isDecreasing then
            data.isDecreasing = true
            Rayfield:Notify({Title = "[ âœï¸ ]", Content = "by: " .. fromPlr.Name, Duration = 3, Image = 0})
            plr.PlayerScripts.CharacterAndBeamMove.Enabled = false

            task.spawn(function()
                while data.count > 0 do
                    task.wait(0.1)
                    data.count -= 1
                end

                plr.PlayerScripts.CharacterAndBeamMove.Enabled = true
                fireCount[fromPlr] = nil
            end)
        end
    end)
end

function spawnBlobmanF()
     char = plr.Character
     hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return
    end

     blob = inv and inv:FindFirstChild("CreatureBlobman")
    if blob then
        blobmanInstanceS = blob
        return
    end

     spawnRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("SpawnToyRemoteFunction")
    if spawnRemote then
        task.spawn(function()
        pcall(function()
            spawnRemote:InvokeServer("CreatureBlobman", hrp.CFrame, Vector3.new(0, 0, 0))
        end)
        end)

         tries = 0
        repeat
            task.wait(0.2)
            blobmanInstanceS = inv and inv:FindFirstChild("CreatureBlobman")
            tries += 1
        until blobmanInstanceS or tries > 25
    else
    end
end

function ragdollLoopF()
	if ragdollLoopD then return end
	ragdollLoopD = true

	while sitJumpT do
		char = plr.Character
		hrp = char and char:FindFirstChild("HumanoidRootPart")
		if char and hrp then
			 args = {[1] = hrp, [2] = 0}
			 remote = rs:FindFirstChild("CharacterEvents") and rs.CharacterEvents:FindFirstChild("RagdollRemote")
			if remote then
				remote:FireServer(unpack(args))
			end
		end
		task.wait()
	end

	ragdollLoopD = false
end

function sitJumpF()
    char = plr.Character
    hum = char and char:FindFirstChild("Humanoid")
    if not char or not hum then return end
    seat = blobmanInstanceS and blobmanInstanceS:FindFirstChildWhichIsA("VehicleSeat")
    if seat and seat.Occupant ~= hum then
    seat:Sit(hum)
    autoGucciT = false
    sitJumpT = false
end
end

function AutoGucciF()
    while AutoGucciT do
        local success = pcall(function()
            spawnBlobmanF()

             char = plr.Character
            if not char then
                task.wait(0.1)
                return 
            end

             hrp = char:WaitForChild("HumanoidRootPart")
             hum = char:WaitForChild("Humanoid")
             rag = hum:WaitForChild("Ragdolled")
             held = plr:WaitForChild("IsHeld")

             SpawnToyRemoteFunction = RepStorage.MenuToys.SpawnToyRemoteFunction 
             RagdollRemote = RepStorage.CharacterEvents.RagdollRemote
             DestroyToy = RepStorage.MenuToys.DestroyToy
             seat = blobmanInstanceS:WaitForChild("VehicleSeat"):WaitForChild("ProximityPrompt")

            if not hrp then return end
             OCF = hrp.CFrame

            if not sitJumpT then
                task.spawn(sitJumpF)
                sitJumpT = true
            end

            task.spawn(ragdollLoopF)
            task.wait(0.3)
            --fireproximityprompt(seat)
            --task.wait(0.1)
            --hrp.Massless = false
            --task.wait(0.1)
            hrp.CFrame = OCF

            successCheck = true
            sitJumpT = false
            RagdollRemote:FireServer(hrp, 0.001)

            while successCheck and AutoGucciT do
                if hum.Health <= 0 then
                    if blobmanInstanceS then
                        DestroyToy:FireServer(blobmanInstanceS)
                    end
                    successCheck = false
                    break
                end

                 seat = blobmanInstanceS and blobmanInstanceS:FindFirstChildWhichIsA("VehicleSeat")
                if seat.Occupant ~= nil then
                    DestroyToy:FireServer(blobmanInstanceS)
                    successCheck = false
                    break
                end

                if rag.Value == true or held.Value == true then
                    while (rag.Value == true or held.Value == true) and AutoGucciT do
                        rs.CharacterEvents.Struggle:FireServer()
                        task.wait()
                    end
                    successCheck = false
                    break
                end

                 blobHRP = blobmanInstanceS and blobmanInstanceS:FindFirstChild("HumanoidRootPart")
                if blobHRP then
                     SetNetworkOwner = rs:WaitForChild("GrabEvents"):WaitForChild("SetNetworkOwner")
                    pcall(function()
                        SetNetworkOwner:FireServer(blobHRP, hrp)
                    end)
                    blobHRP.CFrame = CFrame.new(0, 99999, 0)
                end

                task.wait()
            end

            if not successCheck then
                 blobHRP = blobmanInstanceS and blobmanInstanceS:FindFirstChild("HumanoidRootPart")
                Rayfield:Notify({Title = "[ ðŸ”“ ]",Content = "Gucci | Wait",Duration = 1,Image = nil,})
                if hum then
                    rs.CharacterEvents.Struggle:FireServer(plr)
                    hum.Sit = true
                    task.wait(0.1)
                    hum.Sit = false
                    if blobHRP.Position.Y > 9000 then  DestroyToy:FireServer(blobmanInstanceS) end
                end

                sitJumpT = false
                task.wait(1)
            end
        end)
    task.wait()
    end
end

function sitJumpFV2()
     char = plr.Character
     hum = char and char:FindFirstChild("Humanoid")
    if not char or not hum then return end

     seat = workspace.Map.AlwaysHereTweenedObjects.Train.Object.ObjectModel.Seat
    if seat and seat.Occupant ~= hum then
    seat:Sit(hum)
    AutoGucciTV2 = false
    sitJumpT = false
end
end

function AutoGucciFV2()
     char = plr.Character
    if not char then
        task.wait(1)
        return 
    end

     hrp = char:WaitForChild("HumanoidRootPart")
     hum = char:WaitForChild("Humanoid")

    if not hrp then return end
     OCF = hrp.CFrame

    if not sitJumpT then
        task.spawn(sitJumpFV2)
        sitJumpT = true
    end
    task.spawn(ragdollLoopF)
    task.wait(0.3)
    hrp.CFrame = OCF
    sitJumpT = false
end

function ragdollLoopF2()
	if ragdollLoopD then return end
	ragdollLoopD = true

	while ragdollRunning do
		 char = plr.Character
		 hrp = char and char:FindFirstChild("HumanoidRootPart")
		if char and hrp then
			 args = {[1] = hrp, [2] = 0}
			 remote = rs:FindFirstChild("CharacterEvents") and rs.CharacterEvents:FindFirstChild("RagdollRemote")
			if remote then
				remote:FireServer(unpack(args))
			end
		end
		task.wait()
	end

	ragdollLoopD = false
end

 function HasNoLegs(char)
    return not (char:FindFirstChild("Left Leg") and char:FindFirstChild("Right Leg"))
end

 function StartMonitoring()
    if Monitoring then return end
    Monitoring = true

    task.spawn(function()
        while ToggleActive do
             char = plr.Character
             humanoid = char and char:FindFirstChildOfClass("Humanoid")

            if char and humanoid then
                if HasNoLegs(char) then
                    humanoid.HipHeight = 2
                else
                    repeat task.wait() until not ToggleActive or HasNoLegs(plr.Character)
                end
            end

            task.wait()
        end
        Monitoring = false
    end)
end

plr.CharacterAdded:Connect(function(char)
    if ToggleActive then
        char:WaitForChild("Humanoid")
        repeat task.wait(0.2) until HasNoLegs(char) or not ToggleActive
        if ToggleActive then
            StartMonitoring()
        end
    end
end)

 plotItemsFolder = workspace:WaitForChild("PlotItems")
 playersInPlotsFolder = plotItemsFolder:WaitForChild("PlayersInPlots")

 function antiInPlotsLoop()
    while antiInPlotsEnabled do
        for _, player in pairs(game.Players:GetPlayers()) do
            if player == plr then
                continue
            end

             char = player.Character
            if char and char.Parent then
                 inPlot = playersInPlotsFolder:FindFirstChild(player.Name)

                if inPlot then
                    if char.Parent ~= inv then
                        char.Parent = inv
                    end
                else
                    if char:IsDescendantOf(plotItemsFolder) then
                    end
                end
            end
        end
        task.wait()
    end
end

function BlobSit()
    if BLOBSIT then return end

     char = plr.Character
    if not char then return end

     humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    if humanoid.SeatPart ~= nil then return end

    BLOBSIT = true

    myInv = workspace:FindFirstChild(plr.Name.."SpawnedInToys")
    myBlob = myInv and myInv:FindFirstChild("CreatureBlobman")

    if myBlob then
         seat = myBlob:FindFirstChildOfClass("VehicleSeat")
        if seat then
            if seat.Occupant == nil then
                seat:Sit(humanoid)
                BLOBSIT = false
                return
            else
                 targetPlr = game.Players:GetPlayerFromCharacter(seat.Occupant.Parent)
                if targetPlr then
                    TP(targetPlr)
                    task.wait(0.3)
                    SetOwner(targetPlr)
                    task.wait(0.05)
                    seat:Sit(humanoid)
                    BLOBSIT = false
                    return
                end
            end
        end
    end

    for _, other in ipairs(game.Players:GetPlayers()) do
        if other ~= plr then
             invs = workspace:FindFirstChild(other.Name.."SpawnedInToys")
             blob = invs and invs:FindFirstChild("CreatureBlobman")
            if blob then
                 seat = blob:FindFirstChildOfClass("VehicleSeat")
                if seat then
                    if seat.Occupant == nil then
                        seat:Sit(humanoid)
                        BLOBSIT = false
                        return
                    else
                         targetPlr = game.Players:GetPlayerFromCharacter(seat.Occupant.Parent)
                        if targetPlr then
                            TP(targetPlr)
                            task.wait(0.3)
                            SetOwner(targetPlr)
                            task.wait(0.05)
                            seat:Sit(humanoid)
                            BLOBSIT = false
                            return
                        end
                    end
                end
            end
        end
    end

    task.spawn(function()
        rs:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction"):InvokeServer(
            "CreatureBlobman", 
            CFrame.new(0,9999999,0), 
            Vector3.new(0,9999999,0)
        )
    end)

    task.delay(0.1, function()
         newInv = workspace:FindFirstChild(plr.Name.."SpawnedInToys")
         newBlob = newInv and newInv:FindFirstChild("CreatureBlobman")
        if newBlob then
             seat = newBlob:FindFirstChildOfClass("VehicleSeat")
            if seat and seat.Occupant == nil and humanoid then
                seat:Sit(humanoid)
            end
        end
        BLOBSIT = false
    end)
end

local function getClosestPlayer(targetPart)
    local closest, distance = nil, math.huge
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local mag = (targetPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if mag < distance then
                distance = mag
                closest = player
            end
        end
    end
    return closest
end

function AntiBurn()
    task.spawn(function()
        local EP = workspace:WaitForChild("Map"):WaitForChild("Hole"):WaitForChild("PoisonSmallHole"):WaitForChild("ExtinguishPart")
        while AntiBurnV do
            local hrp = plr.Character:WaitForChild("Head") -- HumanoidRootPart
            if hrp then
                EP.Transparency = 1
                EP.CastShadow = false
                if EP:FindFirstChild("Tex") then
                    EP.Tex.Transparency = 1
                end
                EP.Size = Vector3.new(0, 0, 0)
                EP.CFrame = hrp.CFrame
                task.wait()
                EP.CFrame = hrp.CFrame * CFrame.new(0,3,0)
            end
            task.wait()
        end
        EP.Size = Vector3.new(103.90400695800781, 7.5, 95.14202880859375)
        EP.CFrame = CFrame.new(157.075317, -58.8218384, 287.346954, -1.1920929e-07, 0, -1.00000012, 0, 1, 0, 1.00000012, 0, -1.1920929e-07)
        EP.Transparency = 0.5
        EP.CastShadow = true
        if EP:FindFirstChild("Tex") then
            EP.Tex.Transparency = 0
        end
    end)
end

local function teleportParts(player, partName)
    local character = player.Character
    if not character then return end
    
    local targetParts = {}

    if partName == "Arm/Leg" then
        table.insert(targetParts, character:FindFirstChild("Left Leg"))
        table.insert(targetParts, character:FindFirstChild("Right Leg"))
        table.insert(targetParts, character:FindFirstChild("Left Arm"))
        table.insert(targetParts, character:FindFirstChild("Right Arm"))

    elseif partName == "All/Leg" then
        table.insert(targetParts, character:FindFirstChild("Left Leg"))
        table.insert(targetParts, character:FindFirstChild("Right Leg"))

    elseif partName == "All/Arm" then
        table.insert(targetParts, character:FindFirstChild("Left Arm"))
        table.insert(targetParts, character:FindFirstChild("Right Arm"))

    elseif partName == "Leg/ì™¼ìª½" then
        table.insert(targetParts, character:FindFirstChild("Left Leg"))

    elseif partName == "Leg/ì˜¤ë¥¸ìª½" then
        table.insert(targetParts, character:FindFirstChild("Right Leg"))

    elseif partName == "Arm/ì™¼ìª½" then
        table.insert(targetParts, character:FindFirstChild("Left Arm"))

    elseif partName == "Arm/ì˜¤ë¥¸ìª½" then
        table.insert(targetParts, character:FindFirstChild("Right Arm"))
    end

    for _, part in ipairs(targetParts) do
        if part then part.CFrame = CFrame.new(0, -99999, 0) end
    end

    task.wait(0.3)
    local torso = character:FindFirstChild("Torso")
    if torso then torso.CFrame = CFrame.new(0, -99999, 0) end
end

function TP(target)
    local TCHAR = target.Character
    --local THRP = TCHAR:FindFirstChild("HumanoidRootPart")
    local THRP = TCHAR:FindFirstChild("Torso")

    local localChar = plr.Character
    local localHRP = localChar and localChar:FindFirstChild("HumanoidRootPart")

    if TCHAR and THRP and localHRP then
        local ping = game:GetService("Players").LocalPlayer:GetNetworkPing()
        local offset = THRP.Position + (THRP.Velocity * (ping + 0.15))

        localHRP.CFrame = CFrame.new(offset) * THRP.CFrame.Rotation

        return true
    end
    return false
end

function SetOwner(target)
	local head = target.Character:FindFirstChild("HumanoidRootPart")
	if head and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
		return true
	end
	return false
end

function UnOwner(target)
	local head = target.Character:FindFirstChild("HumanoidRootPart")
	if head and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		rs.GrabEvents.DestroyGrabLine:FireServer(head, head.CFrame)
		return true
	end
	return false
end

function BACK(originCF)
	if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		plr.Character.HumanoidRootPart.CFrame = originCF
	end
end

local function safeGetCharacterParts(player)
    if not player then return nil end
    local char = player.Character
    if not char then return nil end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local head = char:FindFirstChild("Head")
    return char, hrp, head
end

function loopPlayerBlobF() -- ë¸”ë¡­ ë£¹1
    UpdateCurrentBlobman()

    local seat = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").SeatPart
    if not (seat and seat.Parent and seat.Parent.Name == "CreatureBlobman") then
        return false
    end

    local isRiding = seat and seat.Parent and seat.Parent.Name == "CreatureBlobman"

    local processedHumanoids = {}

    local function processPlayer(player)
        if not player then return false end

        local character, hrp, head = safeGetCharacterParts(player)
        if not hrp or not head then return false end

        if hrp.Massless == true and not isRiding then
            return false
        end

        local myChar = plr and plr.Character
        local myHrp = myChar:FindFirstChild("HumanoidRootPart")
        if not myHrp then return false end
        local originCF = myHrp.CFrame

        local tpRunning = true
        task.spawn(function()
            while tpRunning do
                local ok, cf = TP(player)
                if ok and cf then
                    CF = cf
                end
                task.wait()
            end
        end)

        while blobLoopT do
            rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)

            local ownerTag = head:FindFirstChild("PartOwner")
            if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                break
            end
            task.wait()
        end

        tpRunning = false

        local targetNames = { "NinjaKunai", "NinjaShuriken", "NinjaKatana", "ToolCleaver", "ToolDiggingForkRusty", "ToolPencil", "ToolPickaxe" }
        for _, child in ipairs(workspace:GetChildren()) do
            if child:IsA("Folder") and child.Name:match("SpawnedInToys$") then
                for _, item in ipairs(child:GetChildren()) do
                    if table.find(targetNames, item.Name) and item:FindFirstChild("StickyPart") then
                        local sticky = item.StickyPart
                        local weld = sticky:FindFirstChild("StickyWeld")
                        if weld and weld:IsA("WeldConstraint") and weld.Part1 then
                            local targetParts = {
                                character:FindFirstChild("Head"),
                                character:FindFirstChild("Torso"),
                                character:FindFirstChild("Left Arm"),
                                character:FindFirstChild("Left Leg"),
                                character:FindFirstChild("Right Arm"),
                                character:FindFirstChild("Right Leg"),
                                hrp:FindFirstChild("RagdollTouchedHitbox"),
                                hrp:FindFirstChild("FirePlayerPart"),
                            }
                            for _, tPart in ipairs(targetParts) do
                                if tPart and weld.Part1 == tPart then
                                    local basePart = item.PrimaryPart or sticky
                                    if basePart and (basePart.Position - hrp.Position).Magnitude <= 10 then
                                        rs.GrabEvents.SetNetworkOwner:FireServer(sticky, sticky.CFrame)
                                        sticky.CFrame = CFrame.new(0,9999,0)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        rs.GrabEvents.DestroyGrabLine:FireServer(head, head.CFrame)

	hrp.CFrame = CFrame.new(myHrp.CFrame.X, myHrp.CFrame.Y +50, myHrp.CFrame.Z)
	myHrp.CFrame = hrp.CFrame
        BlobMassless(currentBlobS, hrp, "Right")

        if originCF then
            BACK(originCF)
        end

        return true
    end

    task.spawn(function()
        while blobLoopT do
            for i, name in ipairs(playersInLoop2V) do
                local player = game.Players:FindFirstChild(name)
                if not player then --or table.find(Whitelist, name) then
                    continue
                end

                if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then
                    continue
                end

                local character = player.Character
                local humanoid = character and character:FindFirstChildOfClass("Humanoid")
                local hrp = character and character:FindFirstChild("HumanoidRootPart")

                if hrp and hrp:IsA("BasePart") and hrp.Massless and not isRiding then
                    continue
                end

                if humanoid and humanoid.Health > 0 then
                    if processedHumanoids[player] ~= humanoid then
                        local success = processPlayer(player)
                        if success then
                            processedHumanoids[player] = humanoid
                        end
                    end
                else
                    processedHumanoids[player] = nil
                end
                task.wait(0.05)
            end
            task.wait(0.3)
        end
    end)
end

function loopPlayerBlobF2() -- ë¸”ë¡­ ë£¹2
    UpdateCurrentBlobman()

    local seat = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").SeatPart
    if not (seat and seat.Parent and seat.Parent.Name == "CreatureBlobman") then
        return false
    end

    local isRiding = seat and seat.Parent and seat.Parent.Name == "CreatureBlobman"

    local function processPlayer(player)
        if not player then return false end

        local _, hrp, head = safeGetCharacterParts(player)
        if not hrp or not head then return false end

        local character = player.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then return false end

if hrp then
            BlobGrab(currentBlobS, hrp, "Right")
            BlobRelease(currentBlobS, hrp, "Right")
            if LoopBringMODED then humanoid.Sit = true end
			if LoopReleaseMODED and player.InPlot.Value then hrp.CFrame = CFrame.new(0, 500, 0) end
            task.wait(0.03)
            BlobGrab(currentBlobS, hrp, "Right")
            if LoopBringMODED then humanoid.Sit = false end
			if LoopReleaseMODED and player.InPlot.Value then hrp.CFrame = CFrame.new(0, 500, 0) end
        end

        return true
    end

    task.spawn(function()
        while blobLoopT2 do
            for i, name in ipairs(playersInLoop2V) do
                local player = game.Players:FindFirstChild(name)
                if not player then --or table.find(Whitelist, name) then
                    continue
                end

                if PPs:FindFirstChild(name) then
                    continue
                end

                local character = player.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")

                if hrp.Massless == true and not isRiding then
                    continue
                end

                processPlayer(player)
                task.wait(0.01)
            end
            task.wait(0.01)
        end
    end)
end

function loopPlayerBlobF3() -- ë¸”ë¡­ ë£¹3

    UpdateCurrentBlobman()

    local seat = plr.Character
        and plr.Character:FindFirstChildOfClass("Humanoid")
        and plr.Character:FindFirstChildOfClass("Humanoid").SeatPart

    if not (seat and seat.Parent and seat.Parent.Name == "CreatureBlobman") then
        return false
    end

    local runningTasks = {}

    local function waitForRespawn(player)
        while blobLoopT3 do
            local char = player.Character
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            if hum and hum.Health > 0 then
                return char
            end
            task.wait(0.1)
        end
    end

    task.spawn(function()
        while blobLoopT3 do
            for _, name in ipairs(playersInLoop2V) do
                if not blobLoopT3 then break end

                local player = game.Players:FindFirstChild(name)
                if not player then continue end
                if PPs and PPs:FindFirstChild(name) then continue end
                if runningTasks[player] then continue end

                runningTasks[player] = task.spawn(function()
                    local beforeTP

                    while blobLoopT3 do
                        local myChar = plr.Character
                        local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
                        if not myHrp then task.wait(0.1) continue end

                        if not beforeTP then
                            beforeTP = myHrp.CFrame
                        end

                        local char = player.Character
                        local hum = char and char:FindFirstChildOfClass("Humanoid")

                        if hum and hum.Health <= 0 then
                            if beforeTP then
                                BACK(beforeTP)
                            end

                            waitForRespawn(player)

                            local myChar2 = plr.Character
                            local myHrp2 = myChar2 and myChar2:FindFirstChild("HumanoidRootPart")
                            if myHrp2 then
                                beforeTP = myHrp2.CFrame
                            end

                            continue
                        end

                        if not hum then
                            task.wait(0.05)
                            continue
                        end

                        local hrp = char:FindFirstChild("HumanoidRootPart")
                        if not hrp then task.wait(0.05) continue end

                        local distance = (myHrp.Position - hrp.Position).Magnitude
                        if distance > 30 then
                            TP(player)
                            task.wait(0.05)
                            continue
                        end

                        hum.BreakJointsOnDeath = false
                        hum.WalkSpeed = 0
                        hum.JumpPower = 0

                        for i = 0, 0 do
                            if hum.SeatPart == nil then
                                if hum.RigType ~= Enum.HumanoidRigType.R15 then
                                    hum.RigType = Enum.HumanoidRigType.R15
                                end

                                if hum.RigType ~= Enum.HumanoidRigType.R6 then
                                    hum.RigType = Enum.HumanoidRigType.R6
                                end

                                if hum.RigType ~= Enum.HumanoidRigType.R15 then
                                    hum.RigType = Enum.HumanoidRigType.R15
                                end

                            end
                            task.wait()
                        end

                        for i = 1, 3 do
                            if not blobLoopT3 then break end
                            BlobGrab(currentBlobS, hrp, "Right")
                            BlobRelease(currentBlobS, hrp, "Right")
                            task.wait()
                        end

                        task.wait()
                    end

                    if beforeTP then
                        BACK(beforeTP)
                    end

                    runningTasks[player] = nil
                end)

                task.wait()
            end

            task.wait()
        end

        for _, t in pairs(runningTasks) do
            task.cancel(t)
        end
        runningTasks = {}
    end)
end

local RunService = game:GetService("RunService")
local destroyCount = 0
OwnerKickMODED = false
SitMODED = false
OnlyOwner = false
SkipOL = false
OLTPValue = Vector3.new(0, 20, 0)

function loopPlayerBlobF4() -- ì˜¤ë„ˆí‚¥
    UpdateCurrentBlobman()

    local runningTasks = {}
    local monitoredPlayers = {}
    local independentHoldConnections = {}
    local anchorToggleTasks = {}
    local ownerTags = {}
    local originPositions = {}

    local function processPlayer(player)
        if not player then return end

        while blobLoopT4 do
            if not player.Parent then
                monitoredPlayers[player] = nil
                independentHoldConnections[player] = nil
                if anchorToggleTasks[player] then
                    task.cancel(anchorToggleTasks[player])
                    anchorToggleTasks[player] = nil
                end
                if ownerTags[player] then
                    ownerTags[player]:Destroy()
                    ownerTags[player] = nil
                end
                if originPositions[player] then
                    originPositions[player] = nil
                end
                if player.Character then
                    local charHRP = player.Character:FindFirstChild("HumanoidRootPart")
                    if charTOR then
                        charTOR.Anchored = false
                    end
                end
                return
            end

            local character = player.Character
            while blobLoopT4 and (not character or not character:FindFirstChild("Humanoid")) do
                if not player.Parent then return end
                task.wait(0.5)
                character = player.Character
            end

            local charHUM = character and character:FindFirstChild("Humanoid")
            if not charHUM then
                task.wait(0.5)
                continue
            end

            if not originPositions[player] then
                local myChar = plr.Character
                local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
                if myHRP then
                    originPositions[player] = myHRP.CFrame
                end
            end

            while blobLoopT4 and charHUM and charHUM.Health <= 0 do
                if not player.Parent then return end
                if ownerTags[player] then
                    ownerTags[player]:Destroy()
                    ownerTags[player] = nil
                end

                local myChar = plr.Character
                local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
                if myHRP and originPositions[player] then
                    myHRP.CFrame = originPositions[player]
                end

                if independentHoldConnections[player] then
                    independentHoldConnections[player]:Disconnect()
                    independentHoldConnections[player] = nil
                end
                
                if anchorToggleTasks[player] then
                    task.cancel(anchorToggleTasks[player])
                    anchorToggleTasks[player] = nil
                end
                
                task.wait(0.5)
                character = player.Character
                charHUM = character and character:FindFirstChild("Humanoid")
            end

            local _, safeHRP, head = safeGetCharacterParts(player)
            if not safeHRP or not head then
                task.wait(0.5)
                continue
            end

            local myChar = plr.Character
            local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if not myHRP then
                task.wait(0.5)
                continue
            end

            local charHRP = character:FindFirstChild("HumanoidRootPart")
            local charTOR = character:FindFirstChild("Torso")
            if not charHRP then
                task.wait(0.5)
                continue
            end

            local tpRunning = true
            local CF
            task.spawn(function()
                while tpRunning and blobLoopT4 do
                    if not player.Parent then break end
                    local ok, cf = TP(player)
                    if ok and cf then 
                        CF = cf
                    end
                    task.wait()
                end
            end)

            local shouldContinue = false
            while blobLoopT4 do
                if not character.Parent or not charHUM or charHUM.Health <= 0 then 
                    tpRunning = false
                    shouldContinue = true

                    local myChar = plr.Character
                    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
                    if myHRP and originPositions[player] then
                        myHRP.CFrame = originPositions[player]
                    end
                    break
                end

                local mySeat = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").SeatPart
                local amIRiding = mySeat and mySeat.Parent and mySeat.Parent.Name == "CreatureBlobman"

                rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
                local ownerTag = head:FindFirstChild("PartOwner")

                if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                    break
                else
                    if amIRiding then
                        BlobGrab(currentBlobS, charHRP, "Right")
                        BlobRelease(currentBlobS, charHRP, "Right")
                    end
                    if amIRiding and charHUM then
                        charHUM.Sit = true
                        task.wait(0.05)
                        charHUM.Sit = false
                    end
                end
                task.wait(0.05)
            end

            if not shouldContinue then
                tpRunning = false

                local targetCFrame
                if CF then
                    targetCFrame = CF
                    BACK(CF)
                elseif originPositions[player] then
                    targetCFrame = originPositions[player]
                    BACK(originPositions[player])
                end

                if anchorToggleTasks[player] then
                    task.cancel(anchorToggleTasks[player])
                    anchorToggleTasks[player] = nil
                end

                if not ownerTags[player] then
                    local tag = Instance.new("StringValue")
                    tag.Name = "OwnerKickRagdoll"
                    tag.Parent = head
                    ownerTags[player] = tag
                end

                local targetNames = {"NinjaKunai","NinjaShuriken","NinjaKatana","ToolCleaver","ToolDiggingForkRusty","ToolPencil","ToolPickaxe"}
                for _, child in ipairs(workspace:GetChildren()) do
                    if child:IsA("Folder") and child.Name:match("SpawnedInToys$") then
                        for _, item in ipairs(child:GetChildren()) do
                            if table.find(targetNames, item.Name) and item:FindFirstChild("StickyPart") then
                                local sticky = item.StickyPart
                                local weld = sticky:FindFirstChild("StickyWeld")
                                if weld and weld:IsA("WeldConstraint") and weld.Part1 and weld.Part1:IsDescendantOf(character) then
                                    rs.GrabEvents.SetNetworkOwner:FireServer(sticky, sticky.CFrame)
                                    sticky.CFrame = CFrame.new(0,9999,0)
                                end
                            end
                        end
                    end
                end

                if independentHoldConnections[player] then
                    independentHoldConnections[player]:Disconnect()
                    independentHoldConnections[player] = nil
                end

                independentHoldConnections[player] = RunService.Heartbeat:Connect(function()
                    if not blobLoopT4 or not character or not character.Parent or not charHRP or not charHRP.Parent or not charHUM or charHUM.Health <= 0 then
                        if independentHoldConnections[player] then 
                            independentHoldConnections[player]:Disconnect()
                            independentHoldConnections[player] = nil
                            destroyCounts[player] = nil
                        end
                        if anchorToggleTasks[player] then
                            task.cancel(anchorToggleTasks[player])
                            anchorToggleTasks[player] = nil
                        end
                        if ownerTags[player] then
                            ownerTags[player]:Destroy()
                            ownerTags[player] = nil
                        end
                        if charTOR then
                            charTOR.Anchored = false
                        end

                        local myChar = plr.Character
                        local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
                        if myHRP and originPositions[player] then
                            myHRP.CFrame = originPositions[player]
                        end
                        
                        return
                    end

                    local currentSeat = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").SeatPart
                    local isRidingNow = currentSeat and currentSeat.Parent and currentSeat.Parent.Name == "CreatureBlobman"

                    if not isRidingNow and not OwnerKickMODED then
                    if not charHUM.Sit  and not OnlyOwner then rs.GrabEvents.SetNetworkOwner:FireServer(charHRP, CFrame.lookAt(myHRP.Position, charHRP.Position)) end
                    if charHUM.Sit and not OnlyOwner then rs.GrabEvents.DestroyGrabLine:FireServer(charHRP) end
                    if player.IsHeld then rs.GrabEvents.SetNetworkOwner:FireServer(charHRP, CFrame.lookAt(myHRP.Position, charHRP.Position)) end
                    if charHUM.Sit and not OnlyOwner then rs.GrabEvents.DestroyGrabLine:FireServer(charHRP) end
end
                    if not isRidingNow and OwnerKickMODED then
                    rs.GrabEvents.SetNetworkOwner:FireServer(charHRP, CFrame.lookAt(myHRP.Position, charHRP.Position))
                    if not OnlyOwner then rs.GrabEvents.DestroyGrabLine:FireServer(charHRP) end
                    if SitMODED then charHUM.Sit = true end
end
                    if isRidingNow then
                    rs.GrabEvents.SetNetworkOwner:FireServer(charHRP, CFrame.lookAt(myHRP.Position, charHRP.Position))
                    if not OnlyOwner then rs.GrabEvents.DestroyGrabLine:FireServer(charHRP) end
                    if SitMODED then  charHUM.Sit = true end
end

                    local targetPosition
                    if blobLoopT4 then
                        targetPosition = myHRP.CFrame * CFrame.new(OLTPValue)
                    end

                    --if isnetworkowner(charHRP) then charHRP.CFrame = targetPosition end
                    charHRP.CFrame = targetPosition
                end)

                if SkipOL then task.wait(2) end

                anchorToggleTasks[player] = task.spawn(function()
                    while blobLoopT4 and character and character.Parent and charHRP and charHRP.Parent and charHUM and charHUM.Health > 0 do
                        if charTOR and SkipOL then charTOR.Anchored = true end
                        task.wait()
                    end
                end)

                while blobLoopT4 do
                    if not character.Parent or not charHRP.Parent or charHUM.Health <= 0 then 
                        if independentHoldConnections[player] then
                            independentHoldConnections[player]:Disconnect()
                            independentHoldConnections[player] = nil
                        end
                        if anchorToggleTasks[player] then
                            task.cancel(anchorToggleTasks[player])
                            anchorToggleTasks[player] = nil
                        end
                        if ownerTags[player] then
                            ownerTags[player]:Destroy()
                            ownerTags[player] = nil
                        end
                        if charTOR then
                            charTOR.Anchored = false
                        end

                        local myChar = plr.Character
                        local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
                        if myHRP and originPositions[player] then
                            myHRP.CFrame = originPositions[player]
                        end
                        
                        break 
                    end

                    local currentSeat = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").SeatPart
                    if currentSeat and currentSeat.Parent and currentSeat.Parent.Name == "CreatureBlobman" then
                        BlobGrab(currentBlobS, charHRP, "Right")
                        task.wait(0.03)
                        BlobRelease(currentBlobS, charHRP, "Right")
                        charHUM.Sit = true
                        task.delay(0.02, function() if charHUM then charHUM.Sit = false end end)
                    end
                    task.wait(0.01)
                end

                if independentHoldConnections[player] then 
                    independentHoldConnections[player]:Disconnect()
                    independentHoldConnections[player] = nil
                end

                if anchorToggleTasks[player] then
                    task.cancel(anchorToggleTasks[player])
                    anchorToggleTasks[player] = nil
                end

                if ownerTags[player] then
                    ownerTags[player]:Destroy()
                    ownerTags[player] = nil
                end

                if charTOR then
                    charTOR.Anchored = false
                end

                local myChar = plr.Character
                local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
                if myHRP and originPositions[player] then
                    myHRP.CFrame = originPositions[player]
                end
            end

            if originPositions[player] then
                originPositions[player] = nil
            end
            
            task.wait(0.5)
        end
    end

    task.spawn(function()
        while blobLoopT4 do
            local targetList = {}
            if playersInLoop1V then for _, v in pairs(playersInLoop1V) do table.insert(targetList, v) end end
            if playersInLoop2V then for _, v in pairs(playersInLoop2V) do table.insert(targetList, v) end end

            for _, name in ipairs(targetList) do
                local player = game.Players:FindFirstChild(name)
                if not player or player == plr then continue end
                if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end

                if not monitoredPlayers[player] then
                    monitoredPlayers[player] = true
                    if not runningTasks[player] then
                        runningTasks[player] = task.spawn(function()
                            pcall(function() processPlayer(player) end)
                            runningTasks[player] = nil
                            monitoredPlayers[player] = nil
                            if independentHoldConnections[player] then
                                independentHoldConnections[player]:Disconnect()
                                independentHoldConnections[player] = nil
                            end
                            if anchorToggleTasks[player] then
                                task.cancel(anchorToggleTasks[player])
                                anchorToggleTasks[player] = nil
                            end
                            if ownerTags[player] then
                                ownerTags[player]:Destroy()
                                ownerTags[player] = nil
                            end
                            if originPositions[player] then
                                originPositions[player] = nil
                            end
                            destroyCounts[player] = nil
                            if player.Character then
                                local charHRP = player.Character:FindFirstChild("HumanoidRootPart")
                                if charTOR then
                                    charTOR.Anchored = false
                                end
                            end
                        end)
                    end
                end
            end

            for player, taskInfo in pairs(runningTasks) do
                if not player.Parent then
                    task.cancel(taskInfo)
                    runningTasks[player] = nil
                    monitoredPlayers[player] = nil
                    if independentHoldConnections[player] then
                        independentHoldConnections[player]:Disconnect()
                        independentHoldConnections[player] = nil
                    end
                    if anchorToggleTasks[player] then
                        task.cancel(anchorToggleTasks[player])
                        anchorToggleTasks[player] = nil
                    end
                    if ownerTags[player] then
                        ownerTags[player]:Destroy()
                        ownerTags[player] = nil
                    end
                    if originPositions[player] then
                        originPositions[player] = nil
                    end
                    destroyCounts[player] = nil
                    if player.Character then
                        local charHRP = player.Character:FindFirstChild("HumanoidRootPart")
                        if charTOR then
                            charTOR.Anchored = false
                        end
                    end
                end
            end
            task.wait(0.5)
        end

        for player, task in pairs(anchorToggleTasks) do
            if task then
                task.cancel(task)
            end
        end

        for _, taskInfo in pairs(runningTasks) do task.cancel(taskInfo) end
        for player, connection in pairs(independentHoldConnections) do
            if connection then connection:Disconnect() end
        end

        for player, tag in pairs(ownerTags) do
            if tag then
                tag:Destroy()
            end
        end
        ownerTags = {}

        for player, originCF in pairs(originPositions) do
            local myChar = plr.Character
            local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if myHRP and originCF then
                myHRP.CFrame = originCF
            end
        end
        originPositions = {}

        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.Character then
                local charHRP = player.Character:FindFirstChild("HumanoidRootPart")
                if charTOR then
                    charTOR.Anchored = false
                end
            end
        end

        runningTasks = {}
        monitoredPlayers = {}
        independentHoldConnections = {}
        anchorToggleTasks = {}
        destroyCounts = {}
    end)
end

function loopPlayerF() -- ë£¹1
    UpdateCurrentBlobman()

    local currentProcessing = {}

    local function processPlayer(player)
        if not player then return false end

        local character, hrp, head = safeGetCharacterParts(player)
        if not hrp or not head then return false end

        local myChar = plr and plr.Character
        local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not myHrp then return false end
        local originCF = myHrp.CFrame

        local tpRunning = true
        task.spawn(function()
            while tpRunning do
                local ok, cf = TP(player)
                if ok and cf then
                    CF = cf
                end
                task.wait()
            end
        end)

        while loopPlayerT do
            if not player or not player.Character or not player.Character:FindFirstChild("Head") then break end
            
            rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
            local ownerTag = head:FindFirstChild("PartOwner")
            if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                break
            end
            task.wait()
        end

        tpRunning = false

        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if humanoid then

            rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
            rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
            rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)

            if humanoid.RigType ~= Enum.HumanoidRigType.R15 and humanoid.SeatPart == nil then humanoid.RigType = Enum.HumanoidRigType.R15 end

            if humanoid.BreakJointsOnDeath == true and humanoid.SeatPart == nil then humanoid.BreakJointsOnDeath = false end

            if head:FindFirstChildOfClass("BallSocketConstraint") then head.BallSocketConstraint.Attachment0 = nil end

            local FallenY = workspace.FallenPartsDestroyHeight
            local targetY = (FallenY <= -50000 and -49999) or (FallenY <= -100 and -99) or -100
            local storso = character:FindFirstChild("Torso")
            --local ownerTag = head:FindFirstChild("PartOwner")

            if storso then --and ownerTag.Value == plr.Name then
                storso.CFrame = CFrame.new(storso.Position.X, targetY, storso.Position.Z)
            end
        end

        if originCF then BACK(originCF) end
        return true
    end

    task.spawn(function()
        while loopPlayerT do
            for _, name in ipairs(playersInLoop2V) do
                local player = game.Players:FindFirstChild(name)

                if player and not table.find(Whitelist, player.Name) then
                    if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end

                    local character = player.Character
                    local humanoid = character and character:FindFirstChildOfClass("Humanoid")

                    if humanoid and humanoid.Health > 0 then
                        if not currentProcessing[player] then
                            currentProcessing[player] = true

                            task.spawn(function()
                                local success = processPlayer(player)

                                if success then
                                    task.wait(2)
                                end

                                currentProcessing[player] = nil
                            end)
                        end
                    else
                        currentProcessing[player] = nil
                    end
                else
                    if player then
                        currentProcessing[player] = nil
                    end
                end
            end
            task.wait(0.05)
        end
    end)
end

function loopPlayerF2() -- ë£¹2
    UpdateCurrentBlobman()

    local processedHumanoids = {}

    local function processPlayer(player)
        if not player then return false end

        local character, hrp, head = safeGetCharacterParts(player)
        if not hrp or not head then return false end

        local myChar = plr and plr.Character
        local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not myHrp then return false end
        local originCF = myHrp.CFrame

        local tpRunning = true
        task.spawn(function()
            while tpRunning do
                local ok, cf = TP(player)
                if ok and cf then
                    CF = cf
                end
                task.wait()
            end
        end)

        while loopPlayerT2 do
            rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
            local ownerTag = head:FindFirstChild("PartOwner")
            if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                break
            end
            task.wait()
        end

        tpRunning = false

        local targetNames = {
            "NinjaKunai", "NinjaShuriken", "NinjaKatana",
            "ToolCleaver", "ToolDiggingForkRusty",
            "ToolPencil", "ToolPickaxe"
        }

        for _, child in ipairs(workspace:GetChildren()) do
            if child:IsA("Folder") and child.Name:match("SpawnedInToys$") then
                for _, item in ipairs(child:GetChildren()) do
                    if table.find(targetNames, item.Name) and item:FindFirstChild("StickyPart") then
                        local sticky = item.StickyPart
                        local weld = sticky:FindFirstChild("StickyWeld")

                        if weld and weld:IsA("WeldConstraint") and weld.Part1 then
                            local targetParts = {
                                character:FindFirstChild("Head"),
                                character:FindFirstChild("Torso"),
                                character:FindFirstChild("Left Arm"),
                                character:FindFirstChild("Left Leg"),
                                character:FindFirstChild("Right Arm"),
                                character:FindFirstChild("Right Leg"),
                                hrp:FindFirstChild("RagdollTouchedHitbox"),
                                hrp:FindFirstChild("FirePlayerPart"),
                            }

                            for _, tPart in ipairs(targetParts) do
                                if tPart and weld.Part1 == tPart then
                                    local basePart = item.PrimaryPart or sticky
                                    if basePart and (basePart.Position - hrp.Position).Magnitude <= 10 then
                                        rs.GrabEvents.SetNetworkOwner:FireServer(sticky, sticky.CFrame)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        rs.GrabEvents.DestroyGrabLine:FireServer(head, head.CFrame)

        hrp.CFrame = CFrame.new(99999999, 99999999, 99999999)

        task.spawn(function()
            while loopPlayerT2 do
                if hrp and hrp.Parent and hrp.Position.Y < 99999 then
                    local innerTP = true
                    task.spawn(function()
                        while innerTP do
                            local ok, cf = TP(player)
                            if ok and cf then
                                CF = cf
                            end
                            task.wait()
                        end
                    end)

                    while loopPlayerT2 do
                        rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
                        local ownerTag = head:FindFirstChild("PartOwner")
                        if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                            break
                        end
                        task.wait()
                    end

                    innerTP = false
                    rs.GrabEvents.DestroyGrabLine:FireServer(head, head.CFrame)
                    hrp.CFrame = CFrame.new(99999999, 99999999, 99999999)
                end
                task.wait(0.2)
            end
        end)

        if originCF then
            BACK(originCF)
        end

        return true
    end

    task.spawn(function()
        while loopPlayerT2 do
            for _, name in ipairs(playersInLoop2V) do
                local player = game.Players:FindFirstChild(name)
                if player and not table.find(Whitelist, player.Name) then
                    local character = player.Character
                    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
                    if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end

                    if humanoid and humanoid.Health > 0 then
                        if processedHumanoids[player] ~= humanoid then
                            local success = processPlayer(player)
                            if success then
                                processedHumanoids[player] = humanoid
                            end
                        end
                    else
                        processedHumanoids[player] = nil
                    end
                    task.wait(0.05)
                end
            end
            task.wait(0.05)
        end
    end)
end

function loopPlayerF3() -- ë£¹3
    UpdateCurrentBlobman()

    local currentProcessing = {}

    local function processPlayer(player)
        if not player then return false end

        local character, hrp, head = safeGetCharacterParts(player)
        if not hrp or not head then return false end

        local myChar = plr and plr.Character
        local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not myHrp then return false end
        local originCF = myHrp.CFrame

        local tpRunning = true
        task.spawn(function()
            while tpRunning do
                local ok, cf = TP(player)
                if ok and cf then
                    CF = cf
                end
                task.wait()
            end
        end)

        while loopPlayerT3 do
            if not player or not player.Character or not player.Character:FindFirstChild("Head") then break end

            local ownerTag = head:FindFirstChild("FAKE")
            if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                break
            end
            task.wait()
        end

        tpRunning = false

        if originCF then BACK(originCF) end
        return true
    end

    task.spawn(function()
        while loopPlayerT3 do
            for _, name in ipairs(playersInLoop2V) do
                local player = game.Players:FindFirstChild(name)

                if player and not table.find(Whitelist, player.Name) then
                    if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end

                    local character = player.Character
                    local humanoid = character and character:FindFirstChildOfClass("Humanoid")

                    if humanoid and humanoid.Health > 0 then
                        if not currentProcessing[player] then
                            currentProcessing[player] = true

                            task.spawn(function()
                                local success = processPlayer(player)

                                if success then
                                    task.wait(2)
                                end

                                currentProcessing[player] = nil
                            end)
                        end
                    else
                        currentProcessing[player] = nil
                    end
                else
                    if player then
                        currentProcessing[player] = nil
                    end
                end
            end
            task.wait(0.05)
        end
    end)
end

local RunService = game:GetService("RunService")
local notifyCooldowns = {}
local AntiBlobConnection = nil

function AntiBlobF()
    if AntiBlobConnection then 
        AntiBlobConnection:Disconnect() 
        AntiBlobConnection = nil
    end

    AntiBlobConnection = RunService.Stepped:Connect(function()
        if not AntiBlobT then 
            if AntiBlobConnection then 
                AntiBlobConnection:Disconnect() 
                AntiBlobConnection = nil
            end
            return 
        end

        local myChar = plr.Character
        if not myChar then return end
        local humanoid = myChar:FindFirstChild("Humanoid")
        local myHRP = myChar:FindFirstChild("HumanoidRootPart")

        local myAttach = myHRP and myHRP:FindFirstChild("RootAttachment")

        if not (myHRP and myAttach) then 
            return
        end

        if inv then
            for _, blob in ipairs(inv:GetChildren()) do
                if blob.Name == "CreatureBlobman" then
                    local occupantName = "{me}"
                    local vehicleSeat = blob:FindFirstChild("VehicleSeat")
                    if vehicleSeat and vehicleSeat.Occupant then
                        local character = vehicleSeat.Occupant.Parent
                        if character then
                            local player = game.Players:GetPlayerFromCharacter(character)
                            if player then
                                occupantName = player.Name
                            end
                        end
                    end
                    CheckBlob(blob, myHRP, myAttach, occupantName)
                end
            end
        end

        for _, player in ipairs(game.Players:GetPlayers()) do
            if player ~= plr then
                local invs = workspace:FindFirstChild(player.Name .. "SpawnedInToys")
                if invs then
                    for _, blob in ipairs(invs:GetChildren()) do
                        if blob.Name == "CreatureBlobman" then
                            local occupantName = player.Name
                            local vehicleSeat = blob:FindFirstChild("VehicleSeat")
                            if vehicleSeat and vehicleSeat.Occupant then
                                local character = vehicleSeat.Occupant.Parent
                                if character then
                                    local occupantPlayer = game.Players:GetPlayerFromCharacter(character)
                                    if occupantPlayer then
                                        occupantName = occupantPlayer.Name
                                    end
                                end
                            end
                            CheckBlob(blob, myHRP, myAttach, occupantName)
                        end
                    end
                end
            end
        end

        local plots = workspace:FindFirstChild("PlotItems")
        if plots then
            for i = 1, 5 do
                local plot = plots:FindFirstChild("Plot" .. i)
                if plot then
                    for _, blob in ipairs(plot:GetChildren()) do
                        if blob.Name == "CreatureBlobman" then
                            local occupantName = "Plot " .. i
                            local vehicleSeat = blob:FindFirstChild("VehicleSeat")
                            if vehicleSeat and vehicleSeat.Occupant then
                                local character = vehicleSeat.Occupant.Parent
                                if character then
                                    local player = game.Players:GetPlayerFromCharacter(character)
                                    if player then
                                        occupantName = player.Name
                                    end
                                end
                            end
                            CheckBlob(blob, myHRP, myAttach, occupantName)
                        end
                    end
                end
            end
        end
    end)
end

function CheckBlob(blob, myHRP, myAttach, source)
    local script = blob:FindFirstChild("BlobmanSeatAndOwnerScript")
    if not script then return end

    for _, side in ipairs({"Left", "Right"}) do
        local detector = blob:FindFirstChild(side .. "Detector")
        if not detector then continue end

        local weld = detector:FindFirstChild(side .. "Weld")
        local align = detector:FindFirstChild(side .. "AlignOrientation")

        if weld and weld:IsA("AlignPosition") and weld.Attachment0 == myAttach then
            local msg = source .. " â†’ " .. side .. " Grab"
            local now = tick()

            if not notifyCooldowns[msg] or (now - notifyCooldowns[msg]) >= 2 then
                notifyCooldowns[msg] = now
                Rayfield:Notify({Title = "[ âœŠ ]", Content = msg, Duration = 3, Image = 0})
            end

            local success, errorMsg = pcall(function()
                rs.CharacterEvents.RagdollRemote:FireServer(myHRP, 0)

                local myChar = plr.Character
                if not myChar then return end

                local myHD = myChar:FindFirstChild("Head")
                local myLA = myChar:FindFirstChild("Left Arm")
                local myRA = myChar:FindFirstChild("Right Arm")
                local myLL = myChar:FindFirstChild("Left Leg")
                local myLR = myChar:FindFirstChild("Right Leg")

                if humanoid then
                    humanoid.PlatformStand = true
                end

                local bodyParts = {}

                if myHRP then table.insert(bodyParts, myHRP) end
                if myHD then table.insert(bodyParts, myHD) end
                if myLA then table.insert(bodyParts, myLA) end
                if myRA then table.insert(bodyParts, myRA) end
                if myLL then table.insert(bodyParts, myLL) end
                if myLR then table.insert(bodyParts, myLR) end

                for _, part in ipairs(bodyParts) do
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end

                align.Attachment0 = nil
                weld.Attachment0 = nil
                weld.Enabled = false
                align.Enabled = false

                for _, part in ipairs(bodyParts) do
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end

                weld.Enabled = true
                align.Enabled = true

                if humanoid then
                    humanoid.PlatformStand = false
                end

                for _, part in ipairs(bodyParts) do
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end
            end)

            if not success then
                warn("CheckBlob: " .. errorMsg)
            end
        end
    end
end

function AntiStickyGBF()
    if not AntiStickyGBT then
        return
    end

    while AntiStickyGBT do
        local char = plr.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then 
            task.wait(0.1)
            continue
        end

        local desk = inv:FindFirstChild("WD")

        if not desk then
            local spawnRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("SpawnToyRemoteFunction")
            if spawnRemote then
                local offset = hrp.CFrame.LookVector * -24
                local spawnCF = hrp.CFrame + Vector3.new(0, 0, 0) + offset
                task.spawn(function()
                    pcall(function()
                        spawnRemote:InvokeServer("SprayCanWD", spawnCF, spawnCF.Position)
                    end)
                end)
                task.wait(0.001)

                for _, item in pairs(inv:GetChildren()) do
                    if item.Name == "SprayCanWD" then
                        item.Name = "WD"
                        desk = item
                        break
                    end
                end
            end

            if not desk then
                task.wait(0.1)
                continue
            end
        end

        local main = desk:FindFirstChild("Main")
        if main then
            local bp = main:FindFirstChildOfClass("BodyPosition")
            if not bp then
                bp = Instance.new("BodyPosition")
                bp.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bp.Position = Vector3.new(hrp.CFrame.X, 600, hrp.CFrame.Z)
                bp.Parent = main
            else
                bp.Position = Vector3.new(hrp.CFrame.X, 600, hrp.CFrame.Z)
            end
        end

        local hitbox = desk:FindFirstChild("Hitbox")
        if not hitbox then
            task.wait(0.1)
            continue
        end

        local partOwner = hitbox:FindFirstChild("PartOwner")
        if not partOwner or partOwner.Value ~= plr.Name then
            rs.GrabEvents.SetNetworkOwner:FireServer(hitbox, hitbox.CFrame)
            task.wait(0.1)
            partOwner = hitbox:FindFirstChild("PartOwner")
            if not partOwner or partOwner.Value ~= plr.Name then
                task.wait(0.1)
                continue
            end
        end

        local hitbox2 = desk:FindFirstChild("StickyRemoverPart")
        if not hitbox2 then
            task.wait(0.1)
            continue
        end

        local validRoots = {}
        for _, name in ipairs(playersInLoop1V) do
            local player = game.Players:FindFirstChild(name)
            if player and player.Character then
                local root = player.Character:FindFirstChild("HumanoidRootPart") 
                if root and not playersInPlotsFolder:FindFirstChild(name) then
                    table.insert(validRoots, root)
                end
            end
        end

        if #validRoots > 0 then
            for _, targetRoot in ipairs(validRoots) do
                if targetRoot then
                    local behindCFrame = targetRoot.CFrame * CFrame.new(1,0,3)
                    hitbox2.CFrame = behindCFrame
                    task.wait()
                end
            end
        end

        task.wait(0.05)
    end
end

function RagdollGrabF()
    if not RagdollGrabT then
        local deskToRemove = inv:FindFirstChild("RB")
        if deskToRemove then
            local destroyRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("DestroyToy")
            if destroyRemote then
                destroyRemote:FireServer(deskToRemove)
            end
        end
        return
    end

    while RagdollGrabT and task.wait() do
        local char = plr.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then
            continue
        end

        local desk = inv:FindFirstChild("RB")

        if not desk then
            local spawnRemote = rs.MenuToys.SpawnToyRemoteFunction
            if spawnRemote then
                local offset = hrp.CFrame.LookVector * -24
                local spawnCF = hrp.CFrame + offset

                task.spawn(function()
                    pcall(function()
                        spawnRemote:InvokeServer("PalletLightBrown", spawnCF, spawnCF.Position)
task.wait(0.1)
                    end)

                    for attempt = 3, 3 do
                        for _, item in pairs(inv:GetChildren()) do
                            if item.Name == "PalletLightBrown" then
                                local soundPart = item:FindFirstChild("SoundPart")
                                if soundPart then
                                    for i = 3, 3 do
                                        pcall(function()
                                            rs.GrabEvents.SetNetworkOwner:FireServer(soundPart, soundPart.CFrame)
                                            rs.GrabEvents.SetNetworkOwner:FireServer(soundPart, hrp.CFrame)
                                        end)
                                    end

                                    local partOwner = soundPart:FindFirstChild("PartOwner")
                                    if partOwner and partOwner.Value == plr.Name then
                                        item.Name = "RB"
                                        return
                                    end
                                end
                            end
                        end
                        task.wait()
                    end
                end)

                task.wait()
                desk = inv:FindFirstChild("RB")
            end
        end

        if not desk then 
            continue 
        end

        pcall(function()
            for _, part in ipairs(desk:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)

        local soundPart = desk:FindFirstChild("SoundPart")
        if not soundPart then
            local destroyRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("DestroyToy")
            if destroyRemote then
                destroyRemote:FireServer(desk)
            end
            continue
        end

        local partOwner = soundPart:FindFirstChild("PartOwner")
        if not partOwner or partOwner.Value ~= plr.Name then
            local destroyRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("DestroyToy")
            if destroyRemote then
                destroyRemote:FireServer(desk)
            end
            continue
        end

        local targetFound = false

        for _, other in pairs(game:GetService("Players"):GetPlayers()) do
            if other ~= plr and other.Character and other.Character:FindFirstChild("Head") then
                local head = other.Character.Head
                local headPartOwner = head:FindFirstChild("PartOwner")
                local FreeKick = head:FindFirstChild("OwnerKickRagdoll")

                if (headPartOwner and headPartOwner:IsA("StringValue") and headPartOwner.Value == plr.Name) or 
                   (FreeKick and FreeKick:IsA("StringValue")) then

                    local humanoid = other.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        local ragdolled = humanoid:FindFirstChild("Ragdolled")
                        if ragdolled and ragdolled:IsA("BoolValue") and ragdolled.Value then
                            continue
                        end
                    end

                    local otherHrp = other.Character:FindFirstChild("HumanoidRootPart")
                    if otherHrp then
                        soundPart.CFrame = CFrame.new(0,9999,0)
                        task.wait(0.01)
                        soundPart.CFrame = otherHrp.CFrame * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0))
                        targetFound = true
                        break
                    end
                end
            end
        end

        local main = desk:FindFirstChild("Main")
        if main then
            local bp = main:FindFirstChildOfClass("BodyPosition")
            if not bp then
                bp = Instance.new("BodyPosition")
                bp.MaxForce = Vector3.new(999999, 999999, 999999)
                bp.P = 500000
                bp.D = 5000
                bp.Parent = main
            end

            if not targetFound then
                local highPosition = Vector3.new(0, 9999, 0)
                bp.Position = highPosition
                soundPart.CFrame = CFrame.new(highPosition)
            else
                bp.Position = soundPart.Position
            end
        end
    end

    if not RagdollGrabT then
        local deskToRemove = inv:FindFirstChild("RB")
        if deskToRemove then
            local destroyRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("DestroyToy")
            if destroyRemote then
                destroyRemote:FireServer(deskToRemove)
            end
        end
    end
end

function AntiGrabStickyF()
    local plr = game.Players.LocalPlayer
    
    while AntiGrabStickyT and plr do
        task.wait(0.1)

        local char = plr.Character
        if not char or not char.Parent then
            continue
        end

        local inv = workspace:WaitForChild(plr.Name.."SpawnedInToys")
        local rs = game:GetService("ReplicatedStorage")
        local StickyPartEvent = rs.PlayerEvents.StickyPartEvent
        local SetNetworkOwner = rs.GrabEvents.SetNetworkOwner
        local SpawnToyRemoteFunction = rs.MenuToys.SpawnToyRemoteFunction 
        local DestroyToy = rs.MenuToys.DestroyToy

        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        local head = char:FindFirstChild("Head")
        if not hrp or not hum or not head then
            continue
        end

        local agFolder = inv:FindFirstChild("AG")
        local stickyPart = agFolder and agFolder:FindFirstChild("StickyPart")

        local headPartOwner = head:FindFirstChild("PartOwner")
        local stickyWeld = stickyPart and stickyPart:FindFirstChild("StickyWeld")
        local targetPart = hrp:FindFirstChild("RagdollTouchedHitbox")

        if headPartOwner and stickyWeld and targetPart and stickyWeld.Part1 == targetPart then
            pcall(function()
                SetNetworkOwner:FireServer(stickyPart, stickyPart.CFrame)
            end)

            if hum.Sit then
                hum.Sit = false
            end
            if not hum.AutoRotate then
                hum.AutoRotate = true
            end

            headPartOwner:Destroy()
        end

        if stickyWeld and targetPart and stickyWeld.Part1 ~= targetPart then
            pcall(function()
                SetNetworkOwner:FireServer(stickyPart, stickyPart.CFrame)
            end)
        end

        if stickyPart then
            local distance = (hrp.Position - stickyPart.Position).Magnitude
            if distance > 25 then
                pcall(function()
                    DestroyToy:FireServer(agFolder)
                end)
                task.wait(0.001)
            else
                local partOwner = stickyPart:FindFirstChild("PartOwner")
                if not partOwner or partOwner.Value ~= plr.Name then
                    pcall(function()
                        SetNetworkOwner:FireServer(stickyPart, hrp.CFrame)
                    end)
                end

                local targetPart = hrp:FindFirstChild("RagdollTouchedHitbox")
                local stickyWeld = stickyPart:FindFirstChild("StickyWeld")

                if targetPart and stickyPart then
                    if not stickyWeld or stickyWeld.Part1 ~= targetPart then
                        pcall(function()
                            StickyPartEvent:FireServer(stickyPart, targetPart, CFrame.new(0, -0.3, 0.3) * CFrame.Angles(190, 0, 0))
                        end)
                    end
                end
            end
        else
            local existingNinja = inv:FindFirstChild("AG")
            if not existingNinja then

                task.spawn(function()
                    pcall(function()
                        SpawnToyRemoteFunction:InvokeServer("NinjaShuriken", hrp.CFrame * CFrame.new(0,10,20), Vector3.new(0,0,0))
                    end)
                end)

                task.wait(0.001)

                local newNinjaFolder = inv:FindFirstChild("NinjaShuriken")
                if newNinjaFolder then
                    local newStickyPart = newNinjaFolder:FindFirstChild("StickyPart")
                    if newStickyPart then
                        local distance = (hrp.Position - newStickyPart.Position).Magnitude
                        if distance <= 30 then
                            newNinjaFolder.Name = "AG"
                        else
                            pcall(function()
                                DestroyToy:FireServer(newNinjaFolder)
                            end)
                        end
                    end
                end
            else
                local newStickyPart = existingNinja:FindFirstChild("StickyPart")
                if newStickyPart then
                    local distance = (hrp.Position - newStickyPart.Position).Magnitude
                    if distance <= 30 then
                        existingNinja.Name = "AG"
                    end
                end
            end
        end
    end
end

RunService = game:GetService("RunService")
isvs = false

function AntiGrabF(enable)
    if antiGrabConn then
        antiGrabConn:Disconnect()
        antiGrabConn = nil
    end

    if not enable then 
        local char = plr.Character
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChild("Humanoid")

        if hrp and hrp.Anchored then hrp.Anchored = false end
        if hum then
            hum.RequiresNeck = true
            hum.Sit = false
            hum:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
        return 
    end

    local lastHeldState = false
    local sitHoldTimer = 0
    local shouldKeepSit = false
    local wasHeld = false
    local lastRagdollTime = 0
    local ragdollDuration = 0.48

    antiGrabConn = RunService.Heartbeat:Connect(function(deltaTime)
        local char = plr.Character
        if not char then return end

        local hum = char:FindFirstChild("Humanoid")
        isvs = hum and hum.SeatPart ~= nil

        local isHeld = plr:FindFirstChild("IsHeld")
        if not isHeld then return end

        local head = char:FindFirstChild("Head")
        local POR = head and head:FindFirstChild("PartOwner")
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hrp2 = char:FindFirstChild("Torso")
        if not hum then return end

        local FPDH = workspace.FallenPartsDestroyHeight
        local DY = (FPDH <= -50000 and -49999) or (FPDH <= -100 and -99) or -100
        local now = tick()

        if hum then
            hum.RequiresNeck = false
            hum.AutoRotate = true
        end

        if isvs and POR then
        task.wait(0.3)
        end

        if POR and POR.Value then
            local attackerName = POR.Value

            if attackerName and WhiteListMode then
                local inWhitelist = false
                for _, whiteName in ipairs(Whitelist) do
                    if whiteName == attackerName then
                        inWhitelist = true
                        break
                    end
                end
                if inWhitelist then 
                    return 
                end
            end
        end

        if isvs then task.wait(0.3) end

        local rag = hum:FindFirstChild("Ragdolled")
        if isHeld.Value == true and rag and rag.Value == true then
            for _, limbName in ipairs({"Head", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}) do
                local limb = char:FindFirstChild(limbName)
                if limb then
                    local ragdollPart = limb:FindFirstChild("RagdollLimbPart")
                    local ragdollCons = limb:FindFirstChild("BallSocketConstraint")
                    if ragdollCons then ragdollCons.Enabled = false end
                    if ragdollPart then ragdollPart.CanCollide = false end
                end
            end
        end

        if hum.Health <= 0 then
            lastHeldState = false
            shouldKeepSit = false
            sitHoldTimer = 0
            wasHeld = false
            hum.Sit = false
            hum.AutoRotate = true
        end

        if not hrp or hum.Health <= 0 then
            hum:ChangeState(Enum.HumanoidStateType.Dead)
            char:BreakJoints()
            --rs.CharacterEvents.Struggle:FireServer()
            --if hrp2 then hrp2.CFrame = CFrame.new(9999, DY, 9999) end
        end

        if isHeld.Value == true then
            if hum.MoveDirection.Magnitude > 0 then
                local moveSpeed = 10
                local moveVector = hum.MoveDirection * deltaTime * moveSpeed

                hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)

                moveVector = Vector3.new(moveVector.X, 0, moveVector.Z)
                hrp.CFrame = hrp.CFrame + moveVector
                hrp2.CFrame = hrp2.CFrame + moveVector
            end
        end

        if isHeld.Value ~= lastHeldState then
            if isHeld.Value == true then
                wasHeld = true
                shouldKeepSit = true
                sitHoldTimer = 0.3
                hum:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
                hum.Sit = true
                hum.AutoRotate = true

                lastRagdollTime = now
                if POR and hrp then
                    rs.CharacterEvents.Struggle:FireServer()
                    rs.CharacterEvents.RagdollRemote:FireServer(hrp, 0)
                end

                if hrp then
                    setRagdollF(true)
                end
            else
                if wasHeld then
                    shouldKeepSit = true
                    sitHoldTimer = 0.3
                end
            end
            lastHeldState = isHeld.Value
        end

        if lastRagdollTime > 0 and now - lastRagdollTime >= ragdollDuration then
            setRagdollF(false)
            lastRagdollTime = 0
        end

        if isHeld.Value == true and lastRagdollTime > 0 and now - lastRagdollTime < ragdollDuration then
            if hrp then 
                setRagdollF(true)
            end
        end

        if sitHoldTimer > 0 then
            sitHoldTimer = sitHoldTimer - deltaTime

            if isHeld.Value == true or POR or (rag and rag.Value == true) then
                shouldKeepSit = true
                sitHoldTimer = 0.3
                hum.Sit = true
                if isHeld.Value == true then
                    hum:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
                end
            else
                hum.Sit = true
            end
        end

        if sitHoldTimer <= 0 and shouldKeepSit then
            local currentRagdolled = hum:FindFirstChild("Ragdolled")
            if not currentRagdolled or currentRagdolled.Value == false then
                hum.Sit = false
                hum:ChangeState(Enum.HumanoidStateType.Running)
                shouldKeepSit = false
                wasHeld = false
            else
                sitHoldTimer = 0.3
            end
        end

        if shouldKeepSit then
            hum.Sit = true
        end

        if POR then
            local attackerName = POR.Value

            if attackerName and WhiteListMode then
                local inWhitelist = false
                for _, whiteName in ipairs(Whitelist) do
                    if whiteName == attackerName then
                        inWhitelist = true
                        break
                    end
                end
                if inWhitelist then 
                    return 
                end
            end

            rs.CharacterEvents.Struggle:FireServer()
            rs.CharacterEvents.RagdollRemote:FireServer(hrp, 0)
            shouldKeepSit = true
            sitHoldTimer = 0.3
            hum.Sit = true
            hum.AutoRotate = true
            lastRagdollTime = now
            if hrp then
                setRagdollF(true)
            end
        end
    end)
end

function PlotBarrierDelete()
if PBDrun then return end
PBDrun = true

local char = plr.Character
if not char then PBDrun = false return end

local hrp = char:FindFirstChild("HumanoidRootPart")
if not hrp then PBDrun = false return end

local metal = workspace.Plots.Plot1.TeslaCoil.Metal
if not metal then PBDrun = false return end

local TP = metal.CFrame
local OCF = hrp.CFrame

task.spawn(function()
rs.MenuToys.SpawnToyRemoteFunction:InvokeServer("FoodBread", hrp.CFrame, Vector3.new(0,0,0))
end)

task.wait(0.2)

local foodBread = inv:FindFirstChild("FoodBread")
if not foodBread then PBDrun = false return end

if foodBread then
task.spawn(function()
foodBread.HoldPart.HoldItemRemoteFunction:InvokeServer(foodBread, char)
end)
end

task.wait(0.1)

hrp.CFrame = TP
task.wait(0.17)

if foodBread then
rs.MenuToys.DestroyToy:FireServer(foodBread)
end

hrp.CFrame = OCF
task.wait(0.4)

PBDrun = false
end

function antiPaintF(state)
    local function setParts(canTouch)
        local char = plr.Character
        if not char then return end
        local parts = {
            "Head",
            "HumanoidRootPart",
            "Torso",
            "Left Arm",
            "Right Arm",
            "Left Leg",
            "Right Leg"
        }
        for _, partName in ipairs(parts) do
            local part = char:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                part.CanTouch = canTouch
            end
        end
    end

    if state == true then
        task.spawn(function()
            while AntiPaintT do
                setParts(false)
                task.wait(0.1)
            end
        end)
    else
        setParts(true)
    end
end

local AntiKickF = function()
    local plr = game.Players.LocalPlayer
    local char = plr.Character
    if not char then return end

    if AntiGrabTP_Active then
        return
    end

    local inv = workspace:WaitForChild(plr.Name .. "SpawnedInToys")
    local rs = game:GetService("ReplicatedStorage")
    local StickyPartEvent = rs.PlayerEvents.StickyPartEvent
    local SetNetworkOwner = rs.GrabEvents.SetNetworkOwner
    local SpawnToyRemoteFunction = rs.MenuToys.SpawnToyRemoteFunction
    local DestroyToy = rs.MenuToys.DestroyToy

    local function findMyPO()
        local myDisplayName = plr.DisplayName
        local myUserName = plr.Name
        local myPOIdentifier = string.format("[ %s ] ( @%s )", myDisplayName, myUserName)
        
        for _, obj in pairs(workspace:GetChildren()) do
            if obj.Name == "PlayerCharacterLocationDetector" then
                for _, child in pairs(obj:GetChildren()) do
                    if child:IsA("BoolValue") and child.Name == myPOIdentifier then
                        return obj
                    end
                end
            end
        end
        return nil
    end

    while AntiKickT and char and char.Parent do
        if AntiGrabTP_Active then break end
        task.wait()

        local hrp = char:FindFirstChild("HumanoidRootPart")
        local torso = char:FindFirstChild("Torso")
        if not hrp or not torso then continue end

        local myPO = findMyPO()
        --local referencePosition = hrp.Position
        if myPO then referencePosition = myPO.Position end

        local ragdollHitbox = hrp:FindFirstChild("RagdollTouchedHitbox")
        if not ragdollHitbox then continue end

        local stickyPartName = "NinjaShuriken"
        local targetValue = CFrame.new(0.05, -0.3, 0) * CFrame.Angles(190, 0, 0)

        local stickyPartFolder = inv:FindFirstChild(stickyPartName)
        local stickyPart = stickyPartFolder and stickyPartFolder:FindFirstChild("StickyPart")
        local soundPart = stickyPartFolder and stickyPartFolder:FindFirstChild("SoundPart")

        if not stickyPart then
            local success = pcall(function()
            task.spawn(function()
                SpawnToyRemoteFunction:InvokeServer(stickyPartName, SCF.CFrame, Vector3.new(0, 0, 0))
            end)
            end)

            if not success then continue end

            for _ = 0, 10 do
                task.wait(0.05)
                stickyPartFolder = inv:FindFirstChild(stickyPartName)
                if stickyPartFolder then break end
            end

            if not stickyPartFolder then continue end

            stickyPart = stickyPartFolder:FindFirstChild("StickyPart")
            soundPart = stickyPartFolder:FindFirstChild("SoundPart")

            if stickyPart then stickyPart.CanQuery = false end
            if soundPart then soundPart.CanQuery = false end

            if not stickyPart then continue end
        end

        pcall(function()
            SetNetworkOwner:FireServer(stickyPart, stickyPart.CFrame)
            DestroyGrabLine:FireServer(stickyPart)
        end)

        local distance = (referencePosition - stickyPart.Position).Magnitude
        if distance > 8 then
            pcall(function()
                DestroyToy:FireServer(stickyPartFolder)
            end)
            continue
        end

        local partOwner = stickyPart:FindFirstChild("PartOwner")
        if partOwner then
            pcall(function()
                DestroyToy:FireServer(stickyPartFolder)
            end)
            continue
        end

        local stickyWeld = stickyPart:FindFirstChild("StickyWeld")

        if not stickyWeld or stickyWeld.Part1 ~= ragdollHitbox then
            StickyPartEvent:FireServer(stickyPart, ragdollHitbox, targetValue)

            for _ = 0, 10 do
                task.wait(0.05)
                stickyWeld = stickyPart:FindFirstChild("StickyWeld")
                if stickyWeld and stickyWeld.Part1 == ragdollHitbox then
                    break
                end
            end
        end

        if stickyWeld and stickyWeld.Part1 == ragdollHitbox then
            while stickyWeld and stickyWeld.Part1 == ragdollHitbox and ragdollHitbox.Parent do
                if not AntiKickT or AntiGrabTP_Active then break end
                task.wait(0.05)

                local currentFolder = inv:FindFirstChild(stickyPartName)
                if not currentFolder then break end

                local currentStickyPart = currentFolder:FindFirstChild("StickyPart")
                if not currentStickyPart then break end

                stickyWeld = currentStickyPart:FindFirstChild("StickyWeld")
                if not stickyWeld or stickyWeld.Part1 ~= ragdollHitbox then
                    break
                end
            end
        end

        if not AntiKickT or AntiGrabTP_Active then
            if stickyPartFolder and stickyPartFolder.Parent then
                pcall(function()
                    DestroyToy:FireServer(stickyPartFolder)
                end)
            end
            break
        end
    end

    if not AntiKickT then
        local shurikenFolder = inv:FindFirstChild("NinjaShuriken")
        if shurikenFolder then
            pcall(function()
                DestroyToy:FireServer(shurikenFolder)
            end)
        end
    end
end

plr.CharacterAdded:Connect(function(newChar)
    newChar:WaitForChild("Humanoid")
    newChar:WaitForChild("HumanoidRootPart")
    task.wait(0.2)
    if AntiKickT and not AntiGrabTP_Active then
        AntiKickF()
    end
end)

Plots = workspace:WaitForChild("Plots")
function BarrierCanCollideF()
    if BarrierCanCollideT then
        for i = 1, 5 do
            local plot = Plots:FindFirstChild("Plot"..i)
            if plot and plot:FindFirstChild("Barrier") then
                for _, barrier in ipairs(plot.Barrier:GetChildren()) do
                    if barrier:IsA("BasePart") then
                        barrier.CanCollide = false
                    end
                end
            end
        end
    else
        for i = 1, 5 do
            local plot = Plots:FindFirstChild("Plot"..i)
            if plot and plot:FindFirstChild("Barrier") then
                for _, barrier in ipairs(plot.Barrier:GetChildren()) do
                    if barrier:IsA("BasePart") then
                        barrier.CanCollide = true
                    end
                end
            end
        end
    end
end

function AntiExplosionF()
    if AntiExplosionC then
        AntiExplosionC:Disconnect()
        AntiExplosionC = nil
    end
    if AntiExplosionH then
        AntiExplosionH:Disconnect()
        AntiExplosionH = nil
    end

    if not AntiExplosionT then 
        return 
    end

    local char = plr.Character
    if not char then 
        return 
    end

    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")

    AntiExplosionC = workspace.ChildAdded:Connect(function(model)
        if not char or not hrp or not hum then
            return
        end
        
        if model:IsA("BasePart") and (model.Position - hrp.Position).Magnitude <= 20 then
            if hum.SeatPart ~= nil then
                hrp.Anchored = true
                task.wait(0.03)
                hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                hrp.Anchored = false
            else
            if model:IsA("BasePart") and (model.Position - hrp.Position).Magnitude <= 20 then
                hrp.Anchored = true
                task.wait()
                hum:ChangeState(Enum.HumanoidStateType.Running)
                hrp.Anchored = false
                hum.AutoRotate = true

                for _, limb in ipairs(char:GetDescendants()) do
                    if limb:IsA("BasePart") and limb.Name == "RagdollLimbPart" then
                        limb.CanCollide = false
                        end
                    end
                end
            end
        end
    end)
end

plr.CharacterAdded:Connect(function(char)
    char:WaitForChild("Humanoid")
    char:WaitForChild("HumanoidRootPart")
    task.wait(0.2)
    if AntiExplosionT then
        AntiExplosionF()
    end
end)

function AutoAttackF()
    task.spawn(function()
        local RunService = game:GetService("RunService")
        local savedTargets = {}
        local invName = plr.Name.."SpawnedInToys"
        
        while AutoAttackT do
            RunService.Heartbeat:Wait()

            for i = #savedTargets, 1, -1 do
                local t = savedTargets[i]
                local char = t and t.Character
                local hum = char and char:FindFirstChildOfClass("Humanoid")
                if not (t and char and hum and hum.Health > 0) or t == plr then
                    table.remove(savedTargets, i)
                end
            end

            local myChar = plr.Character
            local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
            local myAttach = myHRP and myHRP:FindFirstChild("RootAttachment")

            if not (myChar and myHRP and myAttach) then
                continue
            end

            local function tryAddTarget(player)
                if player and player ~= plr and player.Character then
                    local exists = false
                    for _, v in ipairs(savedTargets) do
                        if v == player then exists = true; break end
                    end
                    if not exists then
                        table.insert(savedTargets, player)
                    end
                end
            end

            local head = myChar:FindFirstChild("Head")
            if head then
                local ownerVal = head:FindFirstChild("PartOwner")
                if ownerVal and ownerVal:IsA("StringValue") and ownerVal.Value ~= "" then
                    local foundPlayer = game.Players:FindFirstChild(ownerVal.Value)
                    tryAddTarget(foundPlayer)
                end
            end

            local inv = workspace:FindFirstChild(invName)
            if inv then
                for _, blob in ipairs(inv:GetChildren()) do
                    if blob.Name == "CreatureBlobman" and blob:FindFirstChild("BlobmanSeatAndOwnerScript") then
                        for _, side in ipairs({"Left", "Right"}) do
                            local detector = blob:FindFirstChild(side.."Detector")
                            local weld = detector and detector:FindFirstChild(side.."Weld")
                            if weld and weld:IsA("AlignPosition") and weld.Attachment0 == myAttach then
                                local foundPlayer = game.Players:FindFirstChild(plr.Name) 
                                tryAddTarget(foundPlayer)
                            end
                        end
                    end
                end
            end

            for _, player in ipairs(game.Players:GetPlayers()) do
                if player ~= plr then
                    local invs = workspace:FindFirstChild(player.Name.."SpawnedInToys")
                    if invs then
                        for _, blob in ipairs(invs:GetChildren()) do
                            if blob.Name == "CreatureBlobman" and blob:FindFirstChild("BlobmanSeatAndOwnerScript") then
                                for _, side in ipairs({"Left", "Right"}) do
                                    local detector = blob:FindFirstChild(side.."Detector")
                                    local weld = detector and detector:FindFirstChild(side.."Weld")
                                    if weld and weld:IsA("AlignPosition") and weld.Attachment0 == myAttach then
                                        tryAddTarget(player)
                                    end
                                end
                            end
                        end
                    end
                end
            end

            local plots = workspace:FindFirstChild("PlotItems")
            if plots then
                for i = 1, 5 do
                    local plot = plots:FindFirstChild("Plot"..i)
                    if plot then
                        for _, blob in ipairs(plot:GetChildren()) do
                            if blob.Name == "CreatureBlobman" and blob:FindFirstChild("BlobmanSeatAndOwnerScript") then
                                for _, side in ipairs({"Left", "Right"}) do
                                    local detector = blob:FindFirstChild(side.."Detector")
                                    local weld = detector and detector:FindFirstChild(side.."Weld")
                                    if weld and weld:IsA("AlignPosition") and weld.Attachment0 == myAttach then
                                        local foundPlayer = game.Players:FindFirstChild("Plot "..i)
                                        tryAddTarget(foundPlayer)
                                    end
                                end
                            end
                        end
                    end
                end
            end

            for i = #savedTargets, 1, -1 do
                local target = savedTargets[i]

                if target == plr then 
                    table.remove(savedTargets, i)
                    continue 
                end

                local tChar = target.Character
                local hum = tChar and tChar:FindFirstChildOfClass("Humanoid")
                local torso = tChar and tChar:FindFirstChild("Torso")
                local head = tChar and tChar:FindFirstChild("Head")

                if not (hum and torso and head and hum.Health > 0) then
                    table.remove(savedTargets, i)
                    continue
                end

                local isWhitelisted = false
                if WhiteListMode and Whitelist and typeof(Whitelist) == "table" then
                    for _, allowed in ipairs(Whitelist) do
                        if allowed == target.Name then isWhitelisted = true; break end
                    end
                end
                if isWhitelisted then continue end

                local myTorso = myChar:FindFirstChild("Torso")
                if not myTorso then continue end

                local distance = (torso.Position - myTorso.Position).Magnitude
                if distance <= 30 then
                    rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))

                    if head then
                        local partOwner = head:FindFirstChild("PartOwner")
                        if partOwner and partOwner:IsA("StringValue") and partOwner.Value == plr.Name then
                            if hum.Health ~= 0 then
                                local FallenY = workspace.FallenPartsDestroyHeight
                                local targetY = (FallenY <= -50000 and -49999) or (FallenY <= -100 and -99) or -100
                                torso.CFrame = CFrame.new(99999, targetY, 99999)
                            end
                        end
                    end
                end
            end
        end
    end)
end

plr.CharacterAdded:Connect(function(char)
    char:WaitForChild("Humanoid")
    char:WaitForChild("HumanoidRootPart")
    task.wait(0.2)
    if AutoAttackT then
        AutoAttackF()
    end
end)

function RagdollWalk()
    task.spawn(function()
        local jointCoroutineRunning = false

        while RagdollWalkT do
            local char = plr.Character
            local hum = char and char:FindFirstChild("Humanoid")
            local torso = char and char:FindFirstChild("Torso")
            local leftArm = char and char:FindFirstChild("Left Arm")
            local leftLeg = char and char:FindFirstChild("Left Leg")
            local rightLeg = char and char:FindFirstChild("Right Leg")
            local ragdoll = hum and hum:FindFirstChild("Ragdolled")
            local limb = leftArm and leftArm:FindFirstChild("RagdollLimbPart")

            if limb and limb:IsA("BasePart") and limb.CanCollide then
                hum.AutoRotate = true

                for _, leg in ipairs({leftLeg, rightLeg}) do
                    local part = leg and leg:FindFirstChild("RagdollLimbPart")
                    if part then part.CanCollide = false end
                end

                if ragdoll then ragdoll.Value = false end

                if not jointCoroutineRunning then
                    jointCoroutineRunning = true
                    coroutine.wrap(function()
                        while RagdollWalkT and limb.CanCollide do
                            for _, jointName in ipairs({"Left Hip", "Left Shoulder", "Neck", "Right Hip", "Right Shoulder"}) do
                                local joint = torso and torso:FindFirstChild(jointName)
                                if joint then joint.Enabled = false end
                            end
                            task.wait(0.05)
                            for _, jointName in ipairs({"Left Hip", "Left Shoulder", "Neck", "Right Hip", "Right Shoulder"}) do
                                local joint = torso and torso:FindFirstChild(jointName)
                                if joint then joint.Enabled = true end
                            end
                            task.wait(0.05)
                        end
                        jointCoroutineRunning = false
                    end)()
                end
            end

            task.wait(0.001)
        end
    end)
end

plr.CharacterAdded:Connect(function()
    task.wait(0.2)
    if RagdollWalkT then
        RagdollWalk()
    end
end)

function flyF()
    if not flyT then return end
    
    local Players = game:GetService("Players")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")

    local plr = Players.LocalPlayer
    local char = plr.Character or plr.CharacterAdded:Wait()
    local humanoid = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart")

    local BV = Instance.new("BodyVelocity")
    local BG = Instance.new("BodyGyro")

    BG.P = 9e4
    BG.Parent = hrp
    BV.Parent = hrp
    BG.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    BG.CFrame = hrp.CFrame
    BV.Velocity = Vector3.new(0,0,0)
    BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)

    local CONTROL = {F=0,B=0,L=0,R=0}
    local lCONTROL = {F=0,B=0,L=0,R=0}
    local SPEED = flyV

    if flyKeyDown then flyKeyDown:Disconnect() end
    if flyKeyUp then flyKeyUp:Disconnect() end
    if flyConnection then flyConnection:Disconnect() end

    flyKeyDown = UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.KeyCode == Enum.KeyCode.W then
            CONTROL.F = 1
        elseif input.KeyCode == Enum.KeyCode.S then
            CONTROL.B = -1
        elseif input.KeyCode == Enum.KeyCode.A then
            CONTROL.L = -1
        elseif input.KeyCode == Enum.KeyCode.D then
            CONTROL.R = 1
        end
    end)

    flyKeyUp = UserInputService.InputEnded:Connect(function(input, processed)
        if input.KeyCode == Enum.KeyCode.W then
            CONTROL.F = 0
        elseif input.KeyCode == Enum.KeyCode.S then
            CONTROL.B = 0
        elseif input.KeyCode == Enum.KeyCode.A then
            CONTROL.L = 0
        elseif input.KeyCode == Enum.KeyCode.D then
            CONTROL.R = 0
        end
    end)

    flyConnection = RunService.Heartbeat:Connect(function()
        if not flyT then
            flyConnection:Disconnect()
            if flyKeyDown then flyKeyDown:Disconnect() end
            if flyKeyUp then flyKeyUp:Disconnect() end
            BV:Destroy()
            BG:Destroy()
            humanoid.PlatformStand = false
            return
        end
        
        local camera = workspace.CurrentCamera
        SPEED = flyV
        
        if CONTROL.F + CONTROL.B ~= 0 or CONTROL.L + CONTROL.R ~= 0 then
            BV.Velocity = ((camera.CFrame.LookVector * (CONTROL.F + CONTROL.B)) + 
                ((camera.CFrame * CFrame.new(CONTROL.L + CONTROL.R, 0, 0).p) - camera.CFrame.p)) * SPEED
            lCONTROL = {F=CONTROL.F,B=CONTROL.B,L=CONTROL.L,R=CONTROL.R}
        else
            BV.Velocity = Vector3.new(0,0,0)
        end
        BG.CFrame = camera.CFrame
    end)
end

plr.CharacterAdded:Connect(function()
    task.wait(0.2)
    if flyT then
        flyF()
    end
end)

function AntiStruggleGrabF()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local SetNetworkOwner = ReplicatedStorage.GrabEvents.SetNetworkOwner
    local DestroyGrabLine = ReplicatedStorage.GrabEvents.DestroyGrabLine
    local CreateGrabLine = ReplicatedStorage.GrabEvents.CreateGrabLine
    local Players = game:GetService("Players")

    if not AntiStruggleGrabT then return end

    task.spawn(function()
        while AntiStruggleGrabT do
            local grabParts = workspace:FindFirstChild("GrabParts")
            if not grabParts then
                task.wait()
                continue
            end

            local gp = grabParts:FindFirstChild("GrabPart")
            local weld = gp and gp:FindFirstChildOfClass("WeldConstraint")
            local part1 = weld and weld.Part1

            if part1 then
                local ownerPlayer = nil
                for _, pl in ipairs(Players:GetPlayers()) do
                    if pl.Character and part1:IsDescendantOf(pl.Character) then
                        ownerPlayer = pl
                        break
                    end
                end

                while AntiStruggleGrabT and workspace:FindFirstChild("GrabParts") do
                    if ownerPlayer then
                        local tgtTorso = ownerPlayer.Character:FindFirstChild("HumanoidRootPart") 
                        local tgtHum = ownerPlayer.Character:FindFirstChild("Humanoid")
                        local tgtHead = ownerPlayer.Character:FindFirstChild("Head")
                        local myTorso = plr.Character:FindFirstChild("HumanoidRootPart") 

                        if tgtTorso and myTorso and tgtHead then
                            local ownerValue = tgtHead:FindFirstChild("PartOwner")
                            if tgtTorso then --not ownerValue or ownerValue.Value ~= plr.Name then
                                SetNetworkOwner:FireServer(tgtTorso, CFrame.lookAt(myTorso.Position, tgtTorso.Position))
                            end
                        end
                    else
                        if part1.Parent then
                            local myTorso = plr.Character:FindFirstChild("HumanoidRootPart")
                            if myTorso then
                                SetNetworkOwner:FireServer(part1, CFrame.lookAt(myTorso.Position, part1.Position))
                            end
                        end
                    end
                    task.wait()
                end
            end
            task.wait()
        end
    end)
end

TpKLG = false
function KillGrabF()
    while KillGrabT and task.wait() do
        local grabParts = workspace:FindFirstChild("GrabParts")
        if not grabParts then continue end

        for _, grabPart in ipairs(grabParts:GetChildren()) do
            if not KillGrabT then break end
            if grabPart.Name ~= "GrabPart" then continue end

            local weldConstraint = grabPart:FindFirstChildOfClass("WeldConstraint")
            if not weldConstraint or not weldConstraint.Part1 then continue end

            local target = weldConstraint.Part1
            if not target or not target.Parent then continue end

            local targetPlayer = game.Players:FindFirstChild(target.Parent.Name)
            if not targetPlayer then continue end

            local targetChar = targetPlayer.Character
            if not targetChar then continue end

            local THead = targetChar:FindFirstChild("Head")
            local THRP = targetChar:FindFirstChild("HumanoidRootPart")
            local THum = targetChar:FindFirstChildOfClass("Humanoid")

            if not THead or not THRP or not THum then continue end
            if THum.Health <= 0 then continue end

            local char = plr.Character
            if not char then continue end

            local myTorso = char:FindFirstChild("HumanoidRootPart")
            if not myTorso then continue end

            if (myTorso.Position - target.Position).Magnitude > 30 then continue end

            local partOwner = THead:FindFirstChild("PartOwner")

            if WhiteListMode then
                local isWhitelisted = false
                for _, whitelistedName in ipairs(Whitelist) do
                    if whitelistedName == targetPlayer.Name then
                        isWhitelisted = true
                        break
                    end
                end
                if isWhitelisted then continue end
            end

            if not partOwner or not partOwner:IsA("StringValue") or partOwner.Value ~= plr.Name then
                pcall(function()
                    game:GetService("ReplicatedStorage").GrabEvents.SetNetworkOwner:FireServer(THRP, CFrame.lookAt(myTorso.Position, THRP.Position))
                end)
                continue
            end

            game:GetService("ReplicatedStorage").GrabEvents.SetNetworkOwner:FireServer(THRP, CFrame.lookAt(myTorso.Position, THRP.Position))
            game:GetService("ReplicatedStorage").GrabEvents.DestroyGrabLine:FireServer(THRP)

            weldConstraint.Part0 = nil

            if THum.RigType ~= Enum.HumanoidRigType.R15 and THum.SeatPart == nil then THum.RigType = Enum.HumanoidRigType.R15 end
            if THum.BreakJointsOnDeath == true and THum.SeatPart == nil then THum.BreakJointsOnDeath = false end

            local FallenY = workspace.FallenPartsDestroyHeight
            local targetY = (FallenY <= -50000 and -49999.50) or (FallenY <= -100 and -99.50) or -100
            if TpKLG then THRP.CFrame = CFrame.new(9999, targetY, 9999) end
        end
    end
end

AnhKick = false
function KickGrabF()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    if not KickGrabT then return end

    local localPlayer = Players.LocalPlayer
    if not localPlayer or not localPlayer.Character then return end

    local connection
    connection = RunService.Heartbeat:Connect(function()
        if not KickGrabT then
            connection:Disconnect()
            return
        end

        local myCharacter = localPlayer.Character
        local myTorso = myCharacter:FindFirstChild("Torso") or myCharacter:FindFirstChild("HumanoidRootPart")
        if not myTorso then return end

        local grabParts = workspace:FindFirstChild("GrabParts")
        if not grabParts then return end

        for _, grabPart in ipairs(grabParts:GetChildren()) do
            if grabPart.Name == "GrabPart" then
                local weld = grabPart:FindFirstChildOfClass("WeldConstraint")
                if not weld then continue end

                local originalPart1 = weld.Part1
                if not originalPart1 then continue end

                local ownerPlayer
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= localPlayer and player.Character and originalPart1:IsDescendantOf(player.Character) then
                        ownerPlayer = player
                        break
                    end
                end

                if not ownerPlayer then continue end
                local tgtTorso = ownerPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not tgtTorso then continue end

                weld.Part1 = tgtTorso

                if AnhKick then
                    local tgtHum = ownerPlayer.Character:FindFirstChild("Humanoid")
                    if not tgtHum then continue end

                    if not tgtHum.Sit then ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(tgtTorso, CFrame.lookAt(myTorso.Position, tgtTorso.Position)) end
                    if tgtHum.Sit then ReplicatedStorage.GrabEvents.DestroyGrabLine:FireServer(tgtTorso) end
                    if ownerPlayer.IsHeld then ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(tgtTorso, CFrame.lookAt(myTorso.Position, tgtTorso.Position)) end
                    if tgtHum.Sit then ReplicatedStorage.GrabEvents.DestroyGrabLine:FireServer(tgtTorso) end
                else
                    ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(tgtTorso, CFrame.lookAt(myTorso.Position, tgtTorso.Position))
                    ReplicatedStorage.GrabEvents.DestroyGrabLine:FireServer(tgtTorso)
                end
            end
        end
    end)
end

function MasslessGrabF()
    while MasslessGrabT and task.wait() do
        local grabParts = workspace:FindFirstChild("GrabParts")
        
        if grabParts then
            local dragParts = {grabParts:FindFirstChild("DragPart"), grabParts:FindFirstChild("DragPart1")}
            
            for _, dragPart in pairs(dragParts) do
                if dragPart then
                    local alignOrientation = dragPart:FindFirstChildOfClass("AlignOrientation")
                    if alignOrientation then
                        alignOrientation.MaxAngularVelocity = math.huge
                        alignOrientation.MaxTorque = math.huge
                        alignOrientation.Responsiveness = 200
                    end
                    
                    local alignPosition = dragPart:FindFirstChildOfClass("AlignPosition")
                    if alignPosition then
                        alignPosition.MaxAxesForce = Vector3.new(math.huge, math.huge, math.huge)
                        alignPosition.MaxForce = math.huge
                        alignPosition.MaxVelocity = math.huge
                        alignPosition.Responsiveness = 200
                    end
                end
            end
        end
    end
end

function NoClipGrabF()
    local trackedTargets = {}
    local playerCheckCooldown = 0
    
    local function findAllParts(object, partsList)
        if object:IsA("BasePart") then
            partsList[object] = object.CanCollide
        end
        
        for _, child in ipairs(object:GetChildren()) do
            findAllParts(child, partsList)
        end
    end
    
    local function setPartsCollision(partsList, enable)
        for part, originalValue in pairs(partsList) do
            if part and part.Parent then
                if enable then
                    part.CanCollide = originalValue
                else
                    part.CanCollide = false
                end
            end
        end
    end
    
    while NoClipGrabT and task.wait() do
        local grabParts = workspace:FindFirstChild("GrabParts")
        
        if grabParts then
            local currentTargets = {}
            
            for _, grabPart in ipairs(grabParts:GetChildren()) do
                if grabPart.Name == "GrabPart" then
                    local weldConstraint = grabPart:FindFirstChildOfClass("WeldConstraint")
                    
                    if weldConstraint and weldConstraint.Part1 then
                        local target = weldConstraint.Part1
                        currentTargets[target] = true
                        
                        if not trackedTargets[target] then
                            local partsToDisable = {}
                            local isPlayer = false
                            
                            if target.Parent then
                                findAllParts(target.Parent, partsToDisable)
                                local humanoid = target.Parent:FindFirstChildOfClass("Humanoid")
                                if humanoid then
                                    isPlayer = true
                                end
                            else
                                if target:IsA("BasePart") then
                                    partsToDisable[target] = target.CanCollide
                                end
                            end
                            
                            setPartsCollision(partsToDisable, false)
                            
                            local connection
                            connection = weldConstraint.Destroying:Connect(function()
                                setPartsCollision(partsToDisable, true)
                                trackedTargets[target] = nil
                                if connection then
                                    connection:Disconnect()
                                end
                            end)
                            
                            trackedTargets[target] = {
                                target = target,
                                connection = connection,
                                partsToDisable = partsToDisable,
                                isPlayer = isPlayer,
                                lastPlayerCheck = os.clock()
                            }
                        else
                            trackedTargets[target].lastPlayerCheck = os.clock()
                        end
                    end
                end
            end
            
            playerCheckCooldown = playerCheckCooldown + task.wait()
            if playerCheckCooldown >= 0.01 then
                playerCheckCooldown = 0
                
                for target, data in pairs(trackedTargets) do
                    if data.isPlayer then
                        local newParts = {}
                        findAllParts(target.Parent, newParts)
                        
                        for part, originalValue in pairs(newParts) do
                            if not data.partsToDisable[part] then
                                data.partsToDisable[part] = originalValue
                            end
                            if part.CanCollide then
                                part.CanCollide = false
                            end
                        end
                    end
                end
            end
            
            for target, data in pairs(trackedTargets) do
                if not currentTargets[target] then
                    setPartsCollision(data.partsToDisable, true)
                    
                    if data.connection then
                        data.connection:Disconnect()
                    end
                    trackedTargets[target] = nil
                end
            end
        else
            for target, data in pairs(trackedTargets) do
                setPartsCollision(data.partsToDisable, true)
                
                if data.connection then
                    data.connection:Disconnect()
                end
            end
            trackedTargets = {}
        end
    end
    
    for target, data in pairs(trackedTargets) do
        setPartsCollision(data.partsToDisable, true)
        
        if data.connection then
            data.connection:Disconnect()
        end
    end
end

function ViewToolF()
    local Tools = {
        "NinjaKunai",
        "NinjaShuriken",
        "NinjaKatana",
        "ToolCleaver",
        "ToolDiggingForkRusty",
        "ToolPencil",
        "ToolPickaxe",
        "AG",
    }

    local Cpf = { "Campfire" }
    local AG = { "AG" }

    local function addView(item, partName, multiple, onlyView1, highTransparency)
        if onlyView1 then return end

        local function createHighlight(part, index)
            if not item:FindFirstChild("Highlight_" .. index) then
                local highlight = Instance.new("Highlight")
                highlight.Name = "Highlight_" .. index
                highlight.Adornee = item
                highlight.FillColor = Color3.fromRGB(255, 0, 0)
                highlight.FillTransparency = 1

                if item.Name == "Campfire" then
                    highlight.OutlineColor = Color3.fromRGB(105, 102, 92)
                elseif item.Name == "AG" then
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 0)
                else
                    highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
                end

                highlight.FillTransparency = 1
                highlight.OutlineTransparency = 0
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.Parent = item
            end
        end

        if multiple and partName then
            local count = 0
            for _, part in ipairs(item:GetDescendants()) do
                if part:IsA("BasePart") and part.Name == partName then
                    count += 1
                    createHighlight(part, count)
                end
            end
        elseif partName then
            local part = item:FindFirstChild(partName, true)
            if part and part:IsA("BasePart") then
                createHighlight(part, partName)
            end
        end
    end

    local function checkAndHighlightItem(item)
        if item:IsA("Model") then
            if table.find(Tools, item.Name) then
                addView(item, "StickyPart")
            elseif table.find(Cpf, item.Name) then
                addView(item, "FirePlayerPart")
            elseif table.find(AG, item.Name) then
                addView(item, nil, false, false)
            end
        end
    end

    task.spawn(function()
        while ViewToolT and task.wait(0.2) do
            for _, folder in ipairs(workspace:GetChildren()) do
                if folder:IsA("Folder") and folder.Name:match("SpawnedInToys$") then
                    for _, item in ipairs(folder:GetChildren()) do
                        checkAndHighlightItem(item)
                    end
                end
            end

            if workspace:FindFirstChild("PlotItems") then
                local plotItems = workspace.PlotItems
                for i = 1, 5 do
                    local plotName = "Plot" .. i
                    local plot = plotItems:FindFirstChild(plotName)
                    if plot then
                        for _, item in ipairs(plot:GetChildren()) do
                            checkAndHighlightItem(item)
                        end
                    end
                end
            end
        end

        for _, folder in ipairs(workspace:GetChildren()) do
            if folder:IsA("Folder") and folder.Name:match("SpawnedInToys$") then
                for _, item in ipairs(folder:GetChildren()) do
                    for _, v in ipairs(item:GetChildren()) do
                        if v.Name:match("^Highlight_") then
                            v:Destroy()
                        end
                    end
                end
            end
        end

        if workspace:FindFirstChild("PlotItems") then
            local plotItems = workspace.PlotItems
            for i = 1, 5 do
                local plotName = "Plot" .. i
                local plot = plotItems:FindFirstChild(plotName)
                if plot then
                    for _, item in ipairs(plot:GetChildren()) do
                        for _, v in ipairs(item:GetChildren()) do
                            if v.Name:match("^Highlight_") then
                                v:Destroy()
                            end
                        end
                    end
                end
            end
        end
    end)
end

function ViewAuraF()
    local targetNames = { 
        "NinjaKunai", "NinjaShuriken", "NinjaKatana", 
        "ToolCleaver", "ToolDiggingForkRusty", 
        "ToolPencil", "ToolPickaxe" 
    }

    task.spawn(function()
        while ViewAuraT and task.wait(0.03) do
            local character = plr.Character
            if not character then continue end

            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then continue end

            for _, folder in ipairs(workspace:GetChildren()) do
                if folder:IsA("Folder") and folder.Name:match("SpawnedInToys$") then
                    if folder.Name ~= (plr.Name .. "SpawnedInToys") then
                        for _, item in ipairs(folder:GetChildren()) do
                            if table.find(targetNames, item.Name) and item:FindFirstChild("StickyPart") then
                                local sticky = item.StickyPart

                                local basePart = item.PrimaryPart or sticky
                                local dist = (basePart.Position - hrp.Position).Magnitude

                                if dist <= 30 then -- and sticky:FindFirstChild("PartOwner").Value ~= plr.Name then
                                    pcall(function()
                                        rs.GrabEvents.SetNetworkOwner:FireServer(sticky, CFrame.lookAt(hrp.Position, sticky.Position))
                                    end)
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end

function AntiBananaAuraF()
    local targetNames = {"FoodBanana"}

    task.spawn(function()
        while AntiBananaAuraT and task.wait(0.1) do
            local character = plr.Character
            if not character then continue end
            
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then continue end

            for _, folder in ipairs(workspace:GetChildren()) do
                if folder:IsA("Folder") and folder.Name:match("SpawnedInToys$") then
                    if folder.Name ~= (plr.Name .. "SpawnedInToys") then
                        for _, item in ipairs(folder:GetChildren()) do
                            if table.find(targetNames, item.Name) and item:FindFirstChild("SoundPart") then
                                local Spart = item.SoundPart

                                local basePart = item.PrimaryPart or Spart
                                local PartOwner = item:FindFirstChild("PartOwner")
                                local dist = (basePart.Position - hrp.Position).Magnitude

                                if dist <= 30 and not PartOwner then
                                    pcall(function()
                                        rs.GrabEvents.SetNetworkOwner:FireServer(Spart, lookAt(hrp.Position, Spart.Position))
                                    end)
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end

function AntiBoxF()
    local targetNames = {"Boombox"}

    task.spawn(function()
        while AntiBoxT and task.wait(0.1) do
            local character = plr.Character
            if not character then continue end

            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then continue end

            for _, folder in ipairs(workspace:GetChildren()) do
                if folder:IsA("Folder") and folder.Name:match("SpawnedInToys$") then
                    if folder.Name ~= (plr.Name .. "SpawnedInToys") then
                        for _, item in ipairs(folder:GetChildren()) do
                            if table.find(targetNames, item.Name) and item:FindFirstChild("SoundPart") then
                                local Spart = item.Button

                                local basePart = item.PrimaryPart or Spart
                                local PartOwner = Spart:FindFirstChild("PartOwner")
                                local dist = (basePart.Position - hrp.Position).Magnitude

                                FallenY = workspace.FallenPartsDestroyHeight
                                targetY = (FallenY <= -50000 and -49999) or (FallenY <= -100 and -99) or -100

                                if dist <= 30 and not PartOwner then rs.GrabEvents.SetNetworkOwner:FireServer(Spart, CFrame.lookAt(hrp.Position, Spart.Position)) end
                                if PartOwner then Spart.CFrame = CFrame.new(0, targetY, 9999) end
                            end
                        end
                    end
                end
            end
        end
    end)
end

function AntiDeathF()
    local connection
    connection = rs2.Heartbeat:Connect(function()
        if not AntiDeathT then
            connection:Disconnect()
            return
        end

        local Character = plr.Character
        if not Character then return end

        local donut = inv:FindFirstChild("InstrumentPianoKeyboard")

        if not donut then
            pcall(function()
                rs.MenuToys.SpawnToyRemoteFunction:InvokeServer("InstrumentPianoKeyboard", CFrame.new(0,0,0), Vector3.new(0,0,0))
            end)
            return
        end

        if not donut:FindFirstChild("HoldPart") then return end

        local HoldItemRemoteFunction = donut.HoldPart:FindFirstChild("HoldItemRemoteFunction")
        local DropItemRemoteFunction = donut.HoldPart:FindFirstChild("DropItemRemoteFunction")

        if HoldItemRemoteFunction and DropItemRemoteFunction then
            HoldItemRemoteFunction:InvokeServer(donut, Character)
            DropItemRemoteFunction:InvokeServer(donut, CFrame.new(99999, 99999, 99999), Vector3.new(99999, 99999, 99999))
        end
    end)
end

RunService = game:GetService("RunService")
Camera = workspace.CurrentCamera

function AutoSitF()
    if currentConnection then
        currentConnection:Disconnect()
        currentConnection = nil
    end

    if not AutoSitT then return end

    currentConnection = RunService.Heartbeat:Connect(function()
        local char = plr.Character
        if not char or not char:FindFirstChild("Humanoid") or not char:FindFirstChild("HumanoidRootPart") then
            return
        end

        local hum = char.Humanoid
        local root = char.HumanoidRootPart

        if hum.SeatPart ~= nil and hum.Sit == true then
            return
        end

        if BLOBSIT then
            return
        end

        local allSeats = {}

        local myInv = workspace:FindFirstChild(plr.Name.."SpawnedInToys")
        if myInv then
            for _, item in pairs(myInv:GetChildren()) do
                if item.Name == "CreatureBlobman" then
                    local seat = item:FindFirstChild("VehicleSeat")
                    if seat then
                        table.insert(allSeats, {
                            seat = seat,
                            isMine = true,
                            occupant = seat.Occupant
                        })
                    end
                end
            end
        end

        for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
            if otherPlayer ~= plr then
                local otherInv = workspace:FindFirstChild(otherPlayer.Name.."SpawnedInToys")
                if otherInv then
                    for _, item in pairs(otherInv:GetChildren()) do
                        if item.Name == "CreatureBlobman" then
                            local seat = item:FindFirstChild("VehicleSeat")
                            if seat and seat.Occupant == nil then
                                table.insert(allSeats, {
                                    seat = seat,
                                    isMine = false,
                                    owner = otherPlayer,
                                    occupant = nil
                                })
                            end
                        end
                    end
                end
            end
        end

        local targetSeat = nil
        local seatType = nil

        for _, seatInfo in ipairs(allSeats) do
            if seatInfo.isMine and seatInfo.occupant == nil then
                targetSeat = seatInfo.seat
                seatType = "myEmpty"
                break
            end
        end

        if not targetSeat then
            for _, seatInfo in ipairs(allSeats) do
                if seatInfo.isMine and seatInfo.occupant ~= nil then
                    targetSeat = seatInfo.seat
                    seatType = "myOccupied"
                    break
                end
            end
        end

        if not targetSeat then
            for _, seatInfo in ipairs(allSeats) do
                if not seatInfo.isMine then
                    targetSeat = seatInfo.seat
                    seatType = "otherEmpty"
                    break
                end
            end
        end

        if not targetSeat then
            if #allSeats == 0 then
                task.spawn(function()
                    rs:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction"):InvokeServer(
                        "CreatureBlobman",
                        root.CFrame * CFrame.new(0, 0, 20),
                        Vector3.new(0, 0, 0)
                    )
                end)
            end
            return
        end

        local seat = targetSeat
        local dist = (root.Position - seat.Position).Magnitude
        local _, onScreen = Camera:WorldToViewportPoint(seat.Position)
        
        if dist > 20 then
            root.CFrame = CFrame.new(seat.Position + Vector3.new(0, 3, 0))
        elseif dist > 10 or not onScreen then
            if hum.Sit then 
                hum.Sit = false 
            end
            seat:Sit(hum)
        else
            local prompt = seat:FindFirstChild("ProximityPrompt")
            if prompt then
                if hum.Sit then hum.Sit = false end
                if hum then rs.CharacterEvents.Struggle:FireServer() end
                fireproximityprompt(prompt)
            else
                seat:Sit(hum)
            end
        end
    end)
end

function AntiBananaF()
    local dropPos = CFrame.new(0, -999999999, 0)
    local dropVec = Vector3.new(0, -999999999, 0)
    local plr = game.Players.LocalPlayer

    local targetItemsDict = {
        ["CupMugWhite"] = true, ["CupMugBrown"] = true, ["FoodBanana"] = true, 
        ["FoodBread"] = true, ["FoodBroccoli"] = true, ["FoodCakePink"] = true, 
        ["FoodCoconut"] = true, ["FoodDippyEgg"] = true, ["FoodDonut"] = true, 
        ["FoodFrenchFries"] = true, ["FoodHamburger"] = true, ["FoodHotdog"] = true, 
        ["FoodMayonnaise"] = true, ["FoodMeatStick"] = true, ["FoodMushroomPoison"] = true, 
        ["FoodPizzaCheese"] = true, ["FoodPizzaPepperoni"] = true, ["FoodSodaCan"] = true, 
        ["PoopPile"] = true, ["PoopPileSparkle"] = true, ["InstrumentBrassBugle"] = true, 
        ["InstrumentBrassTrumpet"] = true, ["InstrumentDrumBongos"] = true, 
        ["InstrumentDrumSnare"] = true, ["InstrumentGuitarAcoustic"] = true, 
        ["InstrumentGuitarBanjo"] = true, ["InstrumentGuitarLyre"] = true, 
        ["InstrumentGuitarUkulele"] = true, ["InstrumentGuitarViolin"] = true, 
        ["InstrumentPianoKeyboard"] = true, ["InstrumentPianoMelodica"] = true, 
        ["InstrumentVoiceMicrophone"] = true, ["InstrumentWoodwindOcarina"] = true, 
        ["InstrumentWoodwindSaxophone"] = true, ["InstrumentBrassVuvuzela"] = true
    }

    local processedItems = {} 

    local function GetMyPlotNumber()
        local plots = workspace:FindFirstChild("Plots")
        if not plots then return nil end

        for i = 1, 5 do
            local plot = plots:FindFirstChild("Plot" .. i)
            if plot then
                local plotSign = plot:FindFirstChild("PlotSign")
                if plotSign then
                    local owners = plotSign:FindFirstChild("ThisPlotsOwners")
                    if owners then
                        local ownerVal = owners:FindFirstChildOfClass("StringValue")
                        if ownerVal and ownerVal.Value == plr.Name then
                            return i
                        end
                    end
                end
            end
        end
        return nil
    end

    local function ProcessItem(item)
        if not item or not item.Parent then return end
        if processedItems[item] then return end

        local holdPart = item:FindFirstChild("HoldPart")
        if not holdPart then return end

        local holdRemote = holdPart:FindFirstChild("HoldItemRemoteFunction")
        local dropRemote = holdPart:FindFirstChild("DropItemRemoteFunction")

        if holdRemote and dropRemote then
            processedItems[item] = true

            task.spawn(function()
                local char = plr.Character
                if not char then 
                    processedItems[item] = nil 
                    return 
                end

                local success, err = pcall(function()
                    holdRemote:InvokeServer(item, char)
                    dropRemote:InvokeServer(item, dropPos, dropVec)
                end)

                if not success or item.Parent then
                    task.wait(1)
                    if item.Parent then
                        processedItems[item] = nil
                    end
                end
            end)
        end
    end

    while AntiBananaT do
        task.wait()

        local char = plr.Character
        if not char or not char.Parent then continue end

        local myPlotNumber = GetMyPlotNumber()
        local itemsToProcess = {}

        for _, player in ipairs(game.Players:GetPlayers()) do
            if player == plr then continue end

            if WhiteListMode then
                local isWhitelisted = false
                for _, whiteName in ipairs(Whitelist) do
                    if player.Name == whiteName then
                        isWhitelisted = true
                        break
                    end
                end
                if isWhitelisted then continue end
            end

            local folder = workspace:FindFirstChild(player.Name .. "SpawnedInToys")
            if folder then
                for _, item in ipairs(folder:GetChildren()) do
                    if targetItemsDict[item.Name] then
                        table.insert(itemsToProcess, item)
                    end
                end
            end
        end

        local plotItems = workspace:FindFirstChild("PlotItems")
        if plotItems then
            for i = 1, 5 do
                if i == myPlotNumber then continue end
                local plot = plotItems:FindFirstChild("Plot" .. i)
                if plot then
                    for _, item in ipairs(plot:GetChildren()) do
                        if targetItemsDict[item.Name] then
                            table.insert(itemsToProcess, item)
                        end
                    end
                end
            end
        end

        for _, item in ipairs(itemsToProcess) do
            if not AntiBananaT then break end
            ProcessItem(item)
        end

        for item, _ in pairs(processedItems) do
            if not item.Parent then
                processedItems[item] = nil
            end
        end
    end
end

ifKickThenT = true
local anchoredCache = {}

function ifKickThenF()
    Players.PlayerAdded:Connect(function(plr)
        plr.CharacterAdded:Connect(function(char)
            local hrp = char:WaitForChild("HumanoidRootPart", 1)
            if hrp then
                anchoredCache[plr] = false
            end
        end)
    end)

    Players.PlayerRemoving:Connect(function(plr)
        if anchoredCache[plr] == true then
            local DISP = plr.DisplayName
            local NAP = plr.Name
            Rayfield:Notify({
                Title = "[ Kick ]", 
                Content = "[" .. DISP .. "] ( @" .. NAP ..  ")", 
                Duration = 7, 
                Image = 0
            })
        end
        anchoredCache[plr] = nil
    end)

    task.spawn(function()
        while ifKickThenT do
            for _, plr in ipairs(Players:GetPlayers()) do
                local char = plr.Character
                if char then
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        anchoredCache[plr] = hrp.Anchored == true
                    end
                end
            end
            task.wait()
        end
    end)
end
ifKickThenF()

local mouse = plr:GetMouse()
function tpF()
    local char = plr.Character
    if not char then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local hum = char:FindFirstChild("Humanoid")
    local ragdolled = hum:FindFirstChild("Ragdolled")

    local target = mouse.Target
    if not target then return end

    local currentCFrame = hrp.CFrame
    local currentRotation = CFrame.new(Vector3.zero, currentCFrame.LookVector)

    local parts = {"Head", "Torso", "Left Leg", "Right Leg", "Left Arm", "Right Arm"}
    for _, name in ipairs(parts) do
        local part = char:FindFirstChild(name)
        if part and part:IsA("BasePart") then
            part.Transparency = 0
        end
    end

    for _, obj in ipairs(char:GetChildren()) do
        if obj:IsA("Accessory") and obj.Name ~= "TypingKeyboardMyWorld" then
            for _, v in ipairs(obj:GetChildren()) do
                if v:IsA("BasePart") then
                    v.Transparency = 0
                end
            end
        end
    end

    local mouseHit = mouse.Hit
    local targetPos = mouseHit.Position + Vector3.new(0, 5, 0)
    local newCFrame = CFrame.new(targetPos) * currentRotation

    if ragdolled.Value == true then
        char:PivotTo(newCFrame)
    else
        hrp.CFrame = newCFrame
    end
end

function AntiBlobUseF()
    task.spawn(function()
        local FallenY = workspace.FallenPartsDestroyHeight
        local targetY = (FallenY <= -50000 and -49999) or (FallenY <= -100 and -99) or -100
        local dropPos = CFrame.new(0, targetY, 9999)
        local plr = game.Players.LocalPlayer
        local targetItems = {"CreatureBlobman", "TractorRed", "TractorOrange", "TractorGreen", "SantaSleigh"}

        local processedBlobs = {}
        local cleanupInterval = 2

        while AntiBlobUseT do
            task.wait(0.1)

            local char = plr.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")

            if not char or not root or not hum then continue end

            local myPlotNumber = nil
            local plots = workspace:FindFirstChild("Plots")
            if plots then
                for i = 1, 5 do
                    local plot = plots:FindFirstChild("Plot" .. i)
                    local plotSign = plot and plot:FindFirstChild("PlotSign")
                    local owners = plotSign and plotSign:FindFirstChild("ThisPlotsOwners")
                    local ownerVal = owners and owners:FindFirstChildOfClass("StringValue")
                    if ownerVal and ownerVal.Value == plr.Name then
                        myPlotNumber = i
                        break
                    end
                end
            end

            local function collectItemsFromFolder(folder)
                local items = {}
                for _, item in ipairs(folder:GetChildren()) do
                    if item:IsA("Model") and table.find(targetItems, item.Name) then
                        if item:FindFirstChild("VehicleSeat") then
                            local vs = item:FindFirstChildOfClass("VehicleSeat")
                            if vs and vs.Occupant then 
                                if vs.Occupant == hum then
                                    table.insert(items, item)
                                end
                                continue 
                            end

                            local itemId = tostring(item:GetDebugId())
                            if not processedBlobs[itemId] then
                                table.insert(items, item)
                            end
                        end
                    end
                end
                return items
            end

            local allItems = {}
            for _, player in ipairs(game.Players:GetPlayers()) do
                if player == plr then continue end
                if WhiteListMode then
                    local inWhitelist = false
                    for _, whiteName in ipairs(Whitelist) do 
                        if player.Name == whiteName then 
                            inWhitelist = true 
                            break 
                        end 
                    end
                    if inWhitelist then continue end
                end
                local folder = workspace:FindFirstChild(player.Name .. "SpawnedInToys")
                if folder then 
                    for _, item in ipairs(collectItemsFromFolder(folder)) do 
                        table.insert(allItems, item) 
                    end 
                end
            end

            local plotItems = workspace:FindFirstChild("PlotItems")
            if plotItems then
                for i = 1, 5 do
                    if i == myPlotNumber then continue end
                    local plot = plotItems:FindFirstChild("Plot" .. i)
                    if plot then 
                        for _, item in ipairs(collectItemsFromFolder(plot)) do 
                            table.insert(allItems, item) 
                        end 
                    end
                end
            end

            for _, item in ipairs(allItems) do
                if not AntiBlobUseT then break end

                local itemId = tostring(item:GetDebugId())

                if processedBlobs[itemId] then
                    continue
                end

                local char = plr.Character
                local root = char and char:FindFirstChild("HumanoidRootPart")
                local hum = char and char:FindFirstChildOfClass("Humanoid")

                if not char or not root or not hum then break end

                local vs = item:FindFirstChildOfClass("VehicleSeat")

                if vs then
                    if vs.Occupant and vs.Occupant ~= hum then 
                        continue 
                    end

                    root.Anchored = true
                    vs:Sit(hum)

                    if hum and vs then
                    task.wait(0.1)
                    hum:ChangeState(Enum.HumanoidStateType.Running)
                    task.wait()
                    if item.PrimaryPart then item:SetPrimaryPartCFrame(dropPos) end
                    root.Anchored = false

                        if root and vs then
                            local connection
                            connection = vs.AncestryChanged:Connect(function()
                                if not vs or not vs.Parent then
                                    if connection then
                                        connection:Disconnect()
                                    end
                                    processedBlobs[itemId] = true

                                    task.delay(cleanupInterval, function()
                                        processedBlobs[itemId] = nil
                                    end)
                                end
                            end)

                            task.delay(2, function()
                                if connection then
                                    connection:Disconnect()
                                end
                                processedBlobs[itemId] = true

                                task.delay(cleanupInterval, function()
                                    processedBlobs[itemId] = nil
                                end)
                            end)
                        end
                    end

                    task.wait(0.01)
                end

                break
            end
        end
    end)
end

local TARGET_INDEX = 1

local Remotes = {
    Spawn = rs:FindFirstChild("MenuToys"):FindFirstChild("SpawnToyRemoteFunction"),
    SetOwner = rs:FindFirstChild("GrabEvents"):FindFirstChild("SetNetworkOwner"),
    Extend = rs:FindFirstChild("GrabEvents"):FindFirstChild("ExtendGrabLine"),
    Explode = rs:FindFirstChild("BombEvents"):FindFirstChild("BombExplode")
}

function LoopSnowBallF()
    if SnowballLoopThread and coroutine.status(SnowballLoopThread) ~= "dead" then
        return
    end

    if not playersInLoop1V or type(playersInLoop1V) ~= "table" then
        playersInLoop1V = {}
    end

    SnowballLoopThread = coroutine.create(function()
        while LoopSnowBallT do
            task.wait(0.1)

            local myHrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if not myHrp then
                continue
            end

            local ball = inv:FindFirstChild("BallSnowball")
            if not ball then
                task.spawn(function()
                    Remotes.Spawn:InvokeServer("BallSnowball", myHrp.CFrame * CFrame.new(0, 10, 20), Vector3.new(0, 0, 0))
                end)
                task.wait(0.15)
                continue
            end

            if #playersInLoop1V == 0 then
                task.wait(0.1)
                continue
            end

            TARGET_INDEX = TARGET_INDEX > #playersInLoop1V and 1 or TARGET_INDEX
            local targetName = playersInLoop1V[TARGET_INDEX]
            local targetPlayer = game.Players:FindFirstChild(targetName)

            if not targetPlayer or targetPlayer == plr or not targetPlayer.Character then
                table.remove(playersInLoop1V, TARGET_INDEX)
                if TARGET_INDEX > #playersInLoop1V then
                    TARGET_INDEX = 1
                end
                continue
            end

            local targetHrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not targetHrp then
                table.remove(playersInLoop1V, TARGET_INDEX)
                if TARGET_INDEX > #playersInLoop1V then
                    TARGET_INDEX = 1
                end
                continue
            end

            TARGET_INDEX = TARGET_INDEX + 1
            if TARGET_INDEX > #playersInLoop1V then
                TARGET_INDEX = 1
            end

            local ballSPart = ball:FindFirstChild("SoundPart")
            if not ballSPart then
                task.wait(0.1)
                continue
            end

            Remotes.SetOwner:FireServer(ballSPart, ballSPart.CFrame)
            task.wait(0.05)
            ballSPart.CFrame = targetHrp.CFrame

            task.wait(0.05)
            Remotes.Explode:FireServer({
                Radius = 0, 
                Color = Color3.new(0, 0, 0), 
                TimeLength = 0, 
                Model = ball, 
                Type = "SnowPoof", 
                ExplodesByFire = false, 
                MaxForcePerStudSquared = 0, 
                Hitbox = ballSPart, 
                ImpactSpeed = 0, 
                ExplodesByPointy = false, 
                DestroysModel = true, 
                PositionPart = ballSPart
            }, Vector3.new(0, 0, 0))

            task.wait(0.15)
        end

        SnowballLoopThread = nil
    end)

    coroutine.resume(SnowballLoopThread)
end

espEnabled = false
espObjects = {}
connections = {}

function PlrEspF()
    espEnabled = not espEnabled

    if espEnabled then
        for player, esp in pairs(espObjects) do
            esp:Destroy()
        end
        espObjects = {}

        for _, conn in pairs(connections) do
            conn:Disconnect()
        end
        connections = {}

        local function updateESPVisibility(player, esp)
            if not esp or not esp.Parent then return end

            if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    esp.Enabled = true
                    esp.Adornee = player.Character.HumanoidRootPart
                    if esp:FindFirstChild("bg") then
                        esp.bg.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
                    end
                else
                    esp.Enabled = false
                end
            else
                esp.Enabled = false
            end
        end

        local heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function()
            for player, esp in pairs(espObjects) do
                updateESPVisibility(player, esp)
            end
        end)
        table.insert(connections, heartbeatConnection)

        local function createESPForPlayer(player)
            if player == plr then return end

            if espObjects[player] then
                espObjects[player]:Destroy()
            end

            local billboard = Instance.new("BillboardGui")
            billboard.Name = "ProfileESP"
            billboard.Size = UDim2.new(0, 170, 0, 55)
            billboard.StudsOffset = Vector3.new(0, 4, 0)
            billboard.AlwaysOnTop = true
            billboard.Enabled = false
            billboard.Parent = game:GetService("CoreGui")

            espObjects[player] = billboard

            local bg = Instance.new("Frame")
            bg.Name = "bg"
            bg.Size = UDim2.new(1, 0, 1, 0)
            bg.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
            bg.BackgroundTransparency = 0.7
            bg.Parent = billboard

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = bg

            local shadow = Instance.new("UIStroke")
            shadow.Color = Color3.fromRGB(0, 0, 0)
            shadow.Thickness = 2
            shadow.Transparency = 0.7
            shadow.Parent = bg

            local profile = Instance.new("ImageLabel")
            profile.Size = UDim2.new(0, 45, 0, 45)
            profile.Position = UDim2.new(0, 5, 0, 5)
            profile.BackgroundTransparency = 1
            profile.Parent = billboard

            local profileCorner = Instance.new("UICorner")
            profileCorner.CornerRadius = UDim.new(1, 0)
            profileCorner.Parent = profile

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(255, 255, 255)
            stroke.Thickness = 2
            stroke.Parent = profile

            spawn(function()
                local ok, img = pcall(function()
                    return game:GetService("Players"):GetUserThumbnailAsync(
                        player.UserId,
                        Enum.ThumbnailType.HeadShot,
                        Enum.ThumbnailSize.Size100x100
                    )
                end)
                profile.Image = ok and img or "rbxasset://textures/ui/GuiImagePlaceholder.png"
            end)

            local displayName = Instance.new("TextLabel")
            displayName.Size = UDim2.new(0, 115, 0, 22)
            displayName.Position = UDim2.new(0, 55, 0, 7)
            displayName.BackgroundTransparency = 1
            displayName.Text = "[ " .. (player.DisplayName or player.Name) .. " ]"
            displayName.TextColor3 = Color3.fromRGB(255, 50, 50)
            displayName.TextSize = 17
            displayName.Font = Enum.Font.GothamBold
            displayName.TextXAlignment = Enum.TextXAlignment.Left
            displayName.TextStrokeTransparency = 0.3
            displayName.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            displayName.Parent = billboard

            local userName = Instance.new("TextLabel")
            userName.Size = UDim2.new(0, 115, 0, 18)
            userName.Position = UDim2.new(0, 55, 0, 25)
            userName.BackgroundTransparency = 1
            userName.Text = "( @" .. player.Name .. " )"
            userName.TextColor3 = Color3.fromRGB(220, 220, 220)
            userName.TextSize = 15
            userName.Font = Enum.Font.Gotham
            userName.TextXAlignment = Enum.TextXAlignment.Left
            userName.TextStrokeTransparency = 0.4
            userName.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            userName.Parent = billboard

            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                billboard.Adornee = player.Character.HumanoidRootPart
                updateESPVisibility(player, billboard)
            end
        end

        for _, player in pairs(game:GetService("Players"):GetPlayers()) do
            if player ~= plr then
                createESPForPlayer(player)
            end
        end

        local newPlayerConnection = game:GetService("Players").PlayerAdded:Connect(function(newPlayer)
            wait(0.5)
            if espEnabled and newPlayer ~= plr then
                createESPForPlayer(newPlayer)
            end
        end)
        table.insert(connections, newPlayerConnection)

        local playerRemovingConnection = game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
            if espObjects[leavingPlayer] then
                espObjects[leavingPlayer]:Destroy()
                espObjects[leavingPlayer] = nil
            end
        end)
        table.insert(connections, playerRemovingConnection)

        for _, player in pairs(game:GetService("Players"):GetPlayers()) do
            if player ~= plr then
                local charAddedConnection = player.CharacterAdded:Connect(function()
                    wait(0.5)
                    if espEnabled and espObjects[player] then
                        local hrp = player.Character:WaitForChild("HumanoidRootPart", 2)
                        if hrp then
                            espObjects[player].Adornee = hrp
                        end
                    end
                end)
                table.insert(connections, charAddedConnection)

                local charRemovingConnection = player.CharacterRemoving:Connect(function()
                    if espEnabled and espObjects[player] then
                        espObjects[player].Enabled = false
                    end
                end)
                table.insert(connections, charRemovingConnection)
            end
        end

    else
        for player, esp in pairs(espObjects) do
            esp:Destroy()
        end
        espObjects = {}
        
        for _, conn in pairs(connections) do
            conn:Disconnect()
        end
        connections = {}
    end
end

function AntiPCLDF()
    targetValueName = "[ " .. plr.DisplayName .. " ] ( @" .. plr.Name .. " )"
        while AntiPCLDT do
            task.wait()
            if not hasDetectedFirstTime and AntiPCLDT then
                for _, item in ipairs(workspace:GetChildren()) do
                    if item.Name == "PlayerCharacterLocationDetector" then
                        for _, child in ipairs(item:GetChildren()) do
                            if child:IsA("BoolValue") and child.Name == targetValueName then
                                plr.Character.HumanoidRootPart.CFrame = CFrame.new(0,999999,0)
                                task.wait(0.1)
                                plr.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Dead)
                                hasDetectedFirstTime = true
                            end
                        end
                    end
                end
            else
                if AntiPCLDT and hasDetectedFirstTime and plr.Character.Humanoid.Died:Connect() then
                character = plr.Character or plr.CharacterAdded:Wait()
                CF = character:WaitForChild("Torso").CFrame
                char = plr.CharacterAdded:Wait()
                char:WaitForChild("Humanoid"):ChangeState(Enum.HumanoidStateType.Dead)
                char:WaitForChild("Torso").CFrame = CF
                task.wait(5)
				if not AntiPCLDT then hasDetectedFirstTime = false end
            end
        end
    end
end

function TrSw()
char = plr.Character
hrp = char.HumanoidRootPart
hum = char.Humanoid

hrp.CFrame = workspace.Map.AlwaysHereTweenedObjects.Train.Object.ObjectModel.Seat.CFrame
repeat task.wait() until hum.SeatPart ~= nil

if not inv:FindFirstChild("InstrumentGuitarLyre") then
task.spawn(function()
rs.MenuToys.SpawnToyRemoteFunction:InvokeServer("InstrumentGuitarLyre", CFrame.new(0,99999,0), Vector3.new(0,99999,0))
end)
end

HPT = inv:WaitForChild("InstrumentGuitarLyre"):WaitForChild("HoldPart"):WaitForChild("RigidConstraint")

repeat
task.wait()
if inv:FindFirstChild("InstrumentGuitarLyre") then
task.spawn(function()
inv:FindFirstChild("InstrumentGuitarLyre"):FindFirstChild("HoldPart"):FindFirstChild("HoldItemRemoteFunction"):InvokeServer(inv:FindFirstChild("InstrumentGuitarLyre"), char)
end)
end
until HPT.Attachment1 ~= nil

task.wait(0.7)

if inv:FindFirstChild("InstrumentGuitarLyre") then
rs.MenuToys.DestroyToy:FireServer(inv:FindFirstChild("InstrumentGuitarLyre"))
end
end

LineLagV = 50
function LineLagF()
for i, e in game.Players:GetPlayers() do
if table.find(Whitelist, e.Name) then return end
end

while wait(0.5) and LineLagT do
for a = 0, LineLagV do
for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
if player.Character.Torso ~= nil then
rs.GrabEvents.CreateGrabLine:FireServer(player.Character.Torso, player.Character.Torso.CFrame)
end
end
end
end
end

----------------------------------------------------------------------------------------- [ ì‹œìž‘ ì„¤ì • ]

local Window = Rayfield:CreateWindow({Name = "Ftap | Np", Icon = 0, Theme = NP, ToggleUIKeybind = "T"})

local playerTab = Window:CreateTab("ë©”ì¸", 0)
local grabTab = Window:CreateTab("ê·¸ëž©", 0)
local antiTab = Window:CreateTab("ë³´ì•ˆ", 0)
local ListTab = Window:CreateTab("ë¦¬ìŠ¤íŠ¸", 0)
local LoopTab = Window:CreateTab("ì‹¤í–‰", 0)
local AuraTab = Window:CreateTab("ì•„ìš°ë¼", 0)
local funTab = Window:CreateTab("ê¸°íƒ€", 0)
local keybindTab = Window:CreateTab("ì„¤ì •", 0)
--local CreditsTab = Window:CreateTab("ì´ì™¸", 0)
local DevTab = Window:CreateTab("Dev", 0)

DevTab:CreateSection("Gamepass")
DevTab:CreateButton({
    Name = "UnLock | Farther Reach",
    Callback = function()

    local ReachNotify = rs.GamepassEvents.FurtherReachBoughtNotifier
    local LimitedTime = rs.MenuToys.LimitedTimeToyEvent

    local GrabScript = plr.Character:FindFirstChild("GrabbingScript")
    local grbaparts = workspace:FindFirstChild("GrabParts")
    local campart = plr.Character:FindFirstChild("CamPart")

    hookinstance(ReachNotify, LimitedTime)
    GrabScript.Enabled = false
    if grbaparts then grbaparts:Destroy() end
    if campart then campart:Destroy() end
    GrabScript.Enabled = true
    LimitedTime:FireServer()

    end
})

DevTab:CreateButton({
    Name = "UnLock | Multi Color",
    Callback = function()

    local ColorNotify = rs.GamepassEvents.MulticolorLineBoughtNotifier
    local LimitedTime = rs.MenuToys.LimitedTimeToyEvent

    local ColorPicking = plr.PlayerGui.MenuGui.Menu.TabContents.Settings.Contents.LineFrame.ColorPicking

    hookinstance(ColorNotify, LimitedTime)
    ColorPicking.Enabled = false
    ColorPicking.Enabled = true
    task.wait(0.1)
    LimitedTime:FireServer()

    end
})

DevTab:CreateSection("Gam")
DevTab:CreateToggle({
    Name = "Kick Notification",
    CurrentValue = true,
    Flag = "5",
    Callback = function(Value)
        ifKickThenT = Value
        if Value then
            ifKickThenF()
        end
    end
})

headMatrix = {0,0,0,0,0,0,0,1,0}
torsoMatrix = {0,0,0,0,0,0,0,1,0}
rightArmMatrix = {0,0,2,0,0,0,0,0,1}

DevTab:CreateSection("")
DevTab:CreateToggle({ 
    Name = "Look", 
    CurrentValue = false,
    Flag = "ToggleSpam",
    Callback = function(Value)
        isSpamming = Value

        if isSpamming then
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
            end

            heartbeatConnection = rs2.Heartbeat:Connect(function()
                rs.CharacterEvents.Look:FireServer(
                    CFrame.new(0, 0, 0, headMatrix[1], headMatrix[2], headMatrix[3], headMatrix[4], headMatrix[5], headMatrix[6], headMatrix[7], headMatrix[8], headMatrix[9]),
                    CFrame.new(0, 0, 0, torsoMatrix[1], torsoMatrix[2], torsoMatrix[3], torsoMatrix[4], torsoMatrix[5], torsoMatrix[6], torsoMatrix[7], torsoMatrix[8], torsoMatrix[9]),
                    CFrame.new(0, 0, 0, rightArmMatrix[1], rightArmMatrix[2], rightArmMatrix[3], rightArmMatrix[4], rightArmMatrix[5], rightArmMatrix[6], rightArmMatrix[7], rightArmMatrix[8], rightArmMatrix[9]),
                    "high"
                )
            end)
        else
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
                heartbeatConnection = nil
            end
--[[
            rs.CharacterEvents.Look:FireServer(
                CFrame.new(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                CFrame.new(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                CFrame.new(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                intensity
            )
]]--
        end
    end
})

local HR = DevTab:CreateInput({
    Name = "Head Rotation",
    CurrentValue = "0,0,0,0,0,0,0,1,0",
    PlaceholderText = "xx, xy, xz, yx, yy, yz, zx, zy, zz",
    RemoveTextAfterFocusLost = false,
    Flag = "HeadMatrix",
    Callback = function(Value)
        local numbers = {}
        for num in Value:gmatch("[^,]+") do
            table.insert(numbers, tonumber(num) or 0)
        end

        for i = 1, 9 do
            headMatrix[i] = numbers[i] or 0
        end
    end
})

local TR = DevTab:CreateInput({
    Name = "Torso Rotation",
    CurrentValue = "0,0,0,0,0,0,0,1,0",
    PlaceholderText = "xx, xy, xz, yx, yy, yz, zx, zy, zz",
    RemoveTextAfterFocusLost = false,
    Flag = "TorsoMatrix",
    Callback = function(Value)
        local numbers = {}
        for num in Value:gmatch("[^,]+") do
            table.insert(numbers, tonumber(num) or 0)
        end

        for i = 1, 9 do
            torsoMatrix[i] = numbers[i] or 0
        end
    end
})

local ARA = DevTab:CreateInput({
    Name = "Right Arm Rotation",
    CurrentValue = "0,0,2,0,0,0,0,0,1",
    PlaceholderText = "xx, xy, xz, yx, yy, yz, zx, zy, zz",
    RemoveTextAfterFocusLost = false,
    Flag = "ArmMatrix",
    Callback = function(Value)
        local numbers = {}
        for num in Value:gmatch("[^,]+") do
            table.insert(numbers, tonumber(num) or 0)
        end

        for i = 1, 9 do
            rightArmMatrix[i] = numbers[i] or 0
        end
    end
})

DevTab:CreateButton({
    Name = "Reset",
    Callback = function()

headMatrix = {0,0,0,0,0,0,0,1,0}
torsoMatrix = {0,0,0,0,0,0,0,1,0}
rightArmMatrix = {0,0,2,0,0,0,0,0,1}

HR:Set("0,0,0,0,0,0,0,1,0")
TR:Set("0,0,0,0,0,0,0,1,0")
ARA:Set("0,0,2,0,0,0,0,0,1")

    end
})

local TextChatService = game:GetService("TextChatService")
local RunService = game:GetService("RunService")

DevTab:CreateSection("Chat")
DevTab:CreateInput({
    Name = "Sound",
    CurrentValue = "",
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Flag = "SoundInput",
    Callback = function(Value)
        spamText = tostring(Value)
    end
})

DevTab:CreateInput({
    Name = "Speed",
    CurrentValue = "",
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Flag = "SpeedInput",
    Callback = function(Value)
        local num = tonumber(Value)
        if num and num > 0 then
            SpeedSpam = num
        else
            SpeedSpam = 0.1
        end
    end
})

DevTab:CreateToggle({ 
    Name = "Toggle", 
    CurrentValue = false,
    Flag = "SpamToggle",
    Callback = function(Value)
        spamming = Value

        if spamConnection then
            spamConnection:Disconnect()
            spamConnection = nil
        end

        if Value then
            local accumulator = 0

            spamConnection = RunService.Heartbeat:Connect(function(deltaTime)
                if not spamming then 
                    return 
                end

                accumulator = accumulator + deltaTime
                if accumulator >= SpeedSpam then
                    accumulator = 0

                    local success, errorMsg = pcall(function()
                        local message = "/e " .. (spamText)
                        TextChatService.TextChannels.RBXGeneral:SendAsync(message)
                    end)
                end
            end)
        end
    end
})

DevTab:CreateSection("Tweened Objects")
DevTab:CreateButton({
    Name = "Train SetOwner",
    Callback = TrSw
})

DevTab:CreateSection("OWNER")
local Loop1 = DevTab:CreateToggle({
    Name = "PTM",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        loopPlayerT3 = Value
        if loopPlayerT3 then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                local nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerF3()
        else
            loopPlayerT3 = false
            table.clear(playersInLoop2V)
        end
    end
})

DevTab:CreateButton({
    Name = "Kill [ Owner ]",
    Callback = function()
        table.clear(playersInLoop2V)
        for i, e in ipairs(playersInLoop1V) do
            local nameOnly = e:match("^(.-) %(") or e
            table.insert(playersInLoop2V, nameOnly)
        end
        
        UpdateCurrentBlobman()
        
        for _, name in ipairs(playersInLoop2V) do
            local player = game.Players:FindFirstChild(name)
            if player and not table.find(Whitelist, player.Name) then
                local character, hrp, head = safeGetCharacterParts(player)
                local humanoid = character and character:FindFirstChildOfClass("Humanoid")
                if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end
                
                if humanoid and humanoid.Health > 0 then
                    local myChar = plr.Character
                    local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
                    if not myHrp then continue end
                    local originCF = myHrp.CFrame
                    
                    TP(player)
                    task.wait(0.1)
                    
                    while true do
                        rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
                        local ownerTag = head:FindFirstChild("PartOwner")
                        if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                            break
                        end
                        task.wait()
                    end
                    
                    if humanoid.RigType ~= Enum.HumanoidRigType.R15 and humanoid.SeatPart == nil then humanoid.RigType = Enum.HumanoidRigType.R15 end

                    if humanoid.BreakJointsOnDeath == true and humanoid.SeatPart == nil then humanoid.BreakJointsOnDeath = false end

                    if head:FindFirstChildOfClass("BallSocketConstraint") then head.BallSocketConstraint.Attachment0 = nil end

                    local FallenY = workspace.FallenPartsDestroyHeight
                    local targetY = (FallenY <= -50000 and -49999) or (FallenY <= -100 and -99) or -100
                    local storso = character:FindFirstChild("Torso")
                    if storso then
                        storso.CFrame = CFrame.new(storso.Position.X, targetY, storso.Position.Z)
                    end
                    
                    if originCF then BACK(originCF) end
                end
                task.wait(0.1)
            end
        end
    end
})

DevTab:CreateButton({
    Name = "Fling [ Owner ]",
    Callback = function()
        table.clear(playersInLoop2V)
        for i, e in ipairs(playersInLoop1V) do
            local nameOnly = e:match("^(.-) %(") or e
            table.insert(playersInLoop2V, nameOnly)
        end
        
        UpdateCurrentBlobman()
        
        for _, name in ipairs(playersInLoop2V) do
            local player = game.Players:FindFirstChild(name)
            if player and not table.find(Whitelist, player.Name) then
                local character, hrp, head = safeGetCharacterParts(player)
                if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end
                
                local myChar = plr.Character
                local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
                if not myHrp then continue end
                local originCF = myHrp.CFrame
                
                local tpRunning = true
                task.spawn(function()
                    while tpRunning do
                        local ok, cf = TP(player)
                        if ok and cf then
                            CF = cf
                        end
                        task.wait()
                    end
                end)

                while true do
                    rs.GrabEvents.SetNetworkOwner:FireServer(hrp, hrp.CFrame)
                    local ownerTag = head:FindFirstChild("PartOwner")
                    if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                        break
                    end
                    task.wait()
                end

                tpRunning = false

                local targetNames = {
                    "NinjaKunai", "NinjaShuriken", "NinjaKatana",
                    "ToolCleaver", "ToolDiggingForkRusty",
                    "ToolPencil", "ToolPickaxe"
                }

                for _, child in ipairs(workspace:GetChildren()) do
                    if child:IsA("Folder") and child.Name:match("SpawnedInToys$") then
                        for _, item in ipairs(child:GetChildren()) do
                            if table.find(targetNames, item.Name) and item:FindFirstChild("StickyPart") then
                                local sticky = item.StickyPart
                                local weld = sticky:FindFirstChild("StickyWeld")
                                if weld and weld:IsA("WeldConstraint") and weld.Part1 then
                                    local targetParts = {
                                        character:FindFirstChild("Head"),
                                        character:FindFirstChild("Torso"),
                                        character:FindFirstChild("Left Arm"),
                                        character:FindFirstChild("Left Leg"),
                                        character:FindFirstChild("Right Arm"),
                                        character:FindFirstChild("Right Leg"),
                                        hrp:FindFirstChild("RagdollTouchedHitbox"),
                                        hrp:FindFirstChild("FirePlayerPart"),
                                    }
                                    for _, tPart in ipairs(targetParts) do
                                        if tPart and weld.Part1 == tPart then
                                            local basePart = item.PrimaryPart or sticky
                                            if basePart and (basePart.Position - hrp.Position).Magnitude <= 10 then
                                                rs.GrabEvents.SetNetworkOwner:FireServer(sticky, sticky.CFrame)
                                                sticky.CFrame = CFrame.new(0,9999,0)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end

                rs.GrabEvents.DestroyGrabLine:FireServer(head, head.CFrame)
                hrp.CFrame = CFrame.new(99999999, 99999999, 99999999)

                if originCF then
                    BACK(originCF)
                end
                task.wait(0.1)
            end
        end
    end
})

DevTab:CreateSection("BLOB")
DevTab:CreateToggle({
    Name = "Loop WD",
    CurrentValue = false,
    Flag = "5",
    Callback = function(Value)
        AntiStickyGBT = Value
        if Value then
            AntiStickyGBF()
        end
    end
})

local RRButton = DevTab:CreateButton({
    Name = "Release [ Blobman ]",
    Callback = function()
        table.clear(playersInLoop2V)
	for i, e in ipairs(playersInLoop1V) do
		local nameOnly = e:match("^(.-) %(") or e
		table.insert(playersInLoop2V, nameOnly)
	end
        BlobReleaseR()
    end
})

local LGButton = DevTab:CreateButton({
    Name = "Massless [ Blobman ]",
    Callback = function()
        table.clear(playersInLoop2V)
	for i, e in ipairs(playersInLoop1V) do
		local nameOnly = e:match("^(.-) %(") or e
		table.insert(playersInLoop2V, nameOnly)
	end
        BlobMasslessR()
    end
})

local RGButton = DevTab:CreateButton({
    Name = "Grab [ Blobman ]",
    Callback = function()
        table.clear(playersInLoop2V)
	for i, e in ipairs(playersInLoop1V) do
		local nameOnly = e:match("^(.-) %(") or e
		table.insert(playersInLoop2V, nameOnly)
	end
        BlobGrabR()
    end
})

local RDButton = DevTab:CreateButton({
    Name = "Drop [ Blobman ]",
    Callback = function()
        table.clear(playersInLoop2V)
	for i, e in ipairs(playersInLoop1V) do
		local nameOnly = e:match("^(.-) %(") or e
		table.insert(playersInLoop2V, nameOnly)
	end
        BlobDropR()
    end
})

grabTab:CreateSection("Fling")
local flingToggle = grabTab:CreateToggle({
    Name = "Fling",
    CurrentValue = false,
    Flag = "1",
    Callback = function(Value)
        flingT = Value
        flingF()
    end
})

local strengthInput = grabTab:CreateInput({
    Name = "Strength",
    CurrentValue = 0,
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Flag = "2",
    Callback = function(Value)
        strengthV = Value
    end
})
strengthInput:Set(9999)

grabTab:CreateSection("Line")
local extendLineToggle = grabTab:CreateToggle({
    Name = "Extend Line",
    CurrentValue = false,
    Flag = "3",
    Callback = function(Value)
        infLineExtendT = Value
        infLineExtendF()
    end
})

local extendLineInput = grabTab:CreateInput({
    Name = "Wheel Speed",
    CurrentValue = 0,
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Flag = "4",
    Callback = function(Value)
        increaseLineExtendV = Value
    end
})
extendLineInput:Set(1.7)

grabTab:CreateSection("Other")
local AntiStruggleGrab = grabTab:CreateToggle({
    Name = "Loop Grab",
    CurrentValue = false,
    Flag = "1",
    Callback = function(Value)
        AntiStruggleGrabT = Value
        if Value then
            AntiStruggleGrabF()
        end
    end
})

local RagdollGrabToggle = grabTab:CreateToggle({
    Name = "Ragdoll Grab",
    CurrentValue = false,
    Flag = "1",
    Callback = function(Value)
        RagdollGrabT = Value
        if Value then
            RagdollGrabF()
        end
    end
})

local MasslessGrab = grabTab:CreateToggle({ 
    Name = "Massless Grab", 
    CurrentValue = false,
    Flag = "1",
    Callback = function(Value)
        MasslessGrabT = Value
        if Value then
            MasslessGrabF()
        end
    end
})

local NoClipGrab = grabTab:CreateToggle({ 
    Name = "No-clip Grab", 
    CurrentValue = false,
    Flag = "1",
    Callback = function(Value)
        NoClipGrabT = Value
        if Value then
            NoClipGrabF()
        end
    end
})

grabTab:CreateToggle({ 
    Name = "Kill Grab", 
    CurrentValue = false,
    Flag = "1",
    Callback = function(Value)
        KillGrabT = Value
        KillGrabF()
    end
})

grabTab:CreateToggle({ 
    Name = "[ Void ]", 
    CurrentValue = false,
    Flag = "1",
    Callback = function(Value)
        TpKLG = Value
    end
})

grabTab:CreateSection("")
grabTab:CreateToggle({
    Name = "Kick Grab",
    CurrentValue = false,
    Flag = "1",
    Callback = function(Value)
        KickGrabT = Value
        if Value then KickGrabF() end
    end
})

grabTab:CreateToggle({
    Name = "[ Anchored ]",
    CurrentValue = false,
    Flag = "1",
    Callback = function(Value)
        AnhKick = Value
    end
})

-- =============== [ ë³´í˜¸ ëŒ€ìƒ ëª©ë¡ ] ==
local GF = {"1ove0_9"}

--[[
local Owner = {"TSB_01223", "TSB_V00V", "TSB_0VV0", "TSB_Z00Z", "TSB_0ZZ0", "Diwno2f", "Diwno2ff", "Diwno2fff", "TESTPLAYACCOUNT01", "TESTPLAYACCOUNT02", "Dhd9021el", "DM209jfda", "DJHaoidhw2dlk", "DJ029djoia", "D210ela"}

local Overseer = {"tnt300044_test3"}
local CoOwner = {"test_diro3", "Inferno_diro"}

local HeadAdmin = {"oOPPGl9", "0_HY1N"}
local Admin = {"KillLum_YT"}
local Mod = {"plmqazoknqsxihvedc", "jaeyoon4720", "Solo_ponyo"}
]]--

local Owner = {"TSB_01223", "TSB_V00V", "TSB_0VV0", "TSB_Z00Z", "TSB_0ZZ0", "Diwno2f", "Diwno2ff", "Diwno2fff", "TESTPLAYACCOUNT01", "TESTPLAYACCOUNT02", "Dhd9021el", "DM209jfda", "DJHaoidhw2dlk", "DJ029djoia", "D210ela", "iufsd2ee"}
local Overseer = {""}
local CoOwner = {""}
local HeadAdmin = {""}
local Admin = {""}
local Mod = {""}

local Ranks = {
    Owner = 7,
    GF = 6,
    Overseer = 5,
    CoOwner = 4,
    HeadAdmin = 3,
    Admin = 2,
    Mod = 1,
    User = 0
}
-- =============== ---------------- ==

local function Notify(type, playerName)
    playerName = playerName or ""
    local title = ""
    local content = ""

    if type == "Added" then
        title = "[â˜‘ï¸ ]"; content = playerName.." - ì¶”ê°€"
    elseif type == "Removed" then
        title = "[ â˜‘ï¸ ]"; content = playerName.." - ì œê±°"
    elseif type == "Self" then
        title = "[ âš ï¸ ]"; content = "ìžì‹ ì€ ì¶”ê°€ë  ìˆ˜ ì—†ì–´ìš”!"
    elseif type == "Already" then
        title = "[ ðŸ’  ]"; content = playerName.." - ì´ë¯¸ ì¶”ê°€ëì–´ìš”"
    elseif type == "NotFound" then
        title = "[ âŒ ]"; content = "ì°¾ì„ ìˆ˜ ì—†ì–´ìš”!"
    elseif type == "HigherRank" then
        title = "[ â›” ]"; content = "ê¶Œí•œì´ ë¶€ì¡±í•´ìš”!"
    elseif type == "GFE" then
        title = "[ â›” ]"; content = "ë‚˜ê°€ ë’¤ì ¸ ì—„ë§ˆ ìž¥ì• ì¸ ã…‹ã…‹ã…‹"
        GfLogger()
    end

    if Rayfield then
        Rayfield:Notify({Title = title, Content = content, Duration = 2})
    end
end

local function GetPlayerRank(playerName)
    if table.find(Owner, playerName) then return Ranks.Owner end
    if table.find(GF, playerName) then return Ranks.GF end
    if table.find(Overseer, playerName) then return Ranks.Overseer end
    if table.find(CoOwner, playerName) then return Ranks.CoOwner end
    if table.find(HeadAdmin, playerName) then return Ranks.HeadAdmin end
    if table.find(Admin, playerName) then return Ranks.Admin end
    if table.find(Mod, playerName) then return Ranks.Mod end
    return Ranks.User
end

local function findPlayer(Value)
    if not Value or Value == "" then return nil end
    Value = Value:lower()

    for _, p in ipairs(game.Players:GetPlayers()) do
        if p.Name:lower() == Value or (p.DisplayName and p.DisplayName:lower() == Value) then
            return p
        end
    end

    local matches = {}
    for _, p in ipairs(game.Players:GetPlayers()) do
        local playerNameLower = p.Name:lower()
        if playerNameLower:sub(1, #Value) == Value then
            table.insert(matches, p)
        elseif p.DisplayName then
            local displayNameLower = p.DisplayName:lower()
            if displayNameLower:sub(1, #Value) == Value then
                table.insert(matches, p)
            end
        end
    end

    if #matches == 0 then
        return nil
    elseif #matches == 1 then
        return matches[1]
    else
        return matches[1]
    end
end

local function checkPermissions(targetPlayer)
    local localPlayer = game.Players.LocalPlayer
    local myRank = GetPlayerRank(localPlayer.Name)
    local targetRank = GetPlayerRank(targetPlayer.Name)

    if targetPlayer == localPlayer then return false, "Self" end

    if myRank == Ranks.Owner then return true end

    if myRank == Ranks.Overseer and targetRank == Ranks.Owner then
        return true
    end

    if myRank == Ranks.CoOwner and targetRank == Ranks.Owner then
        return true
    end

    if targetRank == Ranks.User then
        return true
    end

    if targetRank == Ranks.GF then
        return false, "GFE"
    end

    if myRank > targetRank then
        return true
    else
        return false, "HigherRank"
    end
end

local function addToList(listTable, dropdown, inputValue, useRankCheck)
    local target = findPlayer(inputValue)
    if not target then Notify("NotFound"); return end

    if useRankCheck then
        local allowed, errorType = checkPermissions(target)
        if not allowed then Notify(errorType, target.Name); return end
    end

    if table.find(listTable, target.Name) then Notify("Already", target.Name); return end

    table.insert(listTable, target.Name)
    if dropdown then dropdown:Refresh(listTable, true) end
    Notify("Added", target.Name)
end

local function removeFromList(listTable, dropdown, inputValue, useRankCheck)
    local foundName, foundIndex = nil, nil
    inputValue = inputValue:lower()

    for i, name in ipairs(listTable) do
        if name:lower():find(inputValue, 1, true) then
            foundName = name; foundIndex = i; break
        end
    end

    if not foundName then Notify("NotFound"); return end

    if useRankCheck then
        local targetRank = GetPlayerRank(foundName)
        local localPlayer = game.Players.LocalPlayer
        local myRank = GetPlayerRank(localPlayer.Name)

        if foundName == localPlayer.Name then Notify("Self"); return end

        if myRank == Ranks.Owner then
        elseif targetRank == Ranks.User then
        elseif myRank <= targetRank then
            Notify("HigherRank", foundName); return
        end
    end

    table.remove(listTable, foundIndex)
    if dropdown then dropdown:Refresh(listTable, true) end
    Notify("Removed", foundName)
end

function Logger()
end

antiTab:CreateSection("Friendly | Toggle")
local WhiteListToggle = antiTab:CreateToggle({
    Name = "WhiteList Mode",
    CurrentValue = false,
    Flag = "5",
    Callback = function(Value)
        ForWhiteList(Value)
    end
})

if plr.UserId == 9078065998 then AddAll = true end

if AddAll then
SelectedList = nil
local AddAllList = ListTab:CreateDropdown({
    Name = "ì¶”ê°€",
    Options = {"ë¸”ë¡­", "ì˜¤ë„ˆ", "ëž˜ê·¸ëŒ"},
    CurrentOption = {"OPEN"},
    MultipleOptions = false,
    Flag = "Dropdown_AllList",
    Callback = function(Options)
        SelectedList = Options[1]
    end
})

ListTab:CreateButton({
    Name = "Add All",
    Callback = function()
        if SelectedList == "ë¸”ë¡­" then
            for _, plr in ipairs(Players:GetPlayers()) do
                addToList(playersInLoop1V, DropdownV1, plr.Name, true)
            end

        elseif SelectedList == "ì˜¤ë„ˆ" then
            for _, plr in ipairs(Players:GetPlayers()) do
                addToList(playersInLoop1V, DropdownV2, plr.Name, true)
            end

        elseif SelectedList == "ëž˜ê·¸ëŒ" then
            for _, plr in ipairs(Players:GetPlayers()) do
                addToList(playersInLoop1V, DropdownV3, plr.Name, true)
            end
        end
    end
})

ListTab:CreateButton({
    Name = "Remove All",
    Callback = function()
        if SelectedList == "ë¸”ë¡­" then
            for key in pairs(playersInLoop1V) do
                removeFromList(playersInLoop1V, DropdownV1, tostring(key))
            end

        elseif SelectedList == "ì˜¤ë„ˆ" then
            for key in pairs(playersInLoop1V) do
                removeFromList(playersInLoop1V, DropdownV2, tostring(key))
            end

        elseif SelectedList == "ëž˜ê·¸ëŒ" then
            for key in pairs(playersInLoop1V) do
                removeFromList(playersInLoop1V, DropdownV3, tostring(key))
            end
        end
    end
})
end

ListTab:CreateSection("White")
local Dropdown = ListTab:CreateDropdown({
    Name = "White List",
    Options = Whitelist,
    CurrentOption = {"OPEN"},
    MultipleOptions = true,
    Flag = "WhitelistDropdown",
    Callback = function(Options)
        Whitelist = Options
    end
})

ListTab:CreateInput({
    Name = "Add",
    PlaceholderText = "...",
    RemoveTextAfterFocusLost = true,
    Callback = function(Value)
        addToList(Whitelist, Dropdown, Value, false) 
    end
})

ListTab:CreateInput({
    Name = "Remove",
    PlaceholderText = "...",
    RemoveTextAfterFocusLost = true,
    Callback = function(Value)
        removeFromList(Whitelist, Dropdown, Value)
    end
})

ListTab:CreateSection("List")
local DropdownV1 = ListTab:CreateDropdown({
    Name = "Loop List",
    Options = playersInLoop1V,
    CurrentOption = {"OPEN"},
    MultipleOptions = true,
    Flag = "LoopBlobDropdown",
    Callback = function(Options)
        playersInLoop1V = Options
    end
})

ListTab:CreateInput({
    Name = "Add",
    PlaceholderText = "...",
    RemoveTextAfterFocusLost = true,
    Callback = function(Value)
        addToList(playersInLoop1V, DropdownV1, Value, true)
    end
})

ListTab:CreateInput({
    Name = "Remove",
    PlaceholderText = "...",
    RemoveTextAfterFocusLost = true,
    Callback = function(Value)
        removeFromList(playersInLoop1V, DropdownV1, Value)
    end
})

--[[
LoopTab:CreateSection("TP")
local HRPMODE = LoopTab:CreateToggle({
    Name = "HRP MODE TP",
    CurrentValue = true,
    Flag = "21",
    Callback = function(Value)
        HRPMOD = Value
    end
})
HRPMODE:Set(true)
]]--

LoopTab:CreateSection("Bring")
LoopTab:CreateButton({
    Name = "Bring [ Blobman ]",
    Callback = function()
        UpdateCurrentBlobman()
        local processedHumanoids = {}

        local function processPlayer(player)
            if not player then return false end

            local character, hrp, head = safeGetCharacterParts(player)
            if not hrp or not head then return false end

            local myChar = plr.Character
            local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if not myHrp then return false end
            local originCF = myHrp.CFrame

        TP(player)
        task.wait(0.25)
        BlobGrab(currentBlobS, hrp, "Right")
        BlobRelease(currentBlobS, hrp, "Right")

        task.wait(0.15)

        if originCF then
            hrp.CFrame = originCF * CFrame.new(0,5,0)
            myHrp.CFrame = originCF
        end

        task.wait(0.3)

        rs.GrabEvents.SetNetworkOwner:FireServer(hrp, hrp.CFrame)
        rs.GrabEvents.DestroyGrabLine:FireServer(hrp, hrp.CFrame)

            if originCF then BACK(originCF) end
            return true
        end

        table.clear(playersInLoop2V)
        for i, e in ipairs(playersInLoop1V) do
            local nameOnly = e:match("^(.-) %(") or e
            table.insert(playersInLoop2V, nameOnly)
        end

        for _, name in ipairs(playersInLoop2V) do
            local player = game.Players:FindFirstChild(name)
            if player and not table.find(Whitelist, player.Name) then
                local character = player.Character
                local humanoid = character and character:FindFirstChildOfClass("Humanoid")
                if PPs:FindFirstChild(name) then continue end

                if humanoid and humanoid.Health > 0 then
                    if processedHumanoids[player] ~= humanoid then
                        local success = processPlayer(player)
                        if success then
                            processedHumanoids[player] = humanoid
                        end
                    end
                else
                    processedHumanoids[player] = nil
                end
                task.wait()
            end
        end
    end
})

LoopTab:CreateButton({
    Name = "Bring [ Owner ]",
    Callback = function()
        UpdateCurrentBlobman()
        local processedHumanoids = {}
        local activeThreads = {}

        local function processPlayer(player)
            if not player then return false end

            local myChar = plr.Character
            local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
            local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
            if not myChar or not myHrp or not myHum or myHum.Health <= 0 then
                return false
            end

            local character, hrp, head = safeGetCharacterParts(player)
            if not hrp or not head then return false end

            local characterParts = {}

            table.insert(characterParts, hrp)

            if character:FindFirstChild("Head") then
                table.insert(characterParts, character.Head)
            end

            local torsoParts = {"Torso"}
            for _, partName in ipairs(torsoParts) do
                local part = character:FindFirstChild(partName)
                if part then
                    table.insert(characterParts, part)
                end
            end

            local armParts = {
                "Left Arm", "Right Arm"
            }
            for _, partName in ipairs(armParts) do
                local part = character:FindFirstChild(partName)
                if part then
                    table.insert(characterParts, part)
                end
            end

            local legParts = {
                "Left Leg", "Right Leg"
            }
            for _, partName in ipairs(legParts) do
                local part = character:FindFirstChild(partName)
                if part then
                    table.insert(characterParts, part)
                end
            end

            local originCF = myHrp.CFrame

            local tpRunning = true
            local tpThread = task.spawn(function()
                while tpRunning do
                    if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") or 
                       (plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").Health <= 0) then
                        break
                    end

                    local ok, cf = TP(player)
                    if ok and cf then
                        CF = cf
                    end
                    task.wait()
                end
            end)
            table.insert(activeThreads, tpThread)

            local success = false
            local startTime = tick()
            local timeout = 10

            while tpRunning and tick() - startTime < timeout do
                if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") or 
                   (plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").Health <= 0) then
                    break
                end

                if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") or 
                   (player.Character:FindFirstChildOfClass("Humanoid") and player.Character:FindFirstChildOfClass("Humanoid").Health <= 0) then
                    break
                end

                for _, part in ipairs(characterParts) do
                    if part and part.Parent then
                        rs.GrabEvents.SetNetworkOwner:FireServer(part, part.CFrame)
                    end
                end
                
                local ownerTag = head:FindFirstChild("PartOwner")
                if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                    success = true
                    break
                end
                task.wait()
            end

            tpRunning = false

            for _, thread in ipairs(activeThreads) do
                if coroutine.status(thread) ~= "dead" then
                    task.cancel(thread)
                end
            end
            table.clear(activeThreads)

            if originCF and myHrp and myHrp.Parent then
                myHrp.CFrame = originCF
                task.wait()
            end

            if success then
                for _, part in ipairs(characterParts) do
                    if part and part.Parent and myHrp and myHrp.Parent then
                        part.CFrame = myHrp.CFrame
                    end
                end
            end

            if originCF and myHrp and myHrp.Parent then 
                BACK(originCF) 
            end
            
            return success
        end

        table.clear(playersInLoop2V)
        for i, e in ipairs(playersInLoop1V) do
            local nameOnly = e:match("^(.-) %(") or e
            table.insert(playersInLoop2V, nameOnly)
        end

        for _, name in ipairs(playersInLoop2V) do
            local myChar = plr.Character
            local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
            if not myChar or not myHum or myHum.Health <= 0 then
                break
            end

            local player = game.Players:FindFirstChild(name)
            if player and not table.find(Whitelist, player.Name) then
                local character = player.Character
                local humanoid = character and character:FindFirstChildOfClass("Humanoid")
                if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end

                if humanoid and humanoid.Health > 0 then
                    if processedHumanoids[player] ~= humanoid then
                        local success = processPlayer(player)
                        if success then
                            processedHumanoids[player] = humanoid
                        end
                    end
                else
                    processedHumanoids[player] = nil
                end
                task.wait(0.003)
            end
        end
    end
})

LoopTab:CreateSection("Owner Kick")
local OLTPInput = LoopTab:CreateInput({
    Name = "X Y Z",
    CurrentValue = "0,20,0",
    PlaceholderText = "",
    RemoveTextAfterFocusLost = false,
    Flag = "",
    Callback = function(Value)
        local x, y, z = string.match(Value, "([%d.-]+),([%d.-]+),([%d.-]+)")
        if x and y and z then
            OLTPValue = Vector3.new(tonumber(x), tonumber(y), tonumber(z))
        else
        end
    end
})
OLTPInput:Set("0,20,0")

local blobLoop4Toggle = LoopTab:CreateToggle({
    Name = "Loop Owner Kick [ Auto ]",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        blobLoopT4 = Value
        if blobLoopT4 then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                local nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerBlobF4()
        else
            blobLoopT4 = false
            table.clear(playersInLoop2V)
        end
    end
})

LoopTab:CreateToggle({
    Name = "[ Anchored ]",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        SkipOL = Value
    end
})

LoopTab:CreateToggle({
    Name = "[ No DestroyGrabLine ]",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        OnlyOwner = Value
    end
})

LoopTab:CreateToggle({
    Name = "[ Original ]",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        OwnerKickMODED = Value
    end
})

LoopTab:CreateToggle({
    Name = "[ Sit ]",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        SitMODED = Value
    end
})

LoopTab:CreateSection("Blobman")
LoopTab:CreateButton({
    Name = "off massless",
    Callback = function()

        Players = game:GetService("Players")

        if #playersInLoop1V == 0 then return end

        local Tname = playersInLoop1V[1]
        local Tplr = Players:FindFirstChild(Tname)
        if not Tplr or not Tplr.Character then return end

        local Tchar = Tplr.Character
        local THRP = Tchar:FindFirstChild("HumanoidRootPart")
        if not THRP then return end

        if THRP.Massless then THRP.Massless = false end

    end
})

local blobLoopToggle = LoopTab:CreateToggle({
    Name = "Loop Kick [ Blobman ]",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        blobLoopT = Value
        if blobLoopT then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                local nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerBlobF()
        else
            blobLoopT = false
            table.clear(playersInLoop2V)

            for _, player in ipairs(game.Players:GetPlayers()) do
                if player.Character then
                    local head = player.Character:FindFirstChild("Head")
                    if head then
                        local kick = head:FindFirstChild("Kick")
                        if kick and kick:IsA("BodyPosition") then
                            kick:Destroy()
                        end
                    end
                end
            end
        end
    end
})

local blobLoop3Toggle = LoopTab:CreateToggle({
    Name = "Loop Kill [ Blobman ]",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        blobLoopT3 = Value
        if blobLoopT3 then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                local nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerBlobF3()
        else
            blobLoopT3 = false
            table.clear(playersInLoop2V)
        end
    end
})

local blobLoop2Toggle = LoopTab:CreateToggle({
    Name = "Loop Release Grab [ Blobman ]",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        blobLoopT2 = Value
        if blobLoopT2 then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                local nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerBlobF2()
        else
            blobLoopT2 = false
            table.clear(playersInLoop2V)
        end
    end
})

LoopTab:CreateToggle({
    Name = "[ Sit ]",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        LoopBringMODED = Value
    end
})

LoopTab:CreateToggle({
    Name = "[ Anti-InPlots Mode ]",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        LoopReleaseMODED = Value
    end
})

LoopTab:CreateSection("Owner")
local Loop1 = LoopTab:CreateToggle({
    Name = "Loop Kill [ Owner ]",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        loopPlayerT = Value
        if loopPlayerT then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                local nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerF()
        else
            loopPlayerT = false
            table.clear(playersInLoop2V)
        end
    end
})

local Loop2 = LoopTab:CreateToggle({
    Name = "Loop Kick [ Owner ]",
    CurrentValue = false,
    Flag = "21",
    Callback = function(Value)
        loopPlayerT2 = Value
        if loopPlayerT2 then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                local nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerF2()
        else
            loopPlayerT2 = false
            table.clear(playersInLoop2V)
        end
    end
})

LoopTab:CreateSection("Ragdoll")
LoopTab:CreateToggle({
    Name = "Explode [ SnowBall ]",
    CurrentValue = false,
    Flag = "27",
    Callback = function(Value)
        LoopSnowBallT = Value
        LoopSnowBallF()
    end
})

LoopTab:CreateButton({
    Name = "BlackHole [ NinjaKunai ]",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Players = game:GetService("Players")
        local plr = Players.LocalPlayer

        if #playersInLoop1V == 0 then
            return
        end

        local targetPlayerName = playersInLoop1V[1]
        local targetPlayer = Players:FindFirstChild(targetPlayerName)

        if not targetPlayer or not targetPlayer.Character then
            return
        end

        local targetCharacter = targetPlayer.Character
        local targetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")

        if not targetHRP then
            return
        end

        local ragdollHitbox = targetHRP:FindFirstChild("RagdollTouchedHitbox")
        if not ragdollHitbox then
            ragdollHitbox = targetHRP
            for _, child in ipairs(targetHRP:GetChildren()) do
                if child.Name:find("Hitbox") or child.Name:find("Attachment") or child:IsA("Attachment") then
                    ragdollHitbox = child
                    break
                end
            end
        end

        local character = plr.Character or plr.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")
        local torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")

        if not torso then
            return
        end

        local StickyPartEvent = ReplicatedStorage:WaitForChild("PlayerEvents"):WaitForChild("StickyPartEvent")
        local SpawnToy = ReplicatedStorage:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction")

        function GetPlotNumber()
            local char = plr.Character
            if not char then return nil end

            if char.Parent == workspace then 
                return nil
            elseif char.Parent.Name == "PlayersInPlots" then
                for _, plot in workspace.Plots:GetChildren() do
                    local plotSign = plot:FindFirstChild("PlotSign")
                    if plotSign and plotSign:FindFirstChild("ThisPlotsOwners") then
                        for _, owner in plotSign.ThisPlotsOwners:GetChildren() do
                            if owner.Value == plr.Name then
                                if plot.Name == "Plot1" then
                                    return 1
                                elseif plot.Name == "Plot2" then
                                    return 2
                                elseif plot.Name == "Plot3" then
                                    return 3
                                elseif plot.Name == "Plot4" then
                                    return 4
                                elseif plot.Name == "Plot5" then
                                    return 5
                                end
                            end
                        end
                    end
                end
            end
            return nil
        end

        function GetInventory()
            local plotNumber = GetPlotNumber()

            if plotNumber then
                local plotItems = workspace:FindFirstChild("PlotItems")
                if plotItems then
                    local plotFolder = plotItems:FindFirstChild("Plot" .. plotNumber)
                    if plotFolder then
                        return plotFolder
                    end
                end
            end
            
            local defaultInv = workspace:FindFirstChild(plr.Name .. "SpawnedInToys")
            if defaultInv then
                return defaultInv
            end
            
            return nil
        end

        function createAndAttachKunai()
            while not plr.CanSpawnToy.Value do 
                task.wait(0.1) 
            end

            local position = hrp.CFrame

            local success, result = pcall(function()
                return task.spawn(function()
                    return SpawnToy:InvokeServer("NinjaKunai", hrp.CFrame * CFrame.new(0, 5, 15), Vector3.new(0, 0, 0))
                end)
            end)
            
            if not success then
                return nil
            end

            task.wait(0.2)

            local inv = GetInventory()
            if not inv then
                return nil
            end

            local kunai
            local children = inv:GetChildren()
            for i = #children, 1, -1 do
                if children[i].Name == "NinjaKunai" then
                    kunai = children[i]
                    break
                end
            end

            if not kunai then 
                return nil 
            end

            local stickyPart = kunai:WaitForChild("StickyPart")
            local SoundPart = kunai:WaitForChild("SoundPart")

            if stickyPart and SoundPart then
                pcall(function()
                    ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(SoundPart, SoundPart.CFrame)
                    ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(SoundPart, torso.CFrame)
                end)
            end

            if stickyPart then
                local attachPosition = ragdollHitbox.CFrame
                local relativeCF = ragdollHitbox.CFrame:ToObjectSpace(attachPosition)

                pcall(function()
                    StickyPartEvent:FireServer(stickyPart, ragdollHitbox, CFrame.new(0,50,0)* CFrame.Angles(190, 0, 0))
                end)
            end

            task.wait(0.1)
            return kunai
        end

        for i = 1, 12 do
            createAndAttachKunai()
            task.wait(0.15)
        end
    end
})

antiTab:CreateSection("Teleport | Toggle")
local AntiGrabV1 = antiTab:CreateToggle({
    Name = "Void TP | Random",
    CurrentValue = false,
    Flag = "FakeTP",
    Callback = function(Value)
        AntiGrabTP_Active = Value

        if AntiGrabTP_Active then
            local char = plr.Character
            local cm = workspace.CurrentCamera
            
            if char then
                originalCharacter = char

                char.Archivable = true
                cloneCharacter = char:Clone()
                cloneCharacter.Parent = Workspace
                cloneCharacter.Name = "(Clone)"
                if cloneCharacter:FindFirstChild("Humanoid") then
                    cloneCharacter.Humanoid.BreakJointsOnDeath = false
                end
                char.Archivable = false

                if cm then
                    cm.CameraSubject = cloneCharacter:FindFirstChild("Humanoid")
                end
                plr.Character = cloneCharacter

                task.spawn(function()
                    while AntiGrabTP_Active and originalCharacter and originalCharacter.Parent do
                        local hrp = originalCharacter:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local randomX = math.random(-999999, 999999)
                            local randomZ = math.random(-999999, 999999)

                            hrp.CFrame = CFrame.new(randomX, 999999, randomZ)
                            task.wait()
                        else
                            task.wait(0.1)
                        end
                    end
                end)
            end
        else
            local cm = workspace.CurrentCamera

            if cloneCharacter then
                local cloneHRP = cloneCharacter:FindFirstChild("HumanoidRootPart")
                if cloneHRP then clonePosition = cloneHRP.CFrame end

                cloneCharacter:Destroy()
                cloneCharacter = nil
            end

            if originalCharacter and originalCharacter.Parent and cm then
                plr.Character = originalCharacter
                cm.CameraSubject = originalCharacter:FindFirstChild("Humanoid")

                if clonePosition then
                    local hrp = originalCharacter:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.CFrame = clonePosition
                    end
                end
            end

            originalCharacter = nil
        end
    end
})

local AntiGrabV1 = antiTab:CreateToggle({
    Name = "Loop TP | Random",
    CurrentValue = false,
    Flag = "5",
    Callback = function(Value)
        AntiGrabTP_ActiveV2 = Value

        local originalPosition = nil

        if Value then
            local char = plr.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                originalPosition = char.HumanoidRootPart.Position
            end
        end

        task.spawn(function()
            while AntiGrabTP_ActiveV2 and task.wait() do
                local char = plr.Character
                if not char then continue end
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if not hrp then continue end

                local randomX = math.random(-500, 500)
                local randomY = math.random(0, 500)
                local randomZ = math.random(-500, 500)

                hrp.CFrame = CFrame.new(randomX, randomY, randomZ)
            end

            if not AntiGrabTP_ActiveV2 and originalPosition then

                local char = plr.Character
                if char and char:FindFirstChild("HumanoidRootPart") then
                    char.HumanoidRootPart.CFrame = CFrame.new(originalPosition)
                end
            end
        end)
    end
})

antiTab:CreateSection("Grab | Toggle")
local AntiGrab = antiTab:CreateToggle({
    Name = "Anti-Grab",
    CurrentValue = false,
    Flag = "5",
    Callback = function(Value)
        AntiGrabF(Value)
    end
})
AntiGrab:Set(true)

local AntiGrabSticky = antiTab:CreateToggle({
    Name = "Anti-Grab | StickyPart",
    CurrentValue = false,
    Callback = function(Value)
        AntiGrabStickyT = Value
        if Value then
            AntiGrabStickyF()
        end
    end
})

local AntiRelease = antiTab:CreateToggle({
    Name = "Anti-Release",
    CurrentValue = false,
    Flag = "AntiDeathToggleFlag",
    Callback = function(Value)
        AntiDeathT = Value
        if AntiDeathT then
            task.spawn(AntiDeathF)
        end
    end,
})
--AntiRelease:Set(true)

antiTab:CreateSection("Blob | Toggle")
local AntiBlob = antiTab:CreateToggle({
	Name = "Anti-Blob",
	CurrentValue = false,
	Flag = "16",
	Callback = function(Value)
		AntiBlobT = Value
		if Value then
			AntiBlobF()
		end
	end
})
AntiBlob:Set(true)

local AntiMassless = antiTab:CreateToggle({
    Name = "Anti-Massless",
    CurrentValue = false,
    Flag = "17",
    Callback = function(Value)
    masslessT = Value
        masslessF()
    end
})
AntiMassless:Set(true)

antiTab:CreateSection("Plot | Toggle")

local TEST= false

if TEST then
local dddddd Toggle = antiTab:CreateToggle({
    Name = "ddddddddddd",
    CurrentValue = false,
    Flag = "ddddddd Flag",
    Callback = function(Value)
        ddddddd = Value
        ddddddd()
    end
})
end

local AntiInPlots = antiTab:CreateToggle({
    Name = "Anti-InPlots",
    CurrentValue = true,
    Callback = function(Value)
    antiInPlotsEnabled = Value
         if Value then
            task.spawn(antiInPlotsLoop)
        end
    end
})
AntiInPlots:Set(true)

antiTab:CreateSection("Game | Toggle")
local AntiVoid = antiTab:CreateToggle({
    Name = "Anti-Void",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            workspace.FallenPartsDestroyHeight = -50000
        else
            workspace.FallenPartsDestroyHeight = -100
        end
    end,
})
AntiVoid:Set(true)

local AntiExplode = antiTab:CreateToggle({
    Name = "Anti-Explosion",
    CurrentValue = false,
    Flag = "antiExplodeToggleFlag",
    Callback = function(Value)
        AntiExplosionT = Value
        if Value then
            AntiExplosionF()
        elseif AntiExplosionC then
            AntiExplosionC:Disconnect()
            AntiExplosionC = nil
        end
    end
})
AntiExplode:Set(true)

local AntiBurn = antiTab:CreateToggle({
    Name = "Anti-Burn",
    CurrentValue = false,
    Flag = "",
    Callback = function(Value)
        AntiBurnV = Value
        AntiBurn()
    end
})
AntiBurn:Set(true)

local AntiPaint = antiTab:CreateToggle({
    Name = "Anti-Paint",
    CurrentValue = false,
    Callback = function(Value)
        AntiPaintT = Value
        antiPaintF(Value)
    end
})
AntiPaint:Set(true)

AntiLagF()
local AntiLag = antiTab:CreateToggle({
    Name = "Anti-Lag",
    CurrentValue = false,
    Flag = "AntiLagToggle",
    Callback = function(Value)
        antiLagEnabled = Value
    end
})
AntiLag:Set(true)

local AutoAttack  antiTab:CreateToggle({
    Name = "Auto-Attacker | Kill",
    CurrentValue = false,
    Flag = "AutoAttack",
    Callback = function(Value)
        AutoAttackT = Value
        AutoAttackF()
    end
})

local AntiHoldPart = antiTab:CreateToggle({
    Name = "Anti-Hold Part",
    CurrentValue = false,
    Callback = function(Value)
        AntiBananaT = Value
        task.spawn(AntiBananaF)
    end
})
--AntiHoldPart:Set(true)

local AntiBlobUse = antiTab:CreateToggle({
    Name = "Anti-Vehicle Toy",
    CurrentValue = false,
    Callback = function(Value)
        AntiBlobUseT = Value
        if Value then
            AntiBlobUseF()
        end
    end
})

antiTab:CreateSection("Kick | Toggle")
local FlyingReset = antiTab:CreateToggle({
    Name = "Flying Reset",
    CurrentValue = false,
    Callback = function(Value)

if Value then
rs.GameCorrectionEvents.GameCorrectionsNotify.OnClientEvent:Connect(function(Type)
if Type == "Flying" then

char = plr.Character
hum = char:FindFirstChildOfClass("Humanoid")
hrp = char:FindFirstChildOfClass("HumanoidRootPart")

rs.CharacterEvents.Struggle:FireServer()
hum.Health = 0
hum:ChangeState(Enum.HumanoidStateType.Dead)
char:BreakJoints()

end
end)
end
    end
})
FlyingReset:Set(true)

local AntiKick = antiTab:CreateToggle({
    Name = "Anti-Kick [ StickyPart ]",
    CurrentValue = false,
    Callback = function(Value)
        AntiKickT = Value
        task.spawn(AntiKickF)
    end
})
--AntiKick:Set(true)

antiTab:CreateButton({
    Name = "Anti-Kick [ StickyPart House ]",
    Callback = function()
        House()

        local plotItemsFolder = workspace.PlotItems:FindFirstChild("Plot"..Plot)
        local TP = workspace.Plots["Plot"..Plot].PlotArea
        local targetCFrame = CFrame.new(TP.Position)

        local char = plr.Character
        if not char then return end

        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local ragdollHitbox = hrp:FindFirstChild("RagdollTouchedHitbox")
        if ragdollHitbox then
            hrp = ragdollHitbox
        end

        local originalPosition = hrp.CFrame

        local targetValue = CFrame.new(0.05, -0.3, 0.3) * CFrame.Angles(190, 0, 0)
        local stickyPartName = "NinjaShuriken"

        if plotItemsFolder then

            local closestShuriken = nil
            local closestDistance = math.huge

            for _, item in pairs(plotItemsFolder:GetChildren()) do
                if item.Name == "NinjaShuriken" then
                    local stickyPart = item:FindFirstChild("StickyPart")
                    if stickyPart then
                        local distance = (hrp.Position - stickyPart.Position).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestShuriken = item
                        end
                    end
                end
            end

            if closestShuriken and closestDistance <= 30 then
                local stickyPart = closestShuriken:FindFirstChild("StickyPart")
                if stickyPart then
                    local FIND2 = stickyPart:FindFirstChild("StickyWeld")

                    if not FIND2 or (FIND2 and FIND2.Part1 ~= hrp) then

                        if not plr.InPlot.Value then
                            hrp.CFrame = targetCFrame
                            task.wait(0.5)
                        end

                        pcall(function()
                            SetNetworkOwner:FireServer(stickyPart, stickyPart.CFrame)
                        end)

                        pcall(function()
                            rs.PlayerEvents.StickyPartEvent:FireServer(stickyPart, hrp, targetValue)
                        end)

                        hrp.CFrame = originalPosition
                    end
                end
            else
                if not plr.InPlot.Value then
                    hrp.CFrame = targetCFrame
                    task.wait(0.5)
                end

                task.spawn(function()
                    rs.MenuToys.SpawnToyRemoteFunction:InvokeServer(stickyPartName, hrp.CFrame * CFrame.new(0,20,15), Vector3.new(0,0,0))
                end)

                task.wait(0.15)

                local newFind = plotItemsFolder:FindFirstChild("NinjaShuriken")
                if newFind then
                    local stickyPart = newFind:FindFirstChild("StickyPart")
                    if stickyPart then
                        pcall(function()
                            SetNetworkOwner:FireServer(stickyPart, stickyPart.CFrame)
                        end)

                        pcall(function()
                            rs.PlayerEvents.StickyPartEvent:FireServer(stickyPart, hrp, targetValue)
                        end)
                    end
                end

                hrp.CFrame = originalPosition
            end
        end
    end
})

local AntiPCLD = antiTab:CreateToggle({
    Name = "Anti-Kick [ Delete PCLD ]",
    CurrentValue = false,
    Flag = "16",
    Callback = function(Value)
        AntiPCLDT = Value
        task.spawn(AntiPCLDF)
    end
})
AntiPCLD:Set(true)

antiTab:CreateSection("Ragdoll | Toggle")
local PermRag = antiTab:CreateToggle({
    Name = "Ragdoll",
    CurrentValue = false,
    Flag = "34",
    Callback = function(Value)
        permRagdollT = Value
        if permRagdollT and not permRagdollRunningS then
            coroutine.wrap(permRagdollLoopF)()
        elseif not permRagdollT then
            permRagdollRunningS = false
        end
    end
})

local PermRag2 = antiTab:CreateToggle({
    Name = "Ragdoll Value",
    CurrentValue = false,
    Flag = "RagdollLoopToggle",
    Callback = function(Value)
        ragdollRunning = Value
        task.spawn(ragdollLoopF2)
    end
})

local RagdollWalkToggle = antiTab:CreateToggle({
    Name = "Ragdoll Walk",
    CurrentValue = false,
    Flag = "14",
    Callback = function(Value)
        RagdollWalkT = Value
        RagdollWalk()
    end
})

antiTab:CreateSection("Gucci | Toggle")
local AutoGucci = antiTab:CreateToggle({
    Name = "Auto-Gucci",
    CurrentValue = false,
    Flag = "autoGucciToggleFlag",
    Callback = function(Value)
        AutoGucciT = Value
        if AutoGucciT then
            task.spawn(AutoGucciF)
        else
            if plr.Character.Humanoid then
                    plr.Character.Humanoid.Sit = true
                    task.wait(0.1)
                    plr.Character.Humanoid.Sit = false
                end
            end

            sitJumpT = false

            if blobmanInstanceS then
            RepStorage.MenuToys.DestroyToy:FireServer(blobmanInstanceS)
            blobmanInstanceS = nil
        end
    end
})

local AutoGucciV2 = antiTab:CreateToggle({
    Name = "Train Gucci",
    CurrentValue = false,
    Flag = "autoGucciToggleFlag",
    Callback = function(Value)
        AutoGucciTV2 = Value
        if AutoGucciTV2 then
            task.spawn(AutoGucciFV2)
        else
            local char = plr.Character
            if char then
                local hum = char:FindFirstChild("Humanoid")
                if hum then
                    hum.Sit = true
                    task.wait(0.1)
                    hum.Sit = false
                 end
	    end
    	 sitJumpT = false
     end
end
})

antiTab:CreateSection("Delete | Toggle")
local AutoHeight = antiTab:CreateToggle({
    Name = "Auto-HipHeight",
    CurrentValue = false,
    Callback = function(Value)
        ToggleActive = Value
        StartMonitoring()
    end
})

local AutoDele = antiTab:CreateToggle({
	Name = "Auto-Delete | Me",
	CurrentValue = false,
	Flag = "15",
	Callback = function(Value)
		autoDeleteLegs = Value
		ragdollLegExplodeF()
	end
})

local AutoDeletePartsDropdown = antiTab:CreateDropdown({
	Name = "Select",
	Options = {"Arm/Leg", "Leg/ì™¼ìª½", "Leg/ì˜¤ë¥¸ìª½", "All/Leg", "Arm/ì™¼ìª½", "Arm/ì˜¤ë¥¸ìª½", "All/Arm"},
	CurrentOption = {"OPEN"},
	Callback = function(Value)
		selectedAutoDeletePart = Value[1]
	end,
})

antiTab:CreateSection("")
local KeybindTab = antiTab:CreateKeybind({
    Name = "Delete | Target",
    CurrentKeybind = "Q",
    HoldToInteract = false,
    Callback = function()
            local beamPart = workspace:FindFirstChild("GrabParts") and workspace.GrabParts:FindFirstChild("BeamPart")
            if beamPart then
                local targetPlayer = getClosestPlayer(beamPart)
                if targetPlayer then
                teleportParts(targetPlayer, selectedPart)
			end
		end
    end
})

local Dropdown = antiTab:CreateDropdown({
    Name = "Select",
    Options = {"Arm/Leg", "Leg/ì™¼ìª½", "Leg/ì˜¤ë¥¸ìª½", "All/Leg", "Arm/ì™¼ìª½", "Arm/ì˜¤ë¥¸ìª½", "All/Arm"},
    CurrentOption = {"OPEN"},
    Callback = function(Value)
        selectedPart = Value[1]
    end,
})

playerTab:CreateSection("Humanoid")
playerTab:CreateToggle({
    Name = "Walk Speed",
    CurrentValue = false,
    Flag = "28",
    Callback = function(Value)
        walkSpeedT = Value 
        updateWalkSpeedF()
    end
})

local walkSpeedInput = playerTab:CreateInput({
    Name = "Value",
    CurrentValue = 16,
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Flag = "29",
    Callback = function(Value)
        walkSpeedV = Value
        updateWalkSpeedF()
    end
})
walkSpeedInput:Set(16)

playerTab:CreateSection("")
playerTab:CreateToggle({
    Name = "Jump Power",
    CurrentValue = false,
    Flag = "30",
    Callback = function(Value)
        jumpPowerT = Value
        updateJumpPowerF()
    end
})

local jumpPowerInput = playerTab:CreateInput({
    Name = "Value",
    CurrentValue = 24,
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Flag = "31",
    Callback = function(Value)
        jumpPowerV = Value
        updateJumpPowerF()
    end
})
jumpPowerInput:Set(24)

playerTab:CreateSection("Other")
local NoClipToggle = playerTab:CreateToggle({
    Name = "No-Clip",
    CurrentValue = false,
    Flag = "32",
    Callback = function(Value)
        noClipT = Value
        updateNoClipF()
    end
})

local infJumpToggle = playerTab:CreateToggle({
    Name = "Infinite jump",
    CurrentValue = false,
    Flag = "32",
    Callback = function(Value)
        infJumpT = Value
        updateInfJumpF()
    end
})

local Fly = playerTab:CreateToggle({ 
    Name = "Fly", 
    CurrentValue = false,
    Flag = "5",
    Callback = function(Value)
        flyT = Value
        flyF()
    end
})

local flyInput = playerTab:CreateInput({
    Name = "Speed",
    CurrentValue = 50,
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Flag = "37",
    Callback = function(Value)
        flyV = Value
    end
})
flyInput:Set(80)

AuraTab:CreateToggle({
    Name = "test Aura",
    CurrentValue = false,
    Flag = "5",
    Callback = function(Value)
        --ViewAuraT = Value
        --if Value then
            --ViewAuraF()
        --end
    end
})

AuraTab:CreateToggle({
    Name = "Anti-Boombox Aura [ Owner ]", -- Boombox
    CurrentValue = false,
    Flag = "5",
    Callback = function(Value)
        AntiBoxT = Value
        AntiBoxF()
    end
})

AuraTab:CreateToggle({
    Name = "Anti-Banana Aura [ Owner ]",
    CurrentValue = false,
    Flag = "5",
    Callback = function(Value)
        AntiBananaAuraT = Value
        AntiBananaAuraF()
    end
})

AuraTab:CreateToggle({
    Name = "Anti-StickyPart Aura [ Owner ]",
    CurrentValue = false,
    Flag = "5",
    Callback = function(Value)
        ViewAuraT = Value
        ViewAuraF()
    end
})

funTab:CreateSection("TP")
local VoidInput = funTab:CreateInput({
   Name = "Set Y",
   CurrentValue = "",
   PlaceholderText = "...",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
      local num = tonumber(Text)
      if num then
         Value = num
      else
         Value = nil
      end
   end,
})

local VoidButton = funTab:CreateButton({
   Name = "Teleport",
   Callback = function()
      if not Value then return end
      local hrp = plr.Character:WaitForChild("HumanoidRootPart")
      local pos = hrp.Position
      hrp.CFrame = CFrame.new(pos.X, Value, pos.Z)
   end,
})

funTab:CreateSection("")
local teleportLocations = {
    ["ìŠ¤í°"] = {0, -7, 0},
    ["ìŠ¤í°ì‚°"] = {494, 163, 175},
    ["ì„¤ì‚°"] = {-394, 230, 509},
    ["í—›ê°„(ë†ì§€)"] = {-156, 59, -291},
    ["ìœ„í—˜êµ¬ì—­"] = {125, -7, 241},
    ["í•˜ëŠ˜ì„¬"] = {63, 346, 309},
    ["í°ë™êµ´"] = {-240, 29, 554},
    ["ìž‘ì€ë™êµ´"] = {-84, 14, -310},
    ["ì—´ì°¨ë™êµ´"] = {602, 45, -175},
    ["ê´‘ì‚°"] = {-308, -7, 506},
    ["ì´ˆë¡ì§‘"] = {-352, 98, 353},
    ["(ì´ˆë¡ì§‘)"] = {-532, -7, 92},
    ["(ë¶„í™ì§‘)"] = {-484, -7, -165},
    ["(ë³´ë¼ì§‘)"] = {249, -7, 461},
    ["(íŒŒëž‘ì§‘)"] = {513, 83, -341},
    ["(ë¹¨ê°•ì§‘)"] = {551, 123, -73},
}

local selectedLocation = "ìŠ¤í°"

local Dropdown = funTab:CreateDropdown({
    Name = "Select Zone",
    Options = {"ìŠ¤í°","ìŠ¤í°ì‚°","ê´‘ì‚°","í°ë™êµ´","ìž‘ì€ë™êµ´","ì—´ì°¨ë™êµ´","ìœ„í—˜êµ¬ì—­","ì„¤ì‚°","í—›ê°„(ë†ì§€)","í•˜ëŠ˜ì„¬","ì´ˆë¡ì§‘","(ì´ˆë¡ì§‘)","(ë¶„í™ì§‘)","(ë³´ë¼ì§‘)","(íŒŒëž‘ì§‘)","(ë¹¨ê°•ì§‘)"},
    CurrentOption = "ìŠ¤í°",
    MultipleOptions = false,
    Callback = function(Value)
        if typeof(Value) == "table" then
            selectedLocation = Value[1] or "ìŠ¤í°"
        else
            selectedLocation = Value
        end
    end,
})

local Button = funTab:CreateButton({
    Name = "Teleport",
    Callback = function()
        local plr = game.Players.LocalPlayer
        local char = plr.Character or plr.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart")

        local pos = teleportLocations[selectedLocation]
        if not pos then
            return
        end

        hrp.CFrame = CFrame.new(pos[1], pos[2], pos[3])
    end,
})

funTab:CreateSection("Lag")
funTab:CreateToggle({
    Name = "Line Lag",
    CurrentValue = false,
    Flag = "lagToggleFlag",
    Callback = function(Value)
        LineLagT = Value
        LineLagF()
    end
})

funTab:CreateInput({
    Name = "Lines",
    CurrentValue = 50,
    PlaceholderText = "Lines",
    RemoveTextAfterFocusLost = false,
    Flag = "linesInputFlag",
    Callback = function(Value)
        LineLagV = Value
    end
})

funTab:CreateSection("Penis")
local Inputt = funTab:CreateInput({
   Name = "Pencil",
   CurrentValue = "",
   PlaceholderText = "Value",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
   end
})

local Ctratee = funTab:CreateButton({
   Name = "Create",
   Callback = function()
       local ReplicatedStorage = game:GetService("ReplicatedStorage")
       local pencilCountText = Inputt.CurrentValue
       local TNUM = tonumber(pencilCountText)

       if not TNUM or TNUM <= 0 then
           warn("Please enter a valid number!")
           Rayfield:Notify({Title = "[ âœï¸ ]", Content = "Nil Value", Duration = 3, Image = 0})
           return
       end

       local character = plr.Character or plr.CharacterAdded:Wait()
       local hrp = character:WaitForChild("HumanoidRootPart")
       local inv = workspace:WaitForChild(plr.Name .. "SpawnedInToys")
       local StickyPartEvent = ReplicatedStorage:WaitForChild("PlayerEvents"):WaitForChild("StickyPartEvent")
       local SpawnToy = ReplicatedStorage:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction")


function GetPlotNumber()
    local char = plr.Character
    if not char then return nil end

    if char.Parent == workspace then 
        return nil
    elseif char.Parent.Name == "PlayersInPlots" then
        for _, plot in workspace.Plots:GetChildren() do
            for _, owner in plot.PlotSign.ThisPlotsOwners:GetChildren() do
                if owner.Value == plr.Name then
                    if plot.Name == "Plot1" then
                        return 1
                    elseif plot.Name == "Plot2" then
                        return 2
                    elseif plot.Name == "Plot3" then
                        return 3
                    elseif plot.Name == "Plot4" then
                        return 4
                    elseif plot.Name == "Plot5" then
                        return 5
                    end
                end
            end
        end
    end
    return nil
end

function GetInventory()
    local plotNumber = GetPlotNumber()

    if plotNumber then
        local plotItems = workspace:FindFirstChild("PlotItems")
        if plotItems then
            local plotFolder = plotItems:FindFirstChild("Plot" .. plotNumber)
            if plotFolder then
                return plotFolder
            end
        end
    end
    return workspace:WaitForChild(plr.Name .. "SpawnedInToys")
end

local inv = GetInventory()

function createPencil(index)
    while not plr.CanSpawnToy.Value do task.wait() end

    task.spawn(function()
        SpawnToy:InvokeServer("ToolPencil", hrp.CFrame * CFrame.new(0,5,15), Vector3.new(0,0,0))
    end)

    task.wait(0.3)

    inv = GetInventory()

    local pencil
    local children = inv:GetChildren()
    for i = #children, 1, -1 do
        if children[i].Name == "ToolPencil" then
            pencil = children[i]
            break
        end
    end

    if not pencil then 
        print("Pencil not found in inventory")
        return nil 
    end

    local stickyPart = pencil:WaitForChild("StickyPart")
    local SoundPart = pencil:WaitForChild("SoundPart")

    if stickyPart and SoundPart then
        ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(SoundPart, SoundPart.CFrame)
        ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(SoundPart, character.Torso.CFrame)
    end

    local PartOwner = SoundPart:WaitForChild("PartOwner")
    if PartOwner then
        SoundPart.CFrame = CFrame.new(0, 599999, 999)
    end

    stickyPart.Name = "w" .. index

    for _, part in pairs(pencil:GetDescendants()) do
        if part:IsA("BasePart") and part.Color == Color3.fromRGB(158, 108, 141) then
            part.Name = "a" .. index
        end
    end

    return pencil
end

local pencils = {}

for i = 1, TNUM do
    local pencil = createPencil(i)
    if pencil then
        table.insert(pencils, pencil)
    end
    task.wait(0.1)
end

for i = 1, #pencils - 1 do
    local currentPencil = pencils[i]
    local nextPencil = pencils[i + 1]

    if currentPencil and nextPencil then
        local attachFrom = currentPencil:FindFirstChild("w" .. i)
        local attachTo = nextPencil:FindFirstChild("a" .. (i + 1))

        if attachFrom and attachTo then
            StickyPartEvent:FireServer(attachFrom, attachTo, CFrame.Angles(0, math.rad(-90), 0))
        end
    end
    task.wait(0.05)
end

local torso2 = character:WaitForChild("HumanoidRootPart"):WaitForChild("RagdollTouchedHitbox")
local torso = character:FindFirstChild("Torso")
if torso2 and #pencils >= TNUM then
    local lastPencil = pencils[TNUM]
    if lastPencil then
        local wLast = lastPencil:FindFirstChild("w" .. TNUM)
        if wLast then
            local attachPosition = torso2.CFrame * CFrame.new(0, -1.1, 0.1) * CFrame.Angles(0, math.rad(180), 0) -- CFrame.new(0, -torso2.Size.Y/2 - -0.1, -0.5)
            local relativeCF = torso2.CFrame:ToObjectSpace(attachPosition)
            StickyPartEvent:FireServer(wLast, torso2, relativeCF)
        end
    end
end
   end
})

funTab:CreateSection("StickyEvent")
local Inputt = funTab:CreateInput({
   Name = "Kunai",
   CurrentValue = "",
   PlaceholderText = "Value",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
   end
})

local Ctratee = funTab:CreateButton({
   Name = "Create [ Grab The Part ]",
   Callback = function()
       local ReplicatedStorage = game:GetService("ReplicatedStorage")
       local Players = game:GetService("Players")
       local plr = Players.LocalPlayer
       
       local kunaiCountText = Inputt.CurrentValue
       local TNUM = tonumber(kunaiCountText)

       if not TNUM or TNUM <= 0 or TNUM > 100 then
           Rayfield:Notify({Title = "[ ðŸ¥· ]", Content = "Invalid Value", Duration = 3, Image = 0})
           return
       end

       local character = plr.Character or plr.CharacterAdded:Wait()
       local hrp = character:WaitForChild("HumanoidRootPart")
       local torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
       
       if not torso then
           return
       end
       
       local StickyPartEvent = ReplicatedStorage:WaitForChild("PlayerEvents"):WaitForChild("StickyPartEvent")
       local SpawnToy = ReplicatedStorage:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction")

       function GetTargetPartFromGrabParts()
           local grabPartsModel = workspace:FindFirstChild("GrabParts")
           if not grabPartsModel then return nil end

           local grabPart = grabPartsModel:FindFirstChild("GrabPart")
           if not grabPart then return nil end

           local weldConstraint = grabPart:FindFirstChild("WeldConstraint")
           if not weldConstraint or not weldConstraint:IsA("WeldConstraint") then return nil end

           if not weldConstraint.Part1 then return nil end

           return weldConstraint.Part1
       end

       function GetPlotNumber()
           local char = plr.Character
           if not char then return nil end

           if char.Parent == workspace then 
               return nil
           elseif char.Parent.Name == "PlayersInPlots" then
               for _, plot in workspace.Plots:GetChildren() do
                   local plotSign = plot:FindFirstChild("PlotSign")
                   if plotSign and plotSign:FindFirstChild("ThisPlotsOwners") then
                       for _, owner in plotSign.ThisPlotsOwners:GetChildren() do
                           if owner.Value == plr.Name then
                               if plot.Name == "Plot1" then
                                   return 1
                               elseif plot.Name == "Plot2" then
                                   return 2
                               elseif plot.Name == "Plot3" then
                                   return 3
                               elseif plot.Name == "Plot4" then
                                   return 4
                               elseif plot.Name == "Plot5" then
                                   return 5
                               end
                           end
                       end
                   end
               end
           end
           return nil
       end

       function GetInventory()
           local plotNumber = GetPlotNumber()

           if plotNumber then
               local plotItems = workspace:FindFirstChild("PlotItems")
               if plotItems then
                   local plotFolder = plotItems:FindFirstChild("Plot" .. plotNumber)
                   if plotFolder then
                       return plotFolder
                   end
               end
           end
           
           local defaultInv = workspace:FindFirstChild(plr.Name .. "SpawnedInToys")
           if defaultInv then
               return defaultInv
           end
           
           return nil
       end

       local targetPart = GetTargetPartFromGrabParts()
       if not targetPart then
           return
       end

       function createAndAttachKunai()
           while not plr.CanSpawnToy.Value do 
               task.wait(0.1) 
           end

           local position = hrp.CFrame

           local success, result = pcall(function()
 task.spawn(function()
               return SpawnToy:InvokeServer("NinjaKunai", hrp.CFrame * CFrame.new(0,5,15), Vector3.new(0, 0, 0))
           end)
           end)
           
           if not success then
               return nil
           end

           task.wait(0.2)

           local inv = GetInventory()
           if not inv then
               return nil
           end

           local kunai
           local children = inv:GetChildren()
           for i = #children, 1, -1 do
               if children[i].Name == "NinjaKunai" then
                   kunai = children[i]
                   break
               end
           end

           if not kunai then 
               return nil 
           end

           local stickyPart = kunai:WaitForChild("StickyPart")
           local SoundPart = kunai:WaitForChild("SoundPart")

           if stickyPart and SoundPart then
               pcall(function()
                   ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(SoundPart, SoundPart.CFrame)
                   ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(SoundPart, torso.CFrame)
               end)
           end

           if stickyPart then
               local attachPosition = targetPart.CFrame
               local relativeCF = targetPart.CFrame:ToObjectSpace(attachPosition)

               pcall(function()
                   StickyPartEvent:FireServer(stickyPart, targetPart, relativeCF)
               end)
           end

           task.wait(0.1)
           return kunai
       end

       for i = 1, TNUM do
           createAndAttachKunai()
           task.wait(0.1)
       end
   end
})

keybindTab:CreateSection("Shader")
keybindTab:CreateButton({
    Name = "Default",
    Callback = function()
        local Lighting = game:GetService("Lighting")

        for _, obj in ipairs(Lighting:GetChildren()) do
            if obj:IsA("Sky") or obj:IsA("Atmosphere") 
            or obj:IsA("BloomEffect") or obj:IsA("ColorCorrectionEffect") 
            or obj:IsA("SunRaysEffect") then
                obj:Destroy()
            end
        end

        Lighting.Ambient = Color3.fromRGB(120, 120, 120)
        Lighting.Brightness = 2
        Lighting.ColorShift_Bottom = Color3.fromRGB(0, 0, 0)
        Lighting.ColorShift_Top = Color3.fromRGB(0, 0, 0)
        Lighting.EnvironmentDiffuseScale = 0
        Lighting.EnvironmentSpecularScale = 0.25
        Lighting.GlobalShadows = true
        Lighting.OutdoorAmbient = Color3.fromRGB(200, 200, 200)
        Lighting.ShadowSoftness = 0.2
        Lighting.Technology = Enum.Technology.Future
        Lighting.ClockTime = 14
        Lighting.GeographicLatitude = 41.735
        Lighting.FogColor = Color3.fromRGB(192, 192, 192)
        Lighting.FogEnd = 100000
        Lighting.FogStart = 0

        local sky = Instance.new("Sky")
        sky.Parent = Lighting
        sky.CelestialBodiesShown = true
        sky.MoonAngularSize = 0
        sky.MoonTextureId = "rbxasset://sky/moon.jpg"
        sky.SkyboxBk = "rbxassetid://8995816670"
        sky.SkyboxDn = "rbxassetid://8995686153"
        sky.SkyboxFt = "rbxassetid://8995816670"
        sky.SkyboxLf = "rbxassetid://8995816670"
        sky.SkyboxRt = "rbxassetid://8995816670"
        sky.SkyboxUp = "rbxassetid://8995814929"
        sky.StarCount = 3000
        sky.SunAngularSize = 30
        sky.SunTextureId = "rbxassetid://8923082571"
    end
})

keybindTab:CreateButton({
    Name = "Day Time",
    Callback = function()
        local Lighting = game:GetService("Lighting")

        Lighting.Ambient = Color3.fromRGB(0, 0, 0)
        Lighting.Brightness = 3.13
        Lighting.ColorShift_Bottom = Color3.fromRGB(0, 0, 0)
        Lighting.ColorShift_Top = Color3.fromRGB(188, 141, 1)
        Lighting.EnvironmentDiffuseScale = 0.583
        Lighting.EnvironmentSpecularScale = 1
        Lighting.GlobalShadows = true
        Lighting.OutdoorAmbient = Color3.fromRGB(145, 128, 95)
        Lighting.ShadowSoftness = 0.04
        Lighting.Technology = Enum.Technology.Future
        Lighting.ClockTime = 14.5
        Lighting.GeographicLatitude = 143
        Lighting.FogColor = Color3.fromRGB(146, 208, 255)
        Lighting.FogEnd = 3000
        Lighting.FogStart = 300

        local sky = Lighting:FindFirstChildOfClass("Sky") or Instance.new("Sky", Lighting)
        sky.CelestialBodiesShown = true
        sky.MoonAngularSize = 11
        sky.MoonTextureId = "rbxassetid://6444320592"
        sky.SkyboxBk = "rbxassetid://6444884337"
        sky.SkyboxDn = "rbxassetid://6444884785"
        sky.SkyboxFt = "rbxassetid://6444884337"
        sky.SkyboxLf = "rbxassetid://6444884337"
        sky.SkyboxRt = "rbxassetid://6444884337"
        sky.SkyboxUp = "rbxassetid://6412503613"
        sky.StarCount = 0
        sky.SunAngularSize = 11
        sky.SunTextureId = "rbxassetid://1084351190"

        local bloom = Lighting:FindFirstChildOfClass("BloomEffect") or Instance.new("BloomEffect", Lighting)
        bloom.Intensity = 1
        bloom.Size = 90
        bloom.Threshold = 2

        local cc = Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect", Lighting)
        cc.Brightness = 0.04
        cc.Contrast = 0.19
        cc.Saturation = 0.12
        cc.TintColor = Color3.fromRGB(255, 255, 255)
    end
})

keybindTab:CreateButton({
    Name = "Shore",
    Callback = function()
        local Lighting = game:GetService("Lighting")

        Lighting.Ambient = Color3.fromRGB(109, 117, 135)
        Lighting.Brightness = 1.921
        Lighting.ColorShift_Bottom = Color3.fromRGB(248, 165, 159)
        Lighting.ColorShift_Top = Color3.fromRGB(226, 75, 0)
        Lighting.EnvironmentDiffuseScale = 0.172
        Lighting.EnvironmentSpecularScale = 0.738
        Lighting.GlobalShadows = true
        Lighting.OutdoorAmbient = Color3.fromRGB(36, 47, 58)
        Lighting.ShadowSoftness = 0.25
        Lighting.Technology = Enum.Technology.Future
        Lighting.TimeOfDay = "-06:23:59"
        Lighting.GeographicLatitude = 0
        Lighting.FogColor = Color3.fromRGB(192, 192, 192)
        Lighting.FogEnd = 100000
        Lighting.FogStart = 0

        local atmosphere = Lighting:FindFirstChildOfClass("Atmosphere") or Instance.new("Atmosphere", Lighting)
        atmosphere.Density = 0.359
        atmosphere.Offset = 0
        atmosphere.Color = Color3.fromRGB(255, 216, 194)
        atmosphere.Decay = Color3.fromRGB(123, 151, 182)
        atmosphere.Glare = 2.97
        atmosphere.Haze = 1.52

        local sky = Lighting:FindFirstChildOfClass("Sky") or Instance.new("Sky", Lighting)
        sky.CelestialBodiesShown = true
        sky.MoonAngularSize = 0
        sky.MoonTextureId = "rbxasset://sky/moon.jpg"
        sky.SkyboxBk = "rbxassetid://88585370973398"
        sky.SkyboxDn = "rbxassetid://128014535205529"
        sky.SkyboxFt = "rbxassetid://85323615042244"
        sky.SkyboxLf = "rbxassetid://77415797450913"
        sky.SkyboxRt = "rbxassetid://127566931602371"
        sky.SkyboxUp = "rbxassetid://102320981098060"
        sky.StarCount = 5000
        sky.SunAngularSize = 4
        sky.SunTextureId = "rbxasset://sky/sun.jpg"

        local bloom = Lighting:FindFirstChildOfClass("BloomEffect") or Instance.new("BloomEffect", Lighting)
        bloom.Intensity = 1
        bloom.Size = 50
        bloom.Threshold = 2.291

        local blur = Lighting:FindFirstChildOfClass("BlurEffect") or Instance.new("BlurEffect", Lighting)
        blur.Enabled = false
        blur.Size = 4

        local cc = Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect", Lighting)
        cc.Brightness = 0
        cc.Contrast = 0.2
        cc.Saturation = 0
        cc.TintColor = Color3.fromRGB(255, 255, 255)

        local sunrays = Lighting:FindFirstChildOfClass("SunRaysEffect") or Instance.new("SunRaysEffect", Lighting)
        sunrays.Intensity = 0.024
        sunrays.Spread = 0.463
    end
})

keybindTab:CreateButton({
    Name = "Cloudy",
    Callback = function()
        local Lighting = game:GetService("Lighting")

        Lighting.Ambient = Color3.fromRGB(0, 0, 0)
        Lighting.Brightness = 5.63
        Lighting.ColorShift_Bottom = Color3.fromRGB(0, 0, 0)
        Lighting.ColorShift_Top = Color3.fromRGB(207, 114, 0)
        Lighting.EnvironmentDiffuseScale = 0.583
        Lighting.EnvironmentSpecularScale = 1
        Lighting.GlobalShadows = true
        Lighting.OutdoorAmbient = Color3.fromRGB(89, 68, 47)
        Lighting.ShadowSoftness = 0.04
        Lighting.Technology = Enum.Technology.Future
        Lighting.ClockTime = 17.629
        Lighting.GeographicLatitude = 21.589
        Lighting.FogColor = Color3.fromRGB(146, 208, 255)
        Lighting.FogEnd = 3000
        Lighting.FogStart = 300

        local atmosphere = Lighting:FindFirstChildOfClass("Atmosphere") or Instance.new("Atmosphere", Lighting)
        atmosphere.Density = 0.357
        atmosphere.Offset = 0
        atmosphere.Color = Color3.fromRGB(165, 165, 165)
        atmosphere.Decay = Color3.fromRGB(16, 16, 16)
        atmosphere.Glare = 0.21
        atmosphere.Haze = 1.46

        local sky = Lighting:FindFirstChildOfClass("Sky") or Instance.new("Sky", Lighting)
        sky.CelestialBodiesShown = true
        sky.MoonAngularSize = 1.5
        sky.MoonTextureId = "rbxassetid://1075087760"
        sky.SkyboxBk = "rbxassetid://2177969403"
        sky.SkyboxDn = "rbxassetid://2177972406"
        sky.SkyboxFt = "rbxassetid://2177970251"
        sky.SkyboxLf = "rbxassetid://2177969836"
        sky.SkyboxRt = "rbxassetid://2177968823"
        sky.SkyboxUp = "rbxassetid://2177971305"
        sky.StarCount = 500
        sky.SunAngularSize = 3
        sky.SunTextureId = "rbxasset://sky/sun.jpg"

        local bloom = Lighting:FindFirstChildOfClass("BloomEffect") or Instance.new("BloomEffect", Lighting)
        bloom.Intensity = 1
        bloom.Size = 90
        bloom.Threshold = 2

        local cc = Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect", Lighting)
        cc.Brightness = 0.04
        cc.Contrast = 0.15
        cc.Saturation = 0.2
        cc.TintColor = Color3.fromRGB(255, 255, 255)

        local sunrays = Lighting:FindFirstChildOfClass("SunRaysEffect") or Instance.new("SunRaysEffect", Lighting)
        sunrays.Intensity = 0.004
        sunrays.Spread = 0.167
    end
})

function jerk()
    local v2 = game:GetService('Players').LocalPlayer
    local v3 = (v2.Character or v2.CharacterAdded:Wait()):FindFirstChildOfClass('Humanoid')

    if not vu5 then
        local v4 = Instance.new('Animation')
        v4.AnimationId = 'rbxassetid://168268306'
        vu5 = (v3:FindFirstChildOfClass('Animator') or v3:WaitForChild('Animator')):LoadAnimation(v4)
    end
    
    vu6 = not vu6

    if vu6 then
        vu5:Play()
        task.wait(0.3)

        while vu6 do
            vu5.TimePosition = 0.3
            task.wait(0.1)
        end
    else
        vu5:Stop()
    end
end

keybindTab:CreateSection("Line")
local antilagDet = keybindTab:CreateInput({
    Name = "Line Detect",
    CurrentValue = 30,
    PlaceholderText = "",
    RemoveTextAfterFocusLost = false,
    Flag = "linesInputFlag",
    Callback = function(Value)
        AntiLagV = Value
    end
})
antilagDet:Set(30)

keybindTab:CreateSection("Animation")
local Jerk = keybindTab:CreateKeybind({
    Name = "Jerk",
    CurrentKeybind = "Three",
    HoldToInteract = false,
    Callback = jerk
})

game:GetService('Players').LocalPlayer.CharacterAdded:Connect(function()
    vu5 = nil
    vu6 = false
end)

keybindTab:CreateSection("Mouse")
keybindTab:CreateKeybind({
    Name = "Teleport",
    CurrentKeybind = "Z",
    HoldToInteract = false,
    Flag = "38",
    Callback = tpF
})

local Tper = keybindTab:CreateToggle({
    Name = "3rd person",
    CurrentValue = false,
    Flag = "AutoSitBlobman",
    Callback = function(Value)
        if Value then
            plr.CameraMode = Enum.CameraMode.Classic
            plr.CameraMaxZoomDistance = 100000
        else
            plr.CameraMode = Enum.CameraMode.LockFirstPerson
            plr.CameraMaxZoomDistance = 0.5
        end
    end
})
Tper:Set(true)

keybindTab:CreateSection("Sit")
local AutoSit = keybindTab:CreateToggle({
    Name = "Sit [Blobman]",
    CurrentValue = false,
    Flag = "AutoSitBlobman",
    Callback = function(Value)
        AutoSitT = Value
        AutoSitF()
    end
})

keybindTab:CreateKeybind({
    Name = "Sit [Blobman]",
    CurrentKeybind = "X",
    HoldToInteract = false,
    Flag = "40",
    Callback = function()
        BlobSit()
    end,
})

keybindTab:CreateSection("Plot")
local BarrierNoclip = keybindTab:CreateToggle({
    Name = "Barrier Noclip",
    CurrentValue = false,
    Flag = "BarrierNoclipToggle",
    Callback = function(Value)
        BarrierCanCollideT = Value
        BarrierCanCollideF()
    end
})
BarrierNoclip:Set(true)

keybindTab:CreateKeybind({
    Name = "Delete Barrier | FoodBread",
    CurrentKeybind = "Y",
    HoldToInteract = false,
    Callback = function()
        PlotBarrierDelete()
    end,
})

local isExecuting = false

local function getMyPlot()
    for i = 1, 5 do
        local plot = workspace.Plots:FindFirstChild("Plot" .. i)
        if plot then
            local plotSign = plot:FindFirstChild("PlotSign")
            if plotSign then
                local thisPlotsOwners = plotSign:FindFirstChild("ThisPlotsOwners")
                if thisPlotsOwners then
                    for _, child in ipairs(thisPlotsOwners:GetChildren()) do
                        if child:IsA("StringValue") and child.Value == game.Players.LocalPlayer.Name then
                            return plot.PlotArea
                        end
                    end
                end
            end
        end
    end
end

keybindTab:CreateKeybind({
    Name = "House Grab",
    CurrentKeybind = "G",
    HoldToInteract = false,
    Callback = function()
        if isExecuting then
            return
        end

        isExecuting = true

        local plr = game.Players.LocalPlayer
        local char = plr.Character or plr.CharacterAdded:Wait()
        local torso = char:WaitForChild("Torso")

        local inPlot = plr:FindFirstChild("InPlot")
        if not inPlot or inPlot.Value == false then
            isExecuting = false
            return
        end

        local TP = getMyPlot()
        if not TP then
            isExecuting = false
            return
        end

        local GrabParts = workspace:FindFirstChild("GrabParts")
        if GrabParts then
        mouse1click()
        end

        local torso = char:WaitForChild("Torso")
        local OCF = torso.CFrame
        torso.CFrame = TP.CFrame
        task.wait(0.15)
        torso.CFrame = OCF
        task.wait(0.15)
        mouse1click()
        isExecuting = false
    end
})

keybindTab:CreateSection("Owner")
keybindTab:CreateKeybind({
    Name = "Anchored",
    CurrentKeybind = "H",
    HoldToInteract = false,
    Flag = "AnchoredKeybind",
    Callback = function()
			local original = workspace:FindFirstChild("GrabParts")
			if not original then return end

			local grabPart = original:FindFirstChild("GrabPart", true)
			if not grabPart or not grabPart:IsA("BasePart") then return end

			local wasCollide = grabPart.CanCollide
			grabPart.CanCollide = true
			task.wait(0.1)

			local targetModel = nil
			local touchingParts = grabPart:GetTouchingParts()

			if #touchingParts == 0 then
				grabPart.CanCollide = wasCollide
				return
			end

			for _, part in ipairs(touchingParts) do
				if not part:IsDescendantOf(original) then
					local current = part
					while current and current ~= workspace do
						if current:IsA("Model") then
							targetModel = current
							break
						end
						current = current.Parent
					end
					if targetModel then break end
				end
			end

			grabPart.CanCollide = wasCollide

			if not targetModel then return end

			if not targetModel.Parent then
				local found = false
				local connection
				connection = targetModel.AncestryChanged:Connect(function(_, parent)
					if parent then
						found = true
						connection:Disconnect()
					end
				end)

				local startTime = tick()
				while not found and tick() - startTime < 2 do
					task.wait(0.1)
				end

				if not found then return end
			end

			local existing = targetModel:FindFirstChild("Force")
			if existing then
				local existingHighlight = targetModel:FindFirstChild("AnchorHighlight")
				if existingHighlight then
					existingHighlight:Destroy()
				end
				existing:Destroy()
				return
			end

			local clone = original:Clone()
			clone.Name = "Force" -- CleanedGrabParts

			for _, desc in ipairs(clone:GetDescendants()) do
				if desc:IsA("BasePart") then
					desc.Transparency = 1
					desc.CanCollide = false

					local beam = desc:FindFirstChild("GrabBeam")
					if beam then beam:Destroy() end

					for _, sName in ipairs({"AttachSound1", "AttachSound", "BeamSound", "BeamSound1"}) do
						local sound = desc:FindFirstChild(sName)
						if sound then sound:Destroy() end
					end
				end
			end

			clone.Parent = targetModel

			local hl = Instance.new("Highlight")
			hl.Name = "AnchorHighlight"
			hl.FillColor = Color3.fromRGB(0, 0, 255)
			hl.FillTransparency = 0.9
			hl.OutlineColor = Color3.fromRGB(0, 0, 255)
			hl.OutlineTransparency = 0.5
			hl.Adornee = targetModel
			hl.Parent = targetModel

			local connection
			connection = game:GetService("RunService").Heartbeat:Connect(function()
				if not clone or not clone.Parent or not targetModel or not targetModel.Parent then
					if connection then connection:Disconnect() end
					return
				end

				if hl and hl.Parent then
					hl.Adornee = targetModel
				else
					connection:Disconnect()
				end
			end)
    end
})

keybindTab:CreateSection("ESP")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")

local PcldViewT = false
local processed = {}
local redBoxes = {}
local descendantConn = nil

function PcldViewF()
    if descendantConn then
        descendantConn:Disconnect()
        descendantConn = nil
        workspace:SetAttribute("PcldViewDescendantConn", false)
    end

    if PcldViewT then
        for _, obj in ipairs(workspace:GetChildren()) do
            if (obj.Name == "PlayerCharacterLocationDetector" or obj.Name == "me") and obj:IsA("BasePart") then
                if not processed[obj] then
                    local box = Instance.new("SelectionBox")
                    box.Adornee = obj
                    box.LineThickness = 0.005
                    box.SurfaceTransparency = 1
                    box.SurfaceColor3 = Color3.fromRGB(255, 255, 255)
                    box.Color3 = Color3.fromRGB(255, 0, 0)
                    box.Parent = obj
                    processed[obj] = true
                    redBoxes[obj] = box
                end
            end
        end

        descendantConn = workspace.DescendantAdded:Connect(function(obj)
            if PcldViewT and (obj.Name == "PlayerCharacterLocationDetector" or obj.Name == "me") and obj:IsA("BasePart") then
                if not processed[obj] then
                    local box = Instance.new("SelectionBox")
                    box.Adornee = obj
                    box.LineThickness = 0.005
                    box.SurfaceTransparency = 1
                    box.SurfaceColor3 = Color3.fromRGB(255, 255, 255)
                    box.Color3 = Color3.fromRGB(255, 0, 0)
                    box.Parent = obj
                    processed[obj] = true
                    redBoxes[obj] = box
                end
            end
        end)

        workspace.DescendantRemoving:Connect(function(obj)
            if redBoxes[obj] then
                redBoxes[obj]:Destroy()
                redBoxes[obj] = nil
                processed[obj] = nil
            end
        end)

    else
        for obj, box in pairs(redBoxes) do
            if box then box:Destroy() end
        end
        redBoxes = {}
        processed = {}
    end
end

local iconEsp = keybindTab:CreateToggle({
    Name = "Icon esp",
    CurrentValue = false,
    Flag = "",
    Callback = function(Value)
        PlrEspT = Value
        PlrEspF()
    end
})
--iconEsp:Set(true)

local PCLDView = keybindTab:CreateToggle({
    Name = "PCLD View",
    CurrentValue = false,
    Flag = "PCLDView",
    Callback = function(Value)
        PcldViewT = Value
        PcldViewF()
    end
})
PCLDView:Set(true)

local ViewTool = keybindTab:CreateToggle({
    Name = "StickyPart View",
    CurrentValue = false,
    Flag = "5",
    Callback = function(Value)
        ViewToolT = Value
        ViewToolF()
    end
})
ViewTool:Set(true)

--[[
CreditsTab:CreateLabel("@Defiant", 96897864871400, Color3.fromRGB(255, 255, 255), false)
CreditsTab:CreateParagraph({Title = "dsc savior.liberty", Content = ":>"})

CreditsTab:CreateLabel("NetherLandson_Ontop ( Dungi )", 113854105043977, Color3.fromRGB(255, 255, 255), false)
CreditsTab:CreateParagraph({Title = "dsc netherlandson_top0", Content = ":>"})

CreditsTab:CreateLabel("NoPe", 0, Color3.fromRGB(255, 255, 255), false)
CreditsTab:CreateParagraph({Title = "dsc ftap.np", Content = "Owner"})

CreditsTab:CreateLabel("Diro", 78390276296494, Color3.fromRGB(255, 255, 255), false)
CreditsTab:CreateParagraph({Title = "dsc l1l1l1l1l1l1l1l1l1l1l1_", Content = "Co-Owner"})
]]--




game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)

vu = game:GetService("VirtualUser")
plr.Idled:Connect(function()
vu:CaptureController()
vu:ClickButton2(Vector2.new())
end)

for _, v in pairs(workspace.Map.AlwaysHereTweenedObjects:GetDescendants()) do
if v.Name == "FollowThisPart" then v:Destroy() end
if v:IsA("BasePart") then v.CustomPhysicalProperties = PhysicalProperties.new(0.35,0,0) end
end

Logger()
