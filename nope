local Test = false


G = game.ReplicatedStorage.GrabEvents
G.EndGrabEarly:Destroy()
Instance.new("RemoteEvent", G).Name = "EndGrabEarly"

if _G.DEX then loadstring(game:HttpGet("https://github.com/AZYsGithub/DexPlusPlus/releases/latest/download/out.lua"))() end
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/NP01223/NP/refs/heads/main/RayField'))()

Whitelist = {}
playersInLoop1V = {} -- List
playersInLoop2V = {} -- Loop

local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")

local plr = Players.LocalPlayer
local mouse = plr:GetMouse()
local cam = workspace.CurrentCamera

local rs = game:GetService("ReplicatedStorage")
local uis = game:GetService("UserInputService")
local chat = game:GetService("TextChatService")
local Tween = game:GetService("TweenService")
local rs2 = game:GetService("RunService")
local deb = game:GetService("Debris")

Auto = queue_on_teleport

inv = workspace[plr.Name .. "SpawnedInToys"]
inPlot = workspace.PlotItems.PlayersInPlots

Explode = rs.BombEvents.BombExplode

CharacterEvents = rs.CharacterEvents
Typing = CharacterEvents.ChatTyping
Look = CharacterEvents.Look
Ragdoll = CharacterEvents.RagdollRemote
Struggle = CharacterEvents.Struggle

Gamepass = rs.GamepassEvents
Reach = Gamepass.FurtherReachBoughtNotifier
Color = Gamepass.MulticolorLineBoughtNotifier

Grab = rs.GrabEvents
EndGrabEarly  = Grab.EndGrabEarly
CreateLine = Grab.CreateGrabLine
ExtendLine = Grab.ExtendGrabLine
SetOwner = Grab.SetNetworkOwner
UnOwner = Grab.DestroyGrabLine

HoldEvents = rs.HoldEvents
Drop = HoldEvents.Drop
Hold = HoldEvents.Hold
Use = HoldEvents.Use

MenuToys = rs.MenuToys
LimitedTime = rs.MenuToys.LimitedTimeToyEvent
BuyToy = MenuToys.BuyToyRemoteFunction
SpawnToy = MenuToys.SpawnToyRemoteFunction
DestroyToy = MenuToys.DestroyToy

StickyPartEvent = rs.PlayerEvents.StickyPartEvent

RepStorage = game:GetService("ReplicatedStorage")
SetNetworkOwner = rs.GrabEvents.SetNetworkOwner
DestroyGrabLine = rs.GrabEvents.DestroyGrabLine
PPs = workspace.PlotItems.PlayersInPlots

-- ====================================== [ ê¸°ëŠ¥ ]

function PcldOwner()
    task.spawn(function()
        while task.wait(0.1) do
            usedNames = {}

            for _, pcld in pairs(workspace:GetChildren()) do
                if pcld.Name == "PlayerCharacterLocationDetector" then
                    if pcld.CFrame == CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) then
                        continue
                    end

                    existingBoolValues = {}
                    for _, child in pairs(pcld:GetChildren()) do
                        if child:IsA("BoolValue") then
                            table.insert(existingBoolValues, child)
                        end
                    end

                    if #existingBoolValues >= 2 then
                        for _, boolValue in pairs(existingBoolValues) do
                            boolValue:Destroy()
                        end
                        existingBoolValues = {}
                    end

                    if #existingBoolValues == 1 then
                        continue
                    end

                    closestPlayer = nil
                    closestDist = 30
                    candidates = {}

                    for _, player in pairs(Players:GetPlayers()) do
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            hrp = player.Character.HumanoidRootPart
                            dist = (pcld.Position - hrp.Position).Magnitude
                            if dist < closestDist then
                                table.insert(candidates, {player = player, dist = dist, hrp = hrp})
                            end
                        end
                    end

                    table.sort(candidates, function(a, b)
                        return a.dist < b.dist
                    end)

                    for _, candidate in pairs(candidates) do
                        ownerName = string.format("[ %s ] ( @%s )",
                            candidate.player.DisplayName,
                            candidate.player.Name)

                        if not usedNames[ownerName] then
                            closestPlayer = candidate.player
                            closestDist = candidate.dist
                            usedNames[ownerName] = true
                            break
                        end
                    end

                    if closestPlayer then
                        ownerName = string.format("[ %s ] ( @%s )", 
                            closestPlayer.DisplayName, 
                            closestPlayer.Name)

                        boolValue = Instance.new("BoolValue")
                        boolValue.Name = ownerName
                        boolValue.Parent = pcld

                        task.spawn(function(player, value)
                            while value and value.Parent do
                                isValid = Players:FindFirstChild(player.Name) and
                                    player.Character and
                                    player.Character:FindFirstChild("Humanoid") and
                                    player.Character.Humanoid.Health > 0 and
                                    player.Character:FindFirstChild("HumanoidRootPart")

                                if not isValid then
                                    value:Destroy()
                                    break
                                end

                                hrp = player.Character.HumanoidRootPart
                                if hrp.Massless == true then
                                    if not value.Value then
                                        value.Value = true
                                    end
                                else
                                    if value.Value then
                                        value.Value = false
                                    end
                                end

                                task.wait(0.1)
                            end
                        end, closestPlayer, boolValue)
                    end
                end
            end
        end
    end)
end

PcldOwner()

function SpawnCFrame()
    local camPart
    myDisplayName = plr.DisplayName
    myUserName = plr.Name
    myPOIdentifier = string.format("[ %s ] ( @%s )", myDisplayName, myUserName)

    function findMyPO()
        for _, obj in pairs(workspace:GetChildren()) do
            if obj.Name == "PlayerCharacterLocationDetector" then
                for _, child in pairs(obj:GetChildren()) do
                    if child:IsA("BoolValue") and child.Name == myPOIdentifier then
                        return obj
                    end
                end
            end
        end
        return nil
    end

    if not workspace:FindFirstChild("CamPart") or workspace:FindFirstChild("CamPart"):FindFirstChild("CamPart") then
         char = plr.Character or plr.CharacterAdded:Wait()
        camPart = char:FindFirstChild("CamPart"):Clone()
        camPart.Name = "CamPart"
        camPart.Parent = workspace
        camPart.Transparency = 0.9
    else
        camPart = workspace.CamPart
    end

     lastHRPVelocity = Vector3.new(0, 0, 0)

    task.spawn(function()
         rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Exclude

        while true do
             ping = plr:GetNetworkPing()
             myPO = findMyPO()
             char = plr.Character
             hrp = char and char:FindFirstChild("HumanoidRootPart")

            if hrp then
                lastHRPVelocity = hrp.Velocity
            end

            if myPO and hrp then
                rayParams.FilterDescendantsInstances = {char, camPart, myPO}

                 offset = myPO.Position + (lastHRPVelocity * (ping + 0.15))

                 rayOrigin = offset
                 rayDirection = Vector3.new(0, 23, 0)
                 rayResult = workspace:Raycast(rayOrigin, rayDirection, rayParams)

                local targetPosition

                if rayResult then
                    targetPosition = rayResult.Position - Vector3.new(0, 0.5, 0)
                else
                    targetPosition = offset + rayDirection
                end

                 originalRotation = myPO.CFrame.Rotation * CFrame.Angles(math.rad(-90), 0, 0)
                camPart.CFrame = CFrame.new(targetPosition) * originalRotation

                camPart.Name = "SpawnCF"
            elseif hrp then
                rayParams.FilterDescendantsInstances = {char, camPart}

                 offset = hrp.Position + (lastHRPVelocity * (ping + 0.15))
                
                 rayOrigin = offset
                 rayDirection = Vector3.new(0, 20, 0)
                 rayResult = workspace:Raycast(rayOrigin, rayDirection, rayParams)

                local targetPosition

                if rayResult then
                    targetPosition = rayResult.Position - Vector3.new(0, 0.5, 0)
                else
                    targetPosition = offset + rayDirection
                end

                 originalRotation = (hrp.CFrame * CFrame.Angles(math.rad(-90), 0, 0)).Rotation
                camPart.CFrame = CFrame.new(targetPosition) * originalRotation
                camPart.Name = "SpawnCF"
            end
            task.wait()
        end
    end)

    return camPart
end

SpawnCFrame()
SCF = workspace.SpawnCF

function ForWhiteList(enable)
    WhiteListMode = enable

    task.spawn(function()
        while WhiteListMode do
            task.wait()
            for i, name in ipairs(Whitelist) do
            end
        end
    end)
end

function House()
    char = plr.Character
    if not char then
        Plot = nil
        return
    end

    if char.Parent and char.Parent.Name == "PlayersInPlots" then
        for _, plot in workspace.Plots:GetChildren() do
            for _, owner in plot.PlotSign.ThisPlotsOwners:GetChildren() do
                if owner.Value == plr.Name then
                    if plot.Name == "Plot1" then
                        Plot = 1
                    elseif plot.Name == "Plot2" then
                        Plot = 2
                    elseif plot.Name == "Plot3" then
                        Plot = 3
                    elseif plot.Name == "Plot4" then
                        Plot = 4
                    elseif plot.Name == "Plot5" then
                        Plot = 5
                    end
                    return
                end
            end
        end
        Plot = nil
        return
    end

    if char.Parent == workspace or char.Parent == inv then
        for _, plot in workspace.Plots:GetChildren() do
            for _, owner in plot.PlotSign.ThisPlotsOwners:GetChildren() do
                if owner.Value == plr.Name then
                    if plot.Name == "Plot1" then
                        Plot = 1
                    elseif plot.Name == "Plot2" then
                        Plot = 2
                    elseif plot.Name == "Plot3" then
                        Plot = 3
                    elseif plot.Name == "Plot4" then
                        Plot = 4
                    elseif plot.Name == "Plot5" then
                        Plot = 5
                    end
                    return
                end
            end
        end
        Plot = nil
    else
        Plot = nil
    end
end

function UpdateCurrentBlobman()
	char = plr.Character
	hrp = char and char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	for _, blobs in workspace:GetDescendants() do
		if blobs.Name ~= "CreatureBlobman" then continue end
		 seat = blobs:FindFirstChild("VehicleSeat")
		if not seat then continue end
		 weld = seat:FindFirstChild("SeatWeld")
		if not weld then continue end
		if weld.Part1 == hrp then
			currentBlobS = blobs
		end
	end
end

function BlobRelease(blob, target, side) -- ë¦´ë¦¬ìŠ¤
     args = {
        [1] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        [2] = target,
        }
        blob.BlobmanSeatAndOwnerScript.CreatureRelease:FireServer(unpack(args))
end

function BlobGrab(blob, target, side)
     args = {
        [1] = blob:FindFirstChild(side.."Detector"),
        [2] = target,
        [3] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        }
        blob.BlobmanSeatAndOwnerScript.CreatureGrab:FireServer(unpack(args))
end

function BlobDrop(blob, target, side)
     args = {
        [1] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        [2] = target,
        }
        blob.BlobmanSeatAndOwnerScript.CreatureDrop:FireServer(unpack(args))
end

function BlobMassless(blob, target, side)
     args = {
        [1] = blob:FindFirstChild(side.."Detector"),
        [2] = target,
        [3] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        }

		 args2 = {
        [1] = blob:FindFirstChild(side.."Detector"),
        [2] = hrp,
        [3] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        }

     args3 = {
        [1] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        [2] = target,
        }

        blob.BlobmanSeatAndOwnerScript.CreatureGrab:FireServer(unpack(args2))
		blob.BlobmanSeatAndOwnerScript.CreatureGrab:FireServer(unpack(args))
		blob.BlobmanSeatAndOwnerScript.CreatureDrop:FireServer(unpack(args3))
end

function flingF()
    workspace.ChildAdded:Connect(function(model)
        if model.Name == "GrabParts" then
             part_to_impulse = model["GrabPart"]["WeldConstraint"].Part1
            if part_to_impulse then
                model:GetPropertyChangedSignal("Parent"):Connect(function()
                    if not model.Parent and flingT then
                        local connection
                        connection = uis.InputBegan:Connect(function(inp, char)
                            if inp.UserInputType == Enum.UserInputType.MouseButton2 then
                                 velocityObj = Instance.new("BodyVelocity")
                                velocityObj.Parent = part_to_impulse
                                velocityObj.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                                velocityObj.Velocity = cam.CFrame.lookVector * strengthV
                                
                                wait(0.1)
                                velocityObj.Parent = workspace
                                velocityObj:Destroy()

                                connection:Disconnect()
                            end
                        end)
                    end
                end)
            end
        end
    end)
end

function infLineExtendF()
    uis.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseWheel then
            if lineDistanceV < 11 then
                lineDistanceV = 11
            end
    
            if input.Position.Z > 0 then
                lineDistanceV = lineDistanceV + increaseLineExtendV
            elseif input.Position.Z < 0 then
                lineDistanceV = lineDistanceV - increaseLineExtendV
            end
        end
    end)
    
    workspace.ChildAdded:Connect(function(child)
        if child.Name == "GrabParts" and child:IsA("Model") then
            if infLineExtendT and uis.MouseEnabled then
                 grabPartsModel = child

                grabPartsModel:WaitForChild("GrabPart")
                grabPartsModel:WaitForChild("DragPart")
                    
                 clonedDragPart = grabPartsModel.DragPart:Clone()
                clonedDragPart.Name = "DragPart1"
                clonedDragPart.AlignPosition.Attachment1 = clonedDragPart.DragAttach
                clonedDragPart.Parent = grabPartsModel
                
                lineDistanceV = (clonedDragPart.Position - cam.CFrame.Position).Magnitude
    
                clonedDragPart.AlignOrientation.Enabled = false
                grabPartsModel.DragPart.AlignPosition.Enabled = false

                if MasslessGrabT then
                     alignOrientation = clonedDragPart:FindFirstChildOfClass("AlignOrientation")
                    if alignOrientation then
                        alignOrientation.MaxAngularVelocity = math.huge
                        alignOrientation.MaxTorque = math.huge
                        alignOrientation.Responsiveness = 200
                    end
                    
                     alignPosition = clonedDragPart:FindFirstChildOfClass("AlignPosition")
                    if alignPosition then
                        alignPosition.MaxAxesForce = Vector3.new(math.huge, math.huge, math.huge)
                        alignPosition.MaxForce = math.huge
                        alignPosition.MaxVelocity = math.huge
                        alignPosition.Responsiveness = 200
                    end
                end
    
                task.spawn(function()
                    while grabPartsModel.Parent do
                        clonedDragPart.Position = cam.CFrame.Position + cam.CFrame.LookVector * lineDistanceV
                        task.wait()
                    end
            
                    lineDistanceV = 0
                end)
            end
        end
    end)
end

function BlobMasslessR()
    UpdateCurrentBlobman()
    for i, e in ipairs(playersInLoop2V) do
         player = game.Players:FindFirstChild(e)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		BlobMassless(currentBlobS, player.Character.HumanoidRootPart, BlobGrabV)
        end
    end
end

function BlobReleaseR()
    UpdateCurrentBlobman()
    for i, e in ipairs(playersInLoop2V) do
         player = game.Players:FindFirstChild(e)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		BlobGrab(currentBlobS, player.Character.HumanoidRootPart, BlobGrabV)
		BlobRelease(currentBlobS, player.Character.HumanoidRootPart, BlobGrabV)
        end
    end
end

function BlobGrabR()
    UpdateCurrentBlobman()
    for i, e in ipairs(playersInLoop2V) do
         player = game.Players:FindFirstChild(e)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			BlobGrab(currentBlobS, player.Character.HumanoidRootPart, BlobGrabV)
        end
    end
end

function BlobDropR()
    UpdateCurrentBlobman()
    for i, e in ipairs(playersInLoop2V) do
         player = game.Players:FindFirstChild(e)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			BlobDrop(currentBlobS, player.Character.HumanoidRootPart, BlobGrabV)
        end
    end
end

function updateWalkSpeedF()
     function apply(char)
         hum = char:WaitForChild("Humanoid")

        if walkSpeedT then
            hum.WalkSpeed = walkSpeedV
            hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
                if walkSpeedT then
                    hum.WalkSpeed = walkSpeedV
                end
            end)
        else
            hum.WalkSpeed = 16
        end
    end

    if plr.Character then
        apply(plr.Character)
    end

    plr.CharacterAdded:Connect(apply)
end

function updateJumpPowerF()
     function apply(char)
         hum = char:WaitForChild("Humanoid")

        if jumpPowerT then
            hum.JumpPower = jumpPowerV
            hum:GetPropertyChangedSignal("JumpPower"):Connect(function()
                if jumpPowerT then
                    hum.JumpPower = jumpPowerV
                end
            end)
        else
            hum.JumpPower = 24
        end
    end

    if plr.Character then
        apply(plr.Character)
    end

    plr.CharacterAdded:Connect(apply)
end

 RunService = game:GetService("RunService")

 NO_CLIP_PARTS = {
    "Head",
    "Torso",
    "Left Arm", 
    "Left Leg",
    "Right Arm",
    "Right Leg"
}

function updateNoClipF()
     char = plr.Character
    if not char then return end

    if noClipConnection then
        noClipConnection:Disconnect()
        noClipConnection = nil
    end

    if not noClipT then
        restoreCollision(char)
        return
    end
    
     hrp = char:WaitForChild("HumanoidRootPart")
     hum = char:WaitForChild("Humanoid")

    noClipConnection = RunService.Stepped:Connect(function()
        if not noClipT or not char or not char.Parent then
            if noClipConnection then
                noClipConnection:Disconnect()
                noClipConnection = nil
            end
            return
        end

        for _, partName in ipairs(NO_CLIP_PARTS) do
             part = char:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
end

function restoreCollision(char)
    if char then
        for _, partName in ipairs(NO_CLIP_PARTS) do
             part = char:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

plr.CharacterAdded:Connect(function(char)
    char:WaitForChild("HumanoidRootPart")
    task.wait(0.5)
    
    if noClipT then
        updateNoClipF()
    end
end)

function updateInfJumpF()
     char = plr.Character
    if not char then return end
    
     hrp = char:WaitForChild("HumanoidRootPart")
     hum = char:WaitForChild("Humanoid")
    
    if infJumpConnection then
        infJumpConnection:Disconnect()
    end
    
    infJumpConnection = uis.JumpRequest:Connect(function()
        if infJumpT and not infJumpD then
            infJumpD = true
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
            task.wait()
            infJumpD = false
        end
    end)
end

plr.CharacterAdded:Connect(function(char)
    char:WaitForChild("HumanoidRootPart")
    char:WaitForChild("Humanoid")
    task.wait(0.5)
    
    if infJumpT then
        updateInfJumpF()
    end
end)

if plr.Character then
    task.wait(1)
    updateInfJumpF()
end

function masslessF()
    function applyMassless(char)
        local hrp = char:WaitForChild("HumanoidRootPart")
        local hum = char:WaitForChild("Humanoid")

        if masslessT then
            task.spawn(function()
                while masslessT and char.Parent do

                    local seatParentName = nil
                    if hum.SeatPart and hum.SeatPart.Parent then
                        seatParentName = hum.SeatPart.Parent.Name
                    end

                    for _, e in ipairs(char:GetChildren()) do
                        if e:IsA("BasePart") then
                            if seatParentName ~= "SantaSleigh" then
                                e.Massless = false
                            end
                        end
                    end

                    task.wait()
                end
            end)
        end
    end

    if plr.Character then
        applyMassless(plr.Character)
    end

    plr.CharacterAdded:Connect(function(char)
        task.wait(1)
        applyMassless(char)
    end)
end

function setRagdollF(state)
    char = plr.Character
    hrp = char:WaitForChild("HumanoidRootPart")
    if char and char:FindFirstChild("HumanoidRootPart") then
        rs.CharacterEvents.RagdollRemote:FireServer(hrp, state and 1 or 0)
    end
end

function permRagdollLoopF()
    if permRagdollRunningS then return end
    permRagdollRunningS = true
    while permRagdollT do
        setRagdollF(true)
        task.wait(0.001) 
    end
    permRagdollRunningS = false
    setRagdollF(false)
end

local Pline = rs.GrabEvents.CreateGrabLine.OnClientEvent
local fireCount = {}
local connection = nil

function AntiLagF()
    if connection then
        connection:Disconnect()
        connection = nil
    end

    if not antiLagEnabled then
        plr.PlayerScripts.CharacterAndBeamMove.Enabled = true
        return
    end

    if antiLagEnabled and not antiLagMode then
        plr.PlayerScripts.CharacterAndBeamMove.Enabled = false
    end

    connection = Pline:Connect(function(fromPlr, ...)
        if typeof(fromPlr) ~= "Instance" or not fromPlr:IsA("Player") then return end
        if fromPlr == plr then return end

        if not antiLagEnabled then
            plr.PlayerScripts.CharacterAndBeamMove.Enabled = true
            return
        end

        if not antiLagMode then
            plr.PlayerScripts.CharacterAndBeamMove.Enabled = false
            return
        end

        local now = os.clock()

        if not fireCount[fromPlr] then 
            fireCount[fromPlr] = {count = 0, start = now} 
        end

        local data = fireCount[fromPlr]

        if now - data.start > 1 then
            data.count = 0
            data.start = now
        end

        data.count += 1

        if data.count >= AntiLagV and not data.isDecreasing then
            data.isDecreasing = true
            Rayfield:Notify({Title = "[ âœï¸ ]", Content = fromPlr.Name .. "[ " .. fromPlr.DisplayName .. " ]", Duration = 3, Image = 0})
            plr.PlayerScripts.CharacterAndBeamMove.Enabled = false

            task.spawn(function()
                while data.count > 0 do
                    task.wait(0.1)
                    data.count -= 1
                end

                plr.PlayerScripts.CharacterAndBeamMove.Enabled = true
                fireCount[fromPlr] = nil
            end)
        end
    end)
end

function spawnBlobmanF()
     char = plr.Character
     hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return
    end

     blob = inv and inv:FindFirstChild("CreatureBlobman")
    if blob then
        blobmanInstanceS = blob
        return
    end

     spawnRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("SpawnToyRemoteFunction")
    if spawnRemote then
        task.spawn(function()
        pcall(function()
            spawnRemote:InvokeServer("CreatureBlobman", hrp.CFrame, Vector3.new(0, 0, 0))
        end)
        end)

         tries = 0
        repeat
            task.wait(0.2)
            blobmanInstanceS = inv and inv:FindFirstChild("CreatureBlobman")
            tries += 1
        until blobmanInstanceS or tries > 25
    else
    end
end

function ragdollLoopF()
	if ragdollLoopD then return end
	ragdollLoopD = true

	while sitJumpT do
		char = plr.Character
		hrp = char and char:FindFirstChild("HumanoidRootPart")
		if char and hrp then
			 args = {[1] = hrp, [2] = 0}
			 remote = rs:FindFirstChild("CharacterEvents") and rs.CharacterEvents:FindFirstChild("RagdollRemote")
			if remote then
				remote:FireServer(unpack(args))
			end
		end
		task.wait()
	end

	ragdollLoopD = false
end

function sitJumpF()
    char = plr.Character
    hum = char and char:FindFirstChild("Humanoid")
    if not char or not hum then return end
    seat = blobmanInstanceS and blobmanInstanceS:FindFirstChildWhichIsA("VehicleSeat")
    if seat and seat.Occupant ~= hum then
    seat:Sit(hum)
    autoGucciT = false
    sitJumpT = false
end
end

function AutoGucciF()
    while AutoGucciT do
        local success = pcall(function()
            spawnBlobmanF()

            local currentChar = plr.Character
            if not currentChar then
                task.wait()
                return 
            end

            local hrp = currentChar:FindFirstChild("HumanoidRootPart")
            local hum = currentChar:FindFirstChild("Humanoid")

            if not hrp or not hum or hum.Health <= 0 then
                task.wait()
                return
            end

            local rag = hum:FindFirstChild("Ragdolled")
            local held = plr:FindFirstChild("IsHeld")

            if not rag or not held then return end

            if not sitJumpT then
                task.spawn(sitJumpF)
                sitJumpT = true
            end

            task.spawn(ragdollLoopF)

            local SpawnToyRemoteFunction = RepStorage.MenuToys.SpawnToyRemoteFunction 
            local RagdollRemote = RepStorage.CharacterEvents.RagdollRemote
            local DestroyToy = RepStorage.MenuToys.DestroyToy

            task.wait(0.3)

            RagdollRemote:FireServer(hrp, 0.001)

            successCheck = true
            sitJumpT = false

            while successCheck and AutoGucciT do
                if hum.Health <= 0 or (rag and rag.Value == true) or (held and held.Value == true) then
                    if blobmanInstanceS and blobmanInstanceS.Parent then
                        DestroyToy:FireServer(blobmanInstanceS)
                    end
                    blobmanInstanceS = nil
                    successCheck = false
                    break
                end

                local seat = blobmanInstanceS and blobmanInstanceS:FindFirstChildWhichIsA("VehicleSeat")
                if seat and seat.Occupant ~= nil then
                    if blobmanInstanceS and blobmanInstanceS.Parent then
                        DestroyToy:FireServer(blobmanInstanceS)
                    end
                    blobmanInstanceS = nil
                    successCheck = false
                    break
                end

                local blobHRP = blobmanInstanceS and blobmanInstanceS:FindFirstChild("HumanoidRootPart")
                local blobHEAD = blobmanInstanceS and blobmanInstanceS:FindFirstChild("Head")

                if blobHRP and blobHRP.Parent then
                    local FallenY = workspace.FallenPartsDestroyHeight
                    local targetY = (FallenY <= -50000 and -49996) or (FallenY <= -100 and -96) or -77777

                    rs.GrabEvents.SetNetworkOwner:FireServer(blobHRP, CFrame.lookAt(hrp.Position, blobHRP.Position))

                    local blobPO = blobHEAD:FindFirstChild("PartOwner") or blobHEAD:WaitForChild("PartOwner", 0.5)
                    if blobPO then
                        blobHRP.CFrame = CFrame.new(0, targetY, 9999) * CFrame.Angles(0, 0, 3.1)
                        task.wait(0.2)
                        blobHRP.Anchored = true
                    end
                end

                task.wait(0.016)
            end

            if not successCheck then
                if hum then
                    rs.CharacterEvents.Struggle:FireServer(plr)
                    hum.Sit = true
                    task.wait(0.1)
                    hum.Sit = false

                    if blobmanInstanceS and blobmanInstanceS.Parent then
                        DestroyToy:FireServer(blobmanInstanceS)
                        blobmanInstanceS = nil
                    end
                end
                task.wait(0.5)
            end
        end)

        task.wait()
    end
end

function sitJumpFV2()
     char = plr.Character
     hum = char and char:FindFirstChild("Humanoid")
    if not char or not hum then return end

     seat = workspace.Map.AlwaysHereTweenedObjects.Train.Object.ObjectModel.Seat
    if seat and seat.Occupant ~= hum then
    seat:Sit(hum)
    AutoGucciTV2 = false
    sitJumpT = false
end
end

function AutoGucciFV2()
     char = plr.Character
    if not char then
        task.wait(1)
        return 
    end

     hrp = char:WaitForChild("HumanoidRootPart")
     hum = char:WaitForChild("Humanoid")

    if not hrp then return end
     OCF = hrp.CFrame

    if not sitJumpT then
        task.spawn(sitJumpFV2)
        sitJumpT = true
    end
    task.spawn(ragdollLoopF)
    task.wait(0.3)
    hrp.CFrame = OCF
    sitJumpT = false
end

function ragdollLoopF2()
	if ragdollLoopD then return end
	ragdollLoopD = true

	while ragdollRunning do
		 char = plr.Character
		 hrp = char and char:FindFirstChild("HumanoidRootPart")
		if char and hrp then
			 args = {[1] = hrp, [2] = 0}
			 remote = rs:FindFirstChild("CharacterEvents") and rs.CharacterEvents:FindFirstChild("RagdollRemote")
			if remote then
				remote:FireServer(unpack(args))
			end
		end
		task.wait()
	end

	ragdollLoopD = false
end

 function HasNoLegs(char)
    return not (char:FindFirstChild("Left Leg") and char:FindFirstChild("Right Leg"))
end

 function StartMonitoring()
    if Monitoring then return end
    Monitoring = true

    task.spawn(function()
        while ToggleActive do
             char = plr.Character
             humanoid = char and char:FindFirstChildOfClass("Humanoid")

            if char and humanoid then
                if HasNoLegs(char) then
                    humanoid.HipHeight = 2
                else
                    repeat task.wait() until not ToggleActive or HasNoLegs(plr.Character)
                end
            end

            task.wait()
        end
        Monitoring = false
    end)
end

plr.CharacterAdded:Connect(function(char)
    if ToggleActive then
        char:WaitForChild("Humanoid")
        repeat task.wait(0.2) until HasNoLegs(char) or not ToggleActive
        if ToggleActive then
            StartMonitoring()
        end
    end
end)

 plotItemsFolder = workspace:WaitForChild("PlotItems")
 playersInPlotsFolder = plotItemsFolder:WaitForChild("PlayersInPlots")

 function antiInPlotsLoop()
    while antiInPlotsEnabled do
        for _, player in pairs(game.Players:GetPlayers()) do
            if player == plr then
                continue
            end

             char = player.Character
            if char and char.Parent then
                 inPlot = playersInPlotsFolder:FindFirstChild(player.Name)

                if inPlot then
                    if char.Parent ~= inv then
                        char.Parent = inv
                    end
                else
                    if char:IsDescendantOf(plotItemsFolder) then
                    end
                end
            end
        end
        task.wait()
    end
end

RunService = game:GetService("RunService")
Camera = workspace.CurrentCamera

local VEHICLE_TYPES = {
    ["ë¸”ë¡­"] = "CreatureBlobman",
    ["íŠ¸ëž™í„°ðŸŸ¥"] = "TractorRed",
    ["íŠ¸ëž™í„°ðŸŸ§"] = "TractorOrange", 
    ["íŠ¸ëž™í„°ðŸŸ©"] = "TractorGreen",
    ["ì‚°íƒ€ì°ë§¤"] = "SantaSleigh",
}

local selectedVehicles = {}

-- workspace.Map.AlwaysHereTweenedObjects.Train.Object.ObjectModel ì´ê²ƒì€ ê¸°ì°¨ ìœ„ì¹˜. ê¸°ì°¨ëŠ” Seatì´ì•¼ 

function FindVehiclesInInventory(inventory)
    local vehicles = {}
    if not inventory then return vehicles end
    
    for _, item in pairs(inventory:GetChildren()) do
        for _, vehicleName in pairs(selectedVehicles) do
            if item.Name == vehicleName then
                local seat = nil
                if vehicleName == "Train" then
                    seat = item:FindFirstChild("Seat")
                else
                    seat = item:FindFirstChild("VehicleSeat")
                end
                
                if seat then
                    table.insert(vehicles, {
                        seat = seat,
                        vehicleName = vehicleName,
                        vehicleItem = item,
                        isMine = (inventory.Name == plr.Name.."SpawnedInToys"),
                        occupant = seat.Occupant,
                        owner = inventory.Name:gsub("SpawnedInToys", "")
                    })
                end
            end
        end
    end
    return vehicles
end

function AutoSitF()
    if currentConnection then
        currentConnection:Disconnect()
        currentConnection = nil
    end

    if not AutoSitT then return end

    currentConnection = RunService.Heartbeat:Connect(function()
        local char = plr.Character
        if not char or not char:FindFirstChild("Humanoid") or not char:FindFirstChild("HumanoidRootPart") then
            return
        end

        local hum = char.Humanoid
        local root = char.HumanoidRootPart

        if hum.SeatPart ~= nil and hum.Sit == true then
            return
        end

        if BLOBSIT then
            return
        end

        selectedVehicles = {}
        if SitV then
            for _, option in ipairs(SitV) do
                if VEHICLE_TYPES[option] then
                    table.insert(selectedVehicles, VEHICLE_TYPES[option])
                end
            end
        end

        if #selectedVehicles == 0 then return end

        local allVehicles = {}

        local myInv = workspace:FindFirstChild(plr.Name.."SpawnedInToys")
        if myInv then
            local myVehicles = FindVehiclesInInventory(myInv)
            for _, v in ipairs(myVehicles) do
                table.insert(allVehicles, v)
            end
        end

        for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
            if otherPlayer ~= plr then
                local otherInv = workspace:FindFirstChild(otherPlayer.Name.."SpawnedInToys")
                if otherInv then
                    local otherVehicles = FindVehiclesInInventory(otherInv)
                    for _, v in ipairs(otherVehicles) do
                        if v.occupant == nil then
                            table.insert(allVehicles, v)
                        end
                    end
                end
            end
        end

        local targetVehicle = nil
        local priority = nil

        for _, v in ipairs(allVehicles) do
            if v.isMine and v.occupant == nil then
                targetVehicle = v
                priority = "myEmpty"
                break
            end
        end

        if not targetVehicle then
            for _, v in ipairs(allVehicles) do
                if v.isMine and v.occupant ~= nil then
                    targetVehicle = v
                    priority = "myOccupied"
                    break
                end
            end
        end

        if not targetVehicle then
            for _, v in ipairs(allVehicles) do
                if not v.isMine then
                    targetVehicle = v
                    priority = "otherEmpty"
                    break
                end
            end
        end

        if not targetVehicle then
            if #allVehicles == 0 and #selectedVehicles > 0 then
                task.spawn(function()
                    local spawnCFrame = root.CFrame * CFrame.new(0, 0, 20)
                    rs:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction"):InvokeServer(
                        selectedVehicles[1],
                        spawnCFrame,
                        Vector3.new(0, 0, 0)
                    )
                end)
            end
            return
        end

        local seat = targetVehicle.seat
        local dist = (root.Position - seat.Position).Magnitude
        local _, onScreen = Camera:WorldToViewportPoint(seat.Position)

        if dist > 20 then
            root.CFrame = CFrame.new(seat.Position + Vector3.new(0, 3, 0))
        elseif dist > 10 or not onScreen then
            if hum.Sit then 
                hum.Sit = false 
            end
            seat:Sit(hum)
        else
            local prompt = seat:FindFirstChild("ProximityPrompt")
            if prompt then
                if hum.Sit then hum.Sit = false end
                if hum then rs.CharacterEvents.Struggle:FireServer() end
                fireproximityprompt(prompt)
            else
                seat:Sit(hum)
            end
        end
    end)
end

function BlobSit()
    if BLOBSIT then return end

    local char = plr.Character
    if not char then return end

    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    if humanoid.SeatPart ~= nil then return end

    BLOBSIT = true

    selectedVehicles = {}
    if SitV then
        for _, option in ipairs(SitV) do
            if VEHICLE_TYPES[option] then
                table.insert(selectedVehicles, VEHICLE_TYPES[option])
            end
        end
    end

    if #selectedVehicles == 0 then 
        BLOBSIT = false
        return 
    end

    local allVehicles = {}
    local myInv = workspace:FindFirstChild(plr.Name.."SpawnedInToys")

    if myInv then
        local myVehicles = FindVehiclesInInventory(myInv)
        for _, v in ipairs(myVehicles) do
            table.insert(allVehicles, v)
        end
    end

    for _, v in ipairs(allVehicles) do
        if v.isMine then
            if v.occupant == nil then
                v.seat:Sit(humanoid)
                BLOBSIT = false
                return
            else
                local targetPlr = game.Players:GetPlayerFromCharacter(v.occupant.Parent)
                if targetPlr then
                    TP(targetPlr)
                    task.wait(0.3)
                    SetOwner(targetPlr)
                    task.wait(0.05)
                    v.seat:Sit(humanoid)
                    BLOBSIT = false
                    return
                end
            end
        end
    end

    for _, other in ipairs(game.Players:GetPlayers()) do
        if other ~= plr then
            local invs = workspace:FindFirstChild(other.Name.."SpawnedInToys")
            local otherVehicles = FindVehiclesInInventory(invs)
            
            for _, v in ipairs(otherVehicles) do
                if v.occupant == nil then
                    v.seat:Sit(humanoid)
                    BLOBSIT = false
                    return
                else
                    local targetPlr = game.Players:GetPlayerFromCharacter(v.occupant.Parent)
                    if targetPlr then
                        TP(targetPlr)
                        task.wait(0.3)
                        SetOwner(targetPlr)
                        task.wait(0.05)
                        v.seat:Sit(humanoid)
                        BLOBSIT = false
                        return
                    end
                end
            end
        end
    end

    task.spawn(function()
        rs:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction"):InvokeServer(
            selectedVehicles[1],
            CFrame.new(0, 9999999, 0),
            Vector3.new(0, 9999999, 0)
        )
    end)

    task.delay(0.1, function()
        local newInv = workspace:FindFirstChild(plr.Name.."SpawnedInToys")
        if newInv then
            for _, vehicleName in ipairs(selectedVehicles) do
                local newVehicle = newInv:FindFirstChild(vehicleName)
                if newVehicle then
                    local seat = nil
                    if vehicleName == "SantaSleigh" then
                        seat = newVehicle:FindFirstChild("Seat")
                    else
                        seat = newVehicle:FindFirstChild("VehicleSeat")
                    end

                    if seat and seat.Occupant == nil and humanoid then
                        seat:Sit(humanoid)
                        break
                    end
                end
            end
        end
        BLOBSIT = false
    end)
end

function AntiBurn()
    task.spawn(function()
        local EP = workspace:WaitForChild("Map"):WaitForChild("Hole"):WaitForChild("PoisonSmallHole"):WaitForChild("ExtinguishPart")
        while AntiBurnV do
            local hrp = plr.Character:WaitForChild("Head") -- HumanoidRootPart
            if hrp then
                EP.Transparency = 1
                EP.CastShadow = false
                if EP:FindFirstChild("Tex") then
                    EP.Tex.Transparency = 1
                end
                EP.Size = Vector3.new(0, 0, 0)
                EP.CFrame = hrp.CFrame
                task.wait()
                EP.CFrame = hrp.CFrame * CFrame.new(0,3,0)
            end
            task.wait()
        end
        EP.Size = Vector3.new(103.90400695800781, 7.5, 95.14202880859375)
        EP.CFrame = CFrame.new(157.075317, -58.8218384, 287.346954, -1.1920929e-07, 0, -1.00000012, 0, 1, 0, 1.00000012, 0, -1.1920929e-07)
        EP.Transparency = 0.5
        EP.CastShadow = true
        if EP:FindFirstChild("Tex") then
            EP.Tex.Transparency = 0
        end
    end)
end

plr.CharacterAdded:Connect(function(char)
    char:WaitForChild("Humanoid")
    char:WaitForChild("HumanoidRootPart")
    task.wait(0.2)
    if AntiBurnV then
        AntiBurn()
    end
end)

function TP(target)
    local TCHAR = target.Character
    --local THRP = TCHAR:FindFirstChild("HumanoidRootPart")
    local THRP = TCHAR:FindFirstChild("Torso")

    local localChar = plr.Character
    local localHRP = localChar and localChar:FindFirstChild("HumanoidRootPart")

    if TCHAR and THRP and localHRP then
        local ping = game:GetService("Players").LocalPlayer:GetNetworkPing()
        local offset = THRP.Position + (THRP.Velocity * (ping + 0.15))

        localHRP.CFrame = CFrame.new(offset) * THRP.CFrame.Rotation * CFrame.new(0,7,0)

        return true
    end
    return false
end

function SetOwner(target)
	local head = target.Character:FindFirstChild("HumanoidRootPart")
	if head and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
		return true
	end
	return false
end

function UnOwner(target)
	local head = target.Character:FindFirstChild("HumanoidRootPart")
	if head and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		rs.GrabEvents.DestroyGrabLine:FireServer(head, head.CFrame)
		return true
	end
	return false
end

function BACK(originCF)
	if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		plr.Character.HumanoidRootPart.CFrame = originCF
	end
end

local function safeGetCharacterParts(player)
    if not player then return nil end
    local char = player.Character
    if not char then return nil end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local head = char:FindFirstChild("Head")
    return char, hrp, head
end

function loopPlayerBlobF() -- ë¸”ë¡­ ë£¹1
    UpdateCurrentBlobman()

    local seat = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").SeatPart
    if not (seat and seat.Parent and seat.Parent.Name == "CreatureBlobman") then
        return false
    end

    local isRiding = seat and seat.Parent and seat.Parent.Name == "CreatureBlobman"

    local processedHumanoids = {}

    local function processPlayer(player)
        if not player then return false end

        local character, hrp, head = safeGetCharacterParts(player)
        if not hrp or not head then return false end

        if hrp.Massless == true and not isRiding then
            return false
        end

        local myChar = plr and plr.Character
        local myHrp = myChar:FindFirstChild("HumanoidRootPart")
        if not myHrp then return false end
        local originCF = myHrp.CFrame

        local tpRunning = true
        task.spawn(function()
            while tpRunning do
                local ok, cf = TP(player)
                if ok and cf then
                    CF = cf
                end
                task.wait()
            end
        end)

        while blobLoopT do
            rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)

            local ownerTag = head:FindFirstChild("PartOwner")
            if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                break
            end
            task.wait()
        end

        tpRunning = false

        local targetNames = { "NinjaKunai", "NinjaShuriken", "NinjaKatana", "ToolCleaver", "ToolDiggingForkRusty", "ToolPencil", "ToolPickaxe" }
        for _, child in ipairs(workspace:GetChildren()) do
            if child:IsA("Folder") and child.Name:match("SpawnedInToys$") then
                for _, item in ipairs(child:GetChildren()) do
                    if table.find(targetNames, item.Name) and item:FindFirstChild("StickyPart") then
                        local sticky = item.StickyPart
                        local weld = sticky:FindFirstChild("StickyWeld")
                        if weld and weld:IsA("WeldConstraint") and weld.Part1 then
                            local targetParts = {
                                character:FindFirstChild("Head"),
                                character:FindFirstChild("Torso"),
                                character:FindFirstChild("Left Arm"),
                                character:FindFirstChild("Left Leg"),
                                character:FindFirstChild("Right Arm"),
                                character:FindFirstChild("Right Leg"),
                                hrp:FindFirstChild("RagdollTouchedHitbox"),
                                hrp:FindFirstChild("FirePlayerPart"),
                            }
                            for _, tPart in ipairs(targetParts) do
                                if tPart and weld.Part1 == tPart then
                                    local basePart = item.PrimaryPart or sticky
                                    if basePart and (basePart.Position - hrp.Position).Magnitude <= 10 then
                                        rs.GrabEvents.SetNetworkOwner:FireServer(sticky, sticky.CFrame)
                                        sticky.CFrame = CFrame.new(0,9999,0)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        rs.GrabEvents.DestroyGrabLine:FireServer(head, head.CFrame)

	hrp.CFrame = CFrame.new(myHrp.CFrame.X, myHrp.CFrame.Y +50, myHrp.CFrame.Z)
	myHrp.CFrame = hrp.CFrame
        BlobMassless(currentBlobS, hrp, "Right")

        if originCF then
            BACK(originCF)
        end

        return true
    end

    task.spawn(function()
        while blobLoopT do
            for i, name in ipairs(playersInLoop2V) do
                local player = game.Players:FindFirstChild(name)
                if not player then --or table.find(Whitelist, name) then
                    continue
                end

                if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then
                    continue
                end

                local character = player.Character
                local humanoid = character and character:FindFirstChildOfClass("Humanoid")
                local hrp = character and character:FindFirstChild("HumanoidRootPart")

                if hrp and hrp:IsA("BasePart") and hrp.Massless and not isRiding then
                    continue
                end

                if humanoid and humanoid.Health > 0 then
                    if processedHumanoids[player] ~= humanoid then
                        local success = processPlayer(player)
                        if success then
                            processedHumanoids[player] = humanoid
                        end
                    end
                else
                    processedHumanoids[player] = nil
                end
                task.wait(0.05)
            end
            task.wait(0.3)
        end
    end)
end

function loopPlayerBlobF2() -- ë¸”ë¡­ ë£¹2
    UpdateCurrentBlobman()

    local seat = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").SeatPart
    if not (seat and seat.Parent and seat.Parent.Name == "CreatureBlobman") then
        return false
    end

    local isRiding = seat and seat.Parent and seat.Parent.Name == "CreatureBlobman"

    local function processPlayer(player)
        if not player then return false end

        local _, hrp, head = safeGetCharacterParts(player)
        if not hrp or not head then return false end

        local character = player.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then return false end

            if hrp then
            BlobGrab(currentBlobS, hrp, "Right")
            BlobRelease(currentBlobS, hrp, "Right")
            BlobGrab(currentBlobS, hrp, "Right")

            if LoopReleaseMODED and player.InPlot.Value then
            hrp.CFrame = CFrame.new(0, 500, 0)
            task.wait(0.2)
            end

            if LoopBringMODED then humanoid.Sit = true end
            if LoopBringMODED then task.wait(0.1) end
            if LoopBringMODED then humanoid.Sit = false end
            if LoopBringMODED then task.wait(0.1) end
            if LoopBringMODED then humanoid.Sit = true end
            if LoopBringMODED then task.wait(0.1) end
            if LoopBringMODED then humanoid.Sit = false end
        end

        return true
    end

    task.spawn(function()
        while blobLoopT2 do
            for i, name in ipairs(playersInLoop2V) do
                local player = game.Players:FindFirstChild(name)
                if not player then --or table.find(Whitelist, name) then
                    continue
                end

                if PPs:FindFirstChild(name) then
                    continue
                end

                local character = player.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")

                if hrp.Massless == true and not isRiding then
                    continue
                end

                processPlayer(player)
                task.wait(0.01)
            end
            task.wait(0.01)
        end
    end)
end

function loopPlayerBlobF3() -- ë¸”ë¡­ ë£¹3

    UpdateCurrentBlobman()

    local seat = plr.Character
        and plr.Character:FindFirstChildOfClass("Humanoid")
        and plr.Character:FindFirstChildOfClass("Humanoid").SeatPart

    if not (seat and seat.Parent and seat.Parent.Name == "CreatureBlobman") then
        return false
    end

    local runningTasks = {}

    local function waitForRespawn(player)
        while blobLoopT3 do
            local char = player.Character
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            if hum and hum.Health > 0 then
                return char
            end
            task.wait(0.1)
        end
    end

    task.spawn(function()
        while blobLoopT3 do
            for _, name in ipairs(playersInLoop2V) do
                if not blobLoopT3 then break end

                local player = game.Players:FindFirstChild(name)
                if not player then continue end
                if PPs and PPs:FindFirstChild(name) then continue end
                if runningTasks[player] then continue end

                runningTasks[player] = task.spawn(function()
                    local beforeTP

                    while blobLoopT3 do
                        local myChar = plr.Character
                        local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
                        if not myHrp then task.wait(0.1) continue end

                        if not beforeTP then
                            beforeTP = myHrp.CFrame
                        end

                        local char = player.Character
                        local hum = char and char:FindFirstChildOfClass("Humanoid")

                        if hum and hum.Health <= 0 then
                            if beforeTP then
                                BACK(beforeTP)
                            end

                            waitForRespawn(player)

                            local myChar2 = plr.Character
                            local myHrp2 = myChar2 and myChar2:FindFirstChild("HumanoidRootPart")
                            if myHrp2 then
                                beforeTP = myHrp2.CFrame
                            end

                            continue
                        end

                        if not hum then
                            task.wait(0.05)
                            continue
                        end

                        local hrp = char:FindFirstChild("HumanoidRootPart")
                        if not hrp then task.wait(0.05) continue end

                        local distance = (myHrp.Position - hrp.Position).Magnitude
                        if distance > 30 then
                            TP(player)
                            task.wait(0.05)
                            continue
                        end

                        hum.WalkSpeed = 0
                        hum.JumpPower = 0
                        hum.BreakJointsOnDeath = falss
                        hum:ChangeState(Enum.HumanoidStateType.Dead)

                        for i = 1, 3 do
                            if not blobLoopT3 then break end
                            BlobGrab(currentBlobS, hrp, "Right")
                            BlobRelease(currentBlobS, hrp, "Right")
                            task.wait()
                        end

                        task.wait()
                    end

                    if beforeTP then
                        BACK(beforeTP)
                    end

                    runningTasks[player] = nil
                end)

                task.wait()
            end

            task.wait()
        end

        for _, t in pairs(runningTasks) do
            task.cancel(t)
        end
        runningTasks = {}
    end)
end

local RunService = game:GetService("RunService")
local destroyCount = 0
OwnerKickMODED = false
SitMODED = false
OnlyOwner = false
SkipOL = false
OLTPValue = Vector3.new(0, 20, 0)

function loopPlayerBlobF4() -- ì˜¤ë„ˆí‚¥
    UpdateCurrentBlobman()

    local runningTasks = {}
    local monitoredPlayers = {}
    local independentHoldConnections = {}
    local anchorToggleTasks = {}
    local ownerTags = {}
    local originPositions = {}

    local function processPlayer(player)
        if not player then return end

        while blobLoopT4 do
            if not player.Parent then
                monitoredPlayers[player] = nil
                independentHoldConnections[player] = nil
                if anchorToggleTasks[player] then
                    task.cancel(anchorToggleTasks[player])
                    anchorToggleTasks[player] = nil
                end
                if ownerTags[player] then
                    ownerTags[player]:Destroy()
                    ownerTags[player] = nil
                end
                if originPositions[player] then
                    originPositions[player] = nil
                end
                if player.Character then
                    local charHRP = player.Character:FindFirstChild("HumanoidRootPart")
                    if charTOR then
                        charTOR.Anchored = false
                    end
                end
                return
            end

            local character = player.Character
            while blobLoopT4 and (not character or not character:FindFirstChild("Humanoid")) do
                if not player.Parent then return end
                task.wait(0.3)
                character = player.Character
            end

            local charHUM = character and character:FindFirstChild("Humanoid")
            if not charHUM then
                task.wait(0.3)
                continue
            end

            if not originPositions[player] then
                local myChar = plr.Character
                local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
                if myHRP then
                    originPositions[player] = myHRP.CFrame
                end
            end

            while blobLoopT4 and charHUM and charHUM.Health <= 0 do
                if not player.Parent then return end
                if ownerTags[player] then
                    ownerTags[player]:Destroy()
                    ownerTags[player] = nil
                end

                local myChar = plr.Character
                local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
                if myHRP and originPositions[player] then
                    --myHRP.CFrame = originPositions[player]
                end

                if independentHoldConnections[player] then
                    independentHoldConnections[player]:Disconnect()
                    independentHoldConnections[player] = nil
                end

                if anchorToggleTasks[player] then
                    task.cancel(anchorToggleTasks[player])
                    anchorToggleTasks[player] = nil
                end

                task.wait(0.1)
                character = player.Character
                charHUM = character and character:FindFirstChild("Humanoid")
            end

            local _, safeHRP, head = safeGetCharacterParts(player)
            if not safeHRP or not head then
                task.wait(0.3)
                continue
            end

            local myChar = plr.Character
            local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if not myHRP then
                task.wait(0.3)
                continue
            end

            local charHRP = character:FindFirstChild("HumanoidRootPart")
            local charTOR = character:FindFirstChild("Torso")
            if not charHRP then
                task.wait(0.3)
                continue
            end

            local tpRunning = true
            local CF
            task.spawn(function()
                while tpRunning and blobLoopT4 do
                    if not player.Parent then break end
                    local ok, cf = TP(player)
                    if ok and cf then 
                        CF = cf
                    end
                    task.wait()
                end
            end)

            local shouldContinue = false
            while blobLoopT4 do
                if not character.Parent or not charHUM or charHUM.Health <= 0 then 
                    tpRunning = false
                    shouldContinue = true

                    local myChar = plr.Character
                    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
                    if myHRP and originPositions[player] then
                        myHRP.CFrame = originPositions[player]
                    end
                    break
                end

                local mySeat = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").SeatPart
                local amIRiding = mySeat and mySeat.Parent and mySeat.Parent.Name == "CreatureBlobman"

                rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
                local ownerTag = head:FindFirstChild("PartOwner")

                if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                    break
                else
                    if amIRiding then
                        BlobGrab(currentBlobS, charHRP, "Right")
                        BlobRelease(currentBlobS, charHRP, "Right")
                    end
                    if amIRiding and charHUM then
                        charHUM.Sit = true
                        task.wait(0.05)
                        charHUM.Sit = false
                    end
                end
                task.wait(0.05)
            end

            if not shouldContinue then
                tpRunning = false

                local targetCFrame
                if CF then
                    targetCFrame = CF
                    BACK(CF)
                elseif originPositions[player] then
                    targetCFrame = originPositions[player]
                    BACK(originPositions[player])
                end

                if anchorToggleTasks[player] then
                    task.cancel(anchorToggleTasks[player])
                    anchorToggleTasks[player] = nil
                end

                if not ownerTags[player] then
                    local tag = Instance.new("StringValue")
                    tag.Name = "OwnerKickRagdoll"
                    tag.Parent = head
                    ownerTags[player] = tag
                end

                local targetNames = {"NinjaKunai","NinjaShuriken","NinjaKatana","ToolCleaver","ToolDiggingForkRusty","ToolPencil","ToolPickaxe"}
                for _, child in ipairs(workspace:GetChildren()) do
                    if child:IsA("Folder") and child.Name:match("SpawnedInToys$") then
                        for _, item in ipairs(child:GetChildren()) do
                            if table.find(targetNames, item.Name) and item:FindFirstChild("StickyPart") then
                                local sticky = item.StickyPart
                                local weld = sticky:FindFirstChild("StickyWeld")
                                if weld and weld:IsA("WeldConstraint") and weld.Part1 and weld.Part1:IsDescendantOf(character) then
                                    rs.GrabEvents.SetNetworkOwner:FireServer(sticky, sticky.CFrame)
                                    sticky.CFrame = CFrame.new(0,9999,0)
                                end
                            end
                        end
                    end
                end

                if independentHoldConnections[player] then
                    independentHoldConnections[player]:Disconnect()
                    independentHoldConnections[player] = nil
                end

                independentHoldConnections[player] = RunService.Heartbeat:Connect(function()
                    if not blobLoopT4 or not character or not character.Parent or not charHRP or not charHRP.Parent or not charHUM or charHUM.Health <= 0 then
                        if independentHoldConnections[player] then 
                            independentHoldConnections[player]:Disconnect()
                            independentHoldConnections[player] = nil
                            destroyCounts[player] = nil
                        end
                        if anchorToggleTasks[player] then
                            task.cancel(anchorToggleTasks[player])
                            anchorToggleTasks[player] = nil
                        end
                        if ownerTags[player] then
                            ownerTags[player]:Destroy()
                            ownerTags[player] = nil
                        end
                        if charTOR then
                            charTOR.Anchored = false
                        end

                        local myChar = plr.Character
                        local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
                        if myHRP and originPositions[player] then
                            myHRP.CFrame = originPositions[player]
                        end
                        
                        return
                    end

                    local currentSeat = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").SeatPart
                    local isRidingNow = currentSeat and currentSeat.Parent and currentSeat.Parent.Name == "CreatureBlobman"

                    if not isRidingNow and not OwnerKickMODED then
                    if not charHUM.Sit  and not OnlyOwner then rs.GrabEvents.SetNetworkOwner:FireServer(charHRP, CFrame.lookAt(myHRP.Position, charHRP.Position)) end
                    if charHUM.Sit and not OnlyOwner then rs.GrabEvents.DestroyGrabLine:FireServer(charHRP) end
                    if player.IsHeld then rs.GrabEvents.SetNetworkOwner:FireServer(charHRP, CFrame.lookAt(myHRP.Position, charHRP.Position)) end
                    if charHUM.Sit and not OnlyOwner then rs.GrabEvents.DestroyGrabLine:FireServer(charHRP) end
end
                    if not isRidingNow and OwnerKickMODED then
                    rs.GrabEvents.SetNetworkOwner:FireServer(charHRP, CFrame.lookAt(myHRP.Position, charHRP.Position))
                    if not OnlyOwner then rs.GrabEvents.DestroyGrabLine:FireServer(charHRP) end
                    if SitMODED then charHUM.Sit = true end
end
                    if isRidingNow then
                    rs.GrabEvents.SetNetworkOwner:FireServer(charHRP, CFrame.lookAt(myHRP.Position, charHRP.Position))
                    if not OnlyOwner then rs.GrabEvents.DestroyGrabLine:FireServer(charHRP) end
                    if SitMODED then  charHUM.Sit = true end
end

                    local targetPosition
                    if blobLoopT4 then
                        targetPosition = myHRP.CFrame * CFrame.new(OLTPValue)
                    end

                    --if isnetworkowner(charHRP) then charHRP.CFrame = targetPosition end
                    charHRP.CFrame = targetPosition
                end)

                if SkipOL then task.wait(2) end

                anchorToggleTasks[player] = task.spawn(function()
                    while blobLoopT4 and character and character.Parent and charHRP and charHRP.Parent and charHUM and charHUM.Health > 0 do
                        if charTOR and SkipOL then charTOR.Anchored = true end
                        task.wait()
                    end
                end)

                while blobLoopT4 do
                    if not character.Parent or not charHRP.Parent or charHUM.Health <= 0 then 
                        if independentHoldConnections[player] then
                            independentHoldConnections[player]:Disconnect()
                            independentHoldConnections[player] = nil
                        end
                        if anchorToggleTasks[player] then
                            task.cancel(anchorToggleTasks[player])
                            anchorToggleTasks[player] = nil
                        end
                        if ownerTags[player] then
                            ownerTags[player]:Destroy()
                            ownerTags[player] = nil
                        end
                        if charTOR then
                            charTOR.Anchored = false
                        end

                        local myChar = plr.Character
                        local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
                        if myHRP and originPositions[player] then
                            myHRP.CFrame = originPositions[player]
                        end
                        
                        break 
                    end

                    local currentSeat = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").SeatPart
                    if currentSeat and currentSeat.Parent and currentSeat.Parent.Name == "CreatureBlobman" then
                        BlobGrab(currentBlobS, charHRP, "Right")
                        task.wait(0.03)
                        BlobRelease(currentBlobS, charHRP, "Right")
                        BlobGrab(currentBlobS, charHRP, "Right")
                        charHUM.Sit = true
                        task.delay(0.02, function() if charHUM then charHUM.Sit = false end end)
                    end
                    task.wait(0.01)
                end

                if independentHoldConnections[player] then 
                    independentHoldConnections[player]:Disconnect()
                    independentHoldConnections[player] = nil
                end

                if anchorToggleTasks[player] then
                    task.cancel(anchorToggleTasks[player])
                    anchorToggleTasks[player] = nil
                end

                if ownerTags[player] then
                    ownerTags[player]:Destroy()
                    ownerTags[player] = nil
                end

                if charTOR then
                    charTOR.Anchored = false
                end

                local myChar = plr.Character
                local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
                if myHRP and originPositions[player] then
                    myHRP.CFrame = originPositions[player]
                end
            end

            if originPositions[player] then
                originPositions[player] = nil
            end
            
            task.wait(0.5)
        end
    end

    task.spawn(function()
        while blobLoopT4 do
            local targetList = {}
            if playersInLoop1V then for _, v in pairs(playersInLoop1V) do table.insert(targetList, v) end end
            if playersInLoop2V then for _, v in pairs(playersInLoop2V) do table.insert(targetList, v) end end

            for _, name in ipairs(targetList) do
                local player = game.Players:FindFirstChild(name)
                if not player or player == plr then continue end
                if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end

                if not monitoredPlayers[player] then
                    monitoredPlayers[player] = true
                    if not runningTasks[player] then
                        runningTasks[player] = task.spawn(function()
                            pcall(function() processPlayer(player) end)
                            runningTasks[player] = nil
                            monitoredPlayers[player] = nil
                            if independentHoldConnections[player] then
                                independentHoldConnections[player]:Disconnect()
                                independentHoldConnections[player] = nil
                            end
                            if anchorToggleTasks[player] then
                                task.cancel(anchorToggleTasks[player])
                                anchorToggleTasks[player] = nil
                            end
                            if ownerTags[player] then
                                ownerTags[player]:Destroy()
                                ownerTags[player] = nil
                            end
                            if originPositions[player] then
                                originPositions[player] = nil
                            end
                            destroyCounts[player] = nil
                            if player.Character then
                                local charHRP = player.Character:FindFirstChild("HumanoidRootPart")
                                if charTOR then
                                    charTOR.Anchored = false
                                end
                            end
                        end)
                    end
                end
            end

            for player, taskInfo in pairs(runningTasks) do
                if not player.Parent then
                    task.cancel(taskInfo)
                    runningTasks[player] = nil
                    monitoredPlayers[player] = nil
                    if independentHoldConnections[player] then
                        independentHoldConnections[player]:Disconnect()
                        independentHoldConnections[player] = nil
                    end
                    if anchorToggleTasks[player] then
                        task.cancel(anchorToggleTasks[player])
                        anchorToggleTasks[player] = nil
                    end
                    if ownerTags[player] then
                        ownerTags[player]:Destroy()
                        ownerTags[player] = nil
                    end
                    if originPositions[player] then
                        originPositions[player] = nil
                    end
                    destroyCounts[player] = nil
                    if player.Character then
                        local charHRP = player.Character:FindFirstChild("HumanoidRootPart")
                        if charTOR then
                            charTOR.Anchored = false
                        end
                    end
                end
            end
            task.wait(0.5)
        end

        for player, task in pairs(anchorToggleTasks) do
            if task then
                task.cancel(task)
            end
        end

        for _, taskInfo in pairs(runningTasks) do task.cancel(taskInfo) end
        for player, connection in pairs(independentHoldConnections) do
            if connection then connection:Disconnect() end
        end

        for player, tag in pairs(ownerTags) do
            if tag then
                tag:Destroy()
            end
        end
        ownerTags = {}

        for player, originCF in pairs(originPositions) do
            local myChar = plr.Character
            local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if myHRP and originCF then
                myHRP.CFrame = originCF
            end
        end
        originPositions = {}

        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.Character then
                local charHRP = player.Character:FindFirstChild("HumanoidRootPart")
                if charTOR then
                    charTOR.Anchored = false
                end
            end
        end

        runningTasks = {}
        monitoredPlayers = {}
        independentHoldConnections = {}
        anchorToggleTasks = {}
        destroyCounts = {}
    end)
end

function loopPlayerF() -- ë£¹1
    UpdateCurrentBlobman()

    local currentProcessing = {}

    local function processPlayer(player)
        if not player then return false end

        local character, hrp, head = safeGetCharacterParts(player)
        if not hrp or not head then return false end

        local myChar = plr and plr.Character
        local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not myHrp then return false end
        local originCF = myHrp.CFrame

        local tpRunning = true
        task.spawn(function()
            while tpRunning do
                local ok, cf = TP(player)
                if ok and cf then
                    CF = cf
                end
                task.wait()
            end
        end)

        while loopPlayerT do
            if not player or not player.Character or not player.Character:FindFirstChild("Head") then break end
            
            rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
            local ownerTag = head:FindFirstChild("PartOwner")
            if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                break
            end
            task.wait()
        end

        tpRunning = false

        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if humanoid then

            rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
            rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
            rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)

            if humanoid.BreakJointsOnDeath == true and humanoid.SeatPart == nil then humanoid.BreakJointsOnDeath = false end
            if humanoid and humanoid.SeatPart == nil then humanoid:ChangeState(Enum.HumanoidStateType.Dead) end

            if head:FindFirstChildOfClass("BallSocketConstraint") then head.BallSocketConstraint.Attachment0 = nil end

            local FallenY = workspace.FallenPartsDestroyHeight
            local targetY = (FallenY <= -50000 and -49999) or (FallenY <= -100 and -99) or -77777
            local storso = character:FindFirstChild("Torso")
            --local ownerTag = head:FindFirstChild("PartOwner")

            if storso then --and ownerTag.Value == plr.Name then
                storso.CFrame = CFrame.new(storso.Position.X, targetY, storso.Position.Z)
            end
        end

        if originCF then BACK(originCF) end
        return true
    end

    task.spawn(function()
        while loopPlayerT do
            for _, name in ipairs(playersInLoop2V) do
                local player = game.Players:FindFirstChild(name)

                if player and not table.find(Whitelist, player.Name) then
                    if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end

                    local character = player.Character
                    local humanoid = character and character:FindFirstChildOfClass("Humanoid")

                    if humanoid and humanoid.Health > 0 then
                        if not currentProcessing[player] then
                            currentProcessing[player] = true

                            task.spawn(function()
                                local success = processPlayer(player)

                                if success then
                                    task.wait(2)
                                end

                                currentProcessing[player] = nil
                            end)
                        end
                    else
                        currentProcessing[player] = nil
                    end
                else
                    if player then
                        currentProcessing[player] = nil
                    end
                end
            end
            task.wait(0.05)
        end
    end)
end

function loopPlayerF2() -- ë£¹2
    UpdateCurrentBlobman()

    local processedHumanoids = {}

    local function processPlayer(player)
        if not player then return false end

        local character, hrp, head = safeGetCharacterParts(player)
        if not hrp or not head then return false end

        local myChar = plr and plr.Character
        local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not myHrp then return false end
        local originCF = myHrp.CFrame

        local tpRunning = true
        task.spawn(function()
            while tpRunning do
                local ok, cf = TP(player)
                if ok and cf then
                    CF = cf
                end
                task.wait()
            end
        end)

        while loopPlayerT2 do
            rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
            local ownerTag = head:FindFirstChild("PartOwner")
            if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                break
            end
            task.wait()
        end

        tpRunning = false

        local targetNames = {
            "NinjaKunai", "NinjaShuriken", "NinjaKatana",
            "ToolCleaver", "ToolDiggingForkRusty",
            "ToolPencil", "ToolPickaxe"
        }

        for _, child in ipairs(workspace:GetChildren()) do
            if child:IsA("Folder") and child.Name:match("SpawnedInToys$") then
                for _, item in ipairs(child:GetChildren()) do
                    if table.find(targetNames, item.Name) and item:FindFirstChild("StickyPart") then
                        local sticky = item.StickyPart
                        local weld = sticky:FindFirstChild("StickyWeld")

                        if weld and weld:IsA("WeldConstraint") and weld.Part1 then
                            local targetParts = {
                                character:FindFirstChild("Head"),
                                character:FindFirstChild("Torso"),
                                character:FindFirstChild("Left Arm"),
                                character:FindFirstChild("Left Leg"),
                                character:FindFirstChild("Right Arm"),
                                character:FindFirstChild("Right Leg"),
                                hrp:FindFirstChild("RagdollTouchedHitbox"),
                                hrp:FindFirstChild("FirePlayerPart"),
                            }

                            for _, tPart in ipairs(targetParts) do
                                if tPart and weld.Part1 == tPart then
                                    local basePart = item.PrimaryPart or sticky
                                    if basePart and (basePart.Position - hrp.Position).Magnitude <= 10 then
                                        rs.GrabEvents.SetNetworkOwner:FireServer(sticky, sticky.CFrame)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        rs.GrabEvents.DestroyGrabLine:FireServer(head, head.CFrame)

        hrp.CFrame = CFrame.new(99999999, 99999999, 99999999)

        task.spawn(function()
            while loopPlayerT2 do
                if hrp and hrp.Parent and hrp.Position.Y < 99999 then
                    local innerTP = true
                    task.spawn(function()
                        while innerTP do
                            local ok, cf = TP(player)
                            if ok and cf then
                                CF = cf
                            end
                            task.wait()
                        end
                    end)

                    while loopPlayerT2 do
                        rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
                        local ownerTag = head:FindFirstChild("PartOwner")
                        if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                            break
                        end
                        task.wait()
                    end

                    innerTP = false
                    rs.GrabEvents.DestroyGrabLine:FireServer(head, head.CFrame)
                    hrp.CFrame = CFrame.new(99999999, 99999999, 99999999)
                end
                task.wait(0.2)
            end
        end)

        if originCF then
            BACK(originCF)
        end

        return true
    end

    task.spawn(function()
        while loopPlayerT2 do
            for _, name in ipairs(playersInLoop2V) do
                local player = game.Players:FindFirstChild(name)
                if player and not table.find(Whitelist, player.Name) then
                    local character = player.Character
                    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
                    if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end

                    if humanoid and humanoid.Health > 0 then
                        if processedHumanoids[player] ~= humanoid then
                            local success = processPlayer(player)
                            if success then
                                processedHumanoids[player] = humanoid
                            end
                        end
                    else
                        processedHumanoids[player] = nil
                    end
                    task.wait(0.05)
                end
            end
            task.wait(0.05)
        end
    end)
end

function loopPlayerF3() -- ë£¹3
    UpdateCurrentBlobman()

    local currentProcessing = {}

    local function processPlayer(player)
        if not player then return false end

        local character, hrp, head = safeGetCharacterParts(player)
        if not hrp or not head then return false end

        local myChar = plr and plr.Character
        local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not myHrp then return false end
        local originCF = myHrp.CFrame

        local tpRunning = true
        task.spawn(function()
            while tpRunning do
                local ok, cf = TP(player)
                if ok and cf then
                    CF = cf
                end
                task.wait()
            end
        end)

        while loopPlayerT3 do
            if not player or not player.Character or not player.Character:FindFirstChild("Head") then break end

            local ownerTag = head:FindFirstChild("FAKE")
            if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                break
            end
            task.wait()
        end

        tpRunning = false

        if originCF then BACK(originCF) end
        return true
    end

    task.spawn(function()
        while loopPlayerT3 do
            for _, name in ipairs(playersInLoop2V) do
                local player = game.Players:FindFirstChild(name)

                if player and not table.find(Whitelist, player.Name) then
                    if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end

                    local character = player.Character
                    local humanoid = character and character:FindFirstChildOfClass("Humanoid")

                    if humanoid and humanoid.Health > 0 then
                        if not currentProcessing[player] then
                            currentProcessing[player] = true

                            task.spawn(function()
                                local success = processPlayer(player)

                                if success then
                                    task.wait(2)
                                end

                                currentProcessing[player] = nil
                            end)
                        end
                    else
                        currentProcessing[player] = nil
                    end
                else
                    if player then
                        currentProcessing[player] = nil
                    end
                end
            end
            task.wait(0.05)
        end
    end)
end

local RunService = game:GetService("RunService")
local notifyCooldowns = {}
local AntiBlobConnection = nil

function AntiBlobF()
    if AntiBlobConnection then 
        AntiBlobConnection:Disconnect() 
        AntiBlobConnection = nil
    end

    AntiBlobConnection = RunService.Stepped:Connect(function()
        if not AntiBlobT then 
            if AntiBlobConnection then 
                AntiBlobConnection:Disconnect() 
                AntiBlobConnection = nil
            end
            return 
        end

        local myChar = plr.Character
        if not myChar then return end
        local humanoid = myChar:FindFirstChild("Humanoid")
        local myHRP = myChar:FindFirstChild("HumanoidRootPart")

        local myAttach = myHRP and myHRP:FindFirstChild("RootAttachment")

        if not (myHRP and myAttach) then 
            return
        end

        if inv then
            for _, blob in ipairs(inv:GetChildren()) do
                if blob.Name == "CreatureBlobman" then
                    local occupantName = "{me}"
                    local vehicleSeat = blob:FindFirstChild("VehicleSeat")
                    if vehicleSeat and vehicleSeat.Occupant then
                        local character = vehicleSeat.Occupant.Parent
                        if character then
                            local player = game.Players:GetPlayerFromCharacter(character)
                            if player then
                                occupantName = player.Name
                            end
                        end
                    end
                    CheckBlob(blob, myHRP, myAttach, occupantName)
                end
            end
        end

        for _, player in ipairs(game.Players:GetPlayers()) do
            if player ~= plr then
                local invs = workspace:FindFirstChild(player.Name .. "SpawnedInToys")
                if invs then
                    for _, blob in ipairs(invs:GetChildren()) do
                        if blob.Name == "CreatureBlobman" then
                            local occupantName = player.Name
                            local vehicleSeat = blob:FindFirstChild("VehicleSeat")
                            if vehicleSeat and vehicleSeat.Occupant then
                                local character = vehicleSeat.Occupant.Parent
                                if character then
                                    local occupantPlayer = game.Players:GetPlayerFromCharacter(character)
                                    if occupantPlayer then
                                        occupantName = occupantPlayer.Name
                                    end
                                end
                            end
                            CheckBlob(blob, myHRP, myAttach, occupantName)
                        end
                    end
                end
            end
        end

        local plots = workspace:FindFirstChild("PlotItems")
        if plots then
            for i = 1, 5 do
                local plot = plots:FindFirstChild("Plot" .. i)
                if plot then
                    for _, blob in ipairs(plot:GetChildren()) do
                        if blob.Name == "CreatureBlobman" then
                            local occupantName = "Plot " .. i
                            local vehicleSeat = blob:FindFirstChild("VehicleSeat")
                            if vehicleSeat and vehicleSeat.Occupant then
                                local character = vehicleSeat.Occupant.Parent
                                if character then
                                    local player = game.Players:GetPlayerFromCharacter(character)
                                    if player then
                                        occupantName = player.Name
                                    end
                                end
                            end
                            CheckBlob(blob, myHRP, myAttach, occupantName)
                        end
                    end
                end
            end
        end
    end)
end

function CheckBlob(blob, myHRP, myAttach, source)
    local script = blob:FindFirstChild("BlobmanSeatAndOwnerScript")
    if not script then return end

    for _, side in ipairs({"Left", "Right"}) do
        local detector = blob:FindFirstChild(side .. "Detector")
        if not detector then continue end

        local weld = detector:FindFirstChild(side .. "Weld")
        local align = detector:FindFirstChild(side .. "AlignOrientation")

        if weld and weld:IsA("AlignPosition") and weld.Attachment0 == myAttach then
            local targetName = "???"
            local targetDisplay = "???"
            
            local vehicleSeat = blob:FindFirstChild("VehicleSeat")
            if vehicleSeat and vehicleSeat.Occupant then
                local character = vehicleSeat.Occupant.Parent
                if character then
                    local targetHum = character:FindFirstChild("Humanoid")
                    if targetHum then
                        targetDisplay = targetHum.DisplayName
                        targetName = character.Name
                    end
                end
            end
            
            local msg = targetName .. " [" .. targetDisplay .. "] â†’ " .. side .. " Grab"
            local now = tick()

            if not notifyCooldowns[msg] or (now - notifyCooldowns[msg]) >= 2 then
                notifyCooldowns[msg] = now
                Rayfield:Notify({Title = "[ âœŠ ]", Content = msg, Duration = 3, Image = 0})
            end

            local success, errorMsg = pcall(function()
                rs.CharacterEvents.RagdollRemote:FireServer(myHRP, 0)

                local myChar = plr.Character
                if not myChar then return end

                local myHD = myChar:FindFirstChild("Head")
                local myLA = myChar:FindFirstChild("Left Arm")
                local myRA = myChar:FindFirstChild("Right Arm")
                local myLL = myChar:FindFirstChild("Left Leg")
                local myLR = myChar:FindFirstChild("Right Leg")

                local bodyParts = {}

                if myHRP then table.insert(bodyParts, myHRP) end
                if myHD then table.insert(bodyParts, myHD) end
                if myLA then table.insert(bodyParts, myLA) end
                if myRA then table.insert(bodyParts, myRA) end
                if myLL then table.insert(bodyParts, myLL) end
                if myLR then table.insert(bodyParts, myLR) end

                for _, part in ipairs(bodyParts) do
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end

                align.Attachment0 = nil
                weld.Attachment0 = nil
                weld.Enabled = false
                align.Enabled = false

                for _, part in ipairs(bodyParts) do
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end

                weld.Enabled = true
                align.Enabled = true

                for _, part in ipairs(bodyParts) do
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end
            end)

            if not success then
                warn("CheckBlob: " .. errorMsg)
            end
        end
    end
end

function AntiStickyGBF()
    if not AntiStickyGBT then
        return
    end

    while AntiStickyGBT do
        local char = plr.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then 
            task.wait(0.1)
            continue
        end

        local desk = inv:FindFirstChild("WD")

        if not desk then
            local spawnRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("SpawnToyRemoteFunction")
            if spawnRemote then
                local offset = hrp.CFrame.LookVector * -24
                local spawnCF = hrp.CFrame + Vector3.new(0, 0, 0) + offset
                task.spawn(function()
                    pcall(function()
                        spawnRemote:InvokeServer("SprayCanWD", spawnCF, spawnCF.Position)
                    end)
                end)
                task.wait(0.001)

                for _, item in pairs(inv:GetChildren()) do
                    if item.Name == "SprayCanWD" then
                        item.Name = "WD"
                        desk = item
                        break
                    end
                end
            end

            if not desk then
                task.wait(0.1)
                continue
            end
        end

        local main = desk:FindFirstChild("Main")
        if main then
            local bp = main:FindFirstChildOfClass("BodyPosition")
            if not bp then
                bp = Instance.new("BodyPosition")
                bp.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bp.Position = Vector3.new(hrp.CFrame.X, 600, hrp.CFrame.Z)
                bp.Parent = main
            else
                bp.Position = Vector3.new(hrp.CFrame.X, 600, hrp.CFrame.Z)
            end
        end

        local hitbox = desk:FindFirstChild("Hitbox")
        if not hitbox then
            task.wait(0.1)
            continue
        end

        local partOwner = hitbox:FindFirstChild("PartOwner")
        if not partOwner or partOwner.Value ~= plr.Name then
            rs.GrabEvents.SetNetworkOwner:FireServer(hitbox, hitbox.CFrame)
            task.wait(0.1)
            partOwner = hitbox:FindFirstChild("PartOwner")
            if not partOwner or partOwner.Value ~= plr.Name then
                task.wait(0.1)
                continue
            end
        end

        local hitbox2 = desk:FindFirstChild("StickyRemoverPart")
        if not hitbox2 then
            task.wait(0.1)
            continue
        end

        local validRoots = {}
        for _, name in ipairs(playersInLoop1V) do
            local player = game.Players:FindFirstChild(name)
            if player and player.Character then
                local root = player.Character:FindFirstChild("HumanoidRootPart") 
                if root and not playersInPlotsFolder:FindFirstChild(name) then
                    table.insert(validRoots, root)
                end
            end
        end

        if #validRoots > 0 then
            for _, targetRoot in ipairs(validRoots) do
                if targetRoot then
                    local behindCFrame = targetRoot.CFrame * CFrame.new(1,0,3)
                    hitbox2.CFrame = behindCFrame
                    task.wait()
                end
            end
        end

        task.wait(0.05)
    end
end

function RagdollGrabF()
    if not RagdollGrabT then
        local deskToRemove = inv:FindFirstChild("RB")
        if deskToRemove then
            local destroyRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("DestroyToy")
            if destroyRemote then
                destroyRemote:FireServer(deskToRemove)
            end
        end
        return
    end

    while RagdollGrabT and task.wait() do
        local char = plr.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then
            continue
        end

        local desk = inv:FindFirstChild("RB")

        if not desk then
            local spawnRemote = rs.MenuToys.SpawnToyRemoteFunction
            if spawnRemote then
                local offset = hrp.CFrame.LookVector * -24
                local spawnCF = hrp.CFrame + offset

                task.spawn(function()
                    pcall(function()
                        spawnRemote:InvokeServer("PalletLightBrown", spawnCF, spawnCF.Position)
task.wait(0.1)
                    end)

                    for attempt = 3, 3 do
                        for _, item in pairs(inv:GetChildren()) do
                            if item.Name == "PalletLightBrown" then
                                local soundPart = item:FindFirstChild("SoundPart")
                                if soundPart then
                                    for i = 3, 3 do
                                        pcall(function()
                                            rs.GrabEvents.SetNetworkOwner:FireServer(soundPart, soundPart.CFrame)
                                            rs.GrabEvents.SetNetworkOwner:FireServer(soundPart, hrp.CFrame)
                                        end)
                                    end

                                    local partOwner = soundPart:FindFirstChild("PartOwner")
                                    if partOwner and partOwner.Value == plr.Name then
                                        item.Name = "RB"
                                        return
                                    end
                                end
                            end
                        end
                        task.wait()
                    end
                end)

                task.wait()
                desk = inv:FindFirstChild("RB")
            end
        end

        if not desk then 
            continue 
        end

        pcall(function()
            for _, part in ipairs(desk:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)

        local soundPart = desk:FindFirstChild("SoundPart")
        if not soundPart then
            local destroyRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("DestroyToy")
            if destroyRemote then
                destroyRemote:FireServer(desk)
            end
            continue
        end

        local partOwner = soundPart:FindFirstChild("PartOwner")
        if not partOwner or partOwner.Value ~= plr.Name then
            local destroyRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("DestroyToy")
            if destroyRemote then
                destroyRemote:FireServer(desk)
            end
            continue
        end

        local targetFound = false

        for _, other in pairs(game:GetService("Players"):GetPlayers()) do
            if other ~= plr and other.Character and other.Character:FindFirstChild("Head") then
                local head = other.Character.Head
                local headPartOwner = head:FindFirstChild("PartOwner")
                local FreeKick = head:FindFirstChild("OwnerKickRagdoll")

                if (headPartOwner and headPartOwner:IsA("StringValue") and headPartOwner.Value == plr.Name) or 
                   (FreeKick and FreeKick:IsA("StringValue")) then

                    local humanoid = other.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        local ragdolled = humanoid:FindFirstChild("Ragdolled")
                        if ragdolled and ragdolled:IsA("BoolValue") and ragdolled.Value then
                            continue
                        end
                    end

                    local otherHrp = other.Character:FindFirstChild("HumanoidRootPart")
                    if otherHrp then
                        soundPart.CFrame = CFrame.new(0,9999,0)
                        task.wait(0.01)
                        soundPart.CFrame = otherHrp.CFrame * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0))
                        targetFound = true
                        break
                    end
                end
            end
        end

        local main = desk:FindFirstChild("Main")
        if main then
            local bp = main:FindFirstChildOfClass("BodyPosition")
            if not bp then
                bp = Instance.new("BodyPosition")
                bp.MaxForce = Vector3.new(999999, 999999, 999999)
                bp.P = 500000
                bp.D = 5000
                bp.Parent = main
            end

            if not targetFound then
                local highPosition = Vector3.new(0, 9999, 0)
                bp.Position = highPosition
                soundPart.CFrame = CFrame.new(highPosition)
            else
                bp.Position = soundPart.Position
            end
        end
    end

    if not RagdollGrabT then
        local deskToRemove = inv:FindFirstChild("RB")
        if deskToRemove then
            local destroyRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("DestroyToy")
            if destroyRemote then
                destroyRemote:FireServer(deskToRemove)
            end
        end
    end
end

function AntiGrabStickyF()
    local plr = game.Players.LocalPlayer
    
    while AntiGrabStickyT and plr do
        task.wait(0.1)

        local char = plr.Character
        if not char or not char.Parent then
            continue
        end

        local inv = workspace:WaitForChild(plr.Name.."SpawnedInToys")
        local rs = game:GetService("ReplicatedStorage")
        local StickyPartEvent = rs.PlayerEvents.StickyPartEvent
        local SetNetworkOwner = rs.GrabEvents.SetNetworkOwner
        local SpawnToyRemoteFunction = rs.MenuToys.SpawnToyRemoteFunction 
        local DestroyToy = rs.MenuToys.DestroyToy

        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        local head = char:FindFirstChild("Head")
        if not hrp or not hum or not head then
            continue
        end

        local agFolder = inv:FindFirstChild("AG")
        local stickyPart = agFolder and agFolder:FindFirstChild("StickyPart")

        local headPartOwner = head:FindFirstChild("PartOwner")
        local stickyWeld = stickyPart and stickyPart:FindFirstChild("StickyWeld")
        local targetPart = hrp:FindFirstChild("RagdollTouchedHitbox")

        if headPartOwner and stickyWeld and targetPart and stickyWeld.Part1 == targetPart then
            pcall(function()
                SetNetworkOwner:FireServer(stickyPart, stickyPart.CFrame)
            end)

            if hum.Sit then
                hum.Sit = false
            end
            if not hum.AutoRotate then
                hum.AutoRotate = true
            end

            headPartOwner:Destroy()
        end

        if stickyWeld and targetPart and stickyWeld.Part1 ~= targetPart then
            pcall(function()
                SetNetworkOwner:FireServer(stickyPart, stickyPart.CFrame)
            end)
        end

        if stickyPart then
            local distance = (hrp.Position - stickyPart.Position).Magnitude
            if distance > 25 then
                pcall(function()
                    DestroyToy:FireServer(agFolder)
                end)
                task.wait(0.001)
            else
                local partOwner = stickyPart:FindFirstChild("PartOwner")
                if not partOwner or partOwner.Value ~= plr.Name then
                    pcall(function()
                        SetNetworkOwner:FireServer(stickyPart, hrp.CFrame)
                    end)
                end

                local targetPart = hrp:FindFirstChild("RagdollTouchedHitbox")
                local stickyWeld = stickyPart:FindFirstChild("StickyWeld")

                if targetPart and stickyPart then
                    if not stickyWeld or stickyWeld.Part1 ~= targetPart then
                        pcall(function()
                            StickyPartEvent:FireServer(stickyPart, targetPart, CFrame.new(0, -0.3, 0.3) * CFrame.Angles(190, 0, 0))
                        end)
                    end
                end
            end
        else
            local existingNinja = inv:FindFirstChild("AG")
            if not existingNinja then

                task.spawn(function()
                    pcall(function()
                        SpawnToyRemoteFunction:InvokeServer("NinjaShuriken", hrp.CFrame * CFrame.new(0,10,20), Vector3.new(0,0,0))
                    end)
                end)

                task.wait(0.001)

                local newNinjaFolder = inv:FindFirstChild("NinjaShuriken")
                if newNinjaFolder then
                    local newStickyPart = newNinjaFolder:FindFirstChild("StickyPart")
                    if newStickyPart then
                        local distance = (hrp.Position - newStickyPart.Position).Magnitude
                        if distance <= 30 then
                            newNinjaFolder.Name = "AG"
                        else
                            pcall(function()
                                DestroyToy:FireServer(newNinjaFolder)
                            end)
                        end
                    end
                end
            else
                local newStickyPart = existingNinja:FindFirstChild("StickyPart")
                if newStickyPart then
                    local distance = (hrp.Position - newStickyPart.Position).Magnitude
                    if distance <= 30 then
                        existingNinja.Name = "AG"
                    end
                end
            end
        end
    end
end

function AntiGrabF(enable)
    if antiGrabConn then
        antiGrabConn:Disconnect()
        antiGrabConn = nil
    end

    if not enable then
        char = plr.Character
        hrp = char and char:FindFirstChild("HumanoidRootPart")
        hum = char and char:FindFirstChild("Humanoid")

        if hrp and hrp.Anchored then hrp.Anchored = false end
        if hum then
            hum.RequiresNeck = true
            hum.Sit = false
            hum:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
        return
    end

    lastHeldState = false
    sitHoldTimer = 0
    shouldKeepSit = false
    lastRagdollTime = 0
    ragdollDuration = 0.48

    antiGrabConn = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
        char = plr.Character
        if not char then return end

        hum = char:FindFirstChild("Humanoid")
        isvs = hum and hum.SeatPart ~= nil

        isHeld = plr:FindFirstChild("IsHeld")
        if not isHeld then return end

        head = char:FindFirstChild("Head")
        POR = head and head:FindFirstChild("PartOwner")
        hrp = char:FindFirstChild("HumanoidRootPart")
        if not hum or not hrp then return end

        hum.RequiresNeck = false
        hum.AutoRotate = true

        if not hrp or hum.Health <= 0 then
            hum:ChangeState(Enum.HumanoidStateType.Dead)
            char:BreakJoints()
            rs.CharacterEvents.Struggle:FireServer()
            return
        end

        if POR and WhiteListMode then
            for _, whiteName in ipairs(Whitelist) do
                if whiteName == POR.Value then return end
            end
        end

        if POR then
            rs.CharacterEvents.Struggle:FireServer()
            rs.CharacterEvents.RagdollRemote:FireServer(hrp, 1)
        end

        if isvs then task.wait(0.3) end

        if hum.Health <= 0 then
            lastHeldState = false
            shouldKeepSit = false
            sitHoldTimer = 0
        end

        rag = hum:FindFirstChild("Ragdolled")
        if isHeld.Value and rag.Value then
            for _, limbName in ipairs({"Head", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}) do
                local limb = char:FindFirstChild(limbName)
                if limb then
                    cons = limb:FindFirstChild("BallSocketConstraint")
                    ragPart = limb:FindFirstChild("RagdollLimbPart")
                    if cons then cons.Enabled = false end
                    if ragPart then ragPart.CanCollide = false end
                end
            end
        end

        if isHeld.Value then
            if hum.MoveDirection.Magnitude > 0 then
                local moveSpeed = 16
                local moveVector = hum.MoveDirection * deltaTime * moveSpeed
                hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                moveVector = Vector3.new(moveVector.X, 0, moveVector.Z)
                hrp.CFrame = hrp.CFrame + moveVector
            end
        end

        if isHeld.Value ~= lastHeldState then
            if isHeld.Value then
                shouldKeepSit = true
                sitHoldTimer = 0.3
                hum:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
                hum.Sit = true
                lastRagdollTime = tick()
            else
                shouldKeepSit = true
                sitHoldTimer = 0.3
            end
            lastHeldState = isHeld.Value
        end

        local now = tick()
        if lastRagdollTime > 0 and now - lastRagdollTime >= ragdollDuration then
            lastRagdollTime = 0
        end

        if isHeld.Value and lastRagdollTime > 0 and now - lastRagdollTime < ragdollDuration and hrp then
            setRagdollF(true)
        end

        if sitHoldTimer > 0 then
            sitHoldTimer = sitHoldTimer - deltaTime
            if rag.Value or isHeld.Value or POR then
                shouldKeepSit = true
                sitHoldTimer = 0.3
                hum.Sit = true
                if isHeld.Value then hum:ChangeState(Enum.HumanoidStateType.RunningNoPhysics) end
            end
        end

        if sitHoldTimer <= 0 and shouldKeepSit then
            if not rag.Value then
                hum.Sit = false
                hum:ChangeState(Enum.HumanoidStateType.Running)
                shouldKeepSit = false
            else
                sitHoldTimer = 0.3
            end
        end
    end)
end

function PlotBarrierDelete()
if PBDrun then return end
PBDrun = true

local char = plr.Character
if not char then PBDrun = false return end

local hrp = char:FindFirstChild("HumanoidRootPart")
if not hrp then PBDrun = false return end

local metal = workspace.Plots.Plot1.TeslaCoil.Metal
if not metal then PBDrun = false return end

local TP = metal.CFrame
local OCF = hrp.CFrame

task.spawn(function()
rs.MenuToys.SpawnToyRemoteFunction:InvokeServer("FoodBread", hrp.CFrame, Vector3.new(0,0,0))
end)

task.wait(0.2)

local foodBread = inv:FindFirstChild("FoodBread")
if not foodBread then PBDrun = false return end

if foodBread then
task.spawn(function()
foodBread.HoldPart.HoldItemRemoteFunction:InvokeServer(foodBread, char)
end)
end

task.wait(0.1)

hrp.CFrame = TP
task.wait(0.17)

if foodBread then
rs.MenuToys.DestroyToy:FireServer(foodBread)
end

hrp.CFrame = OCF
task.wait(0.4)

PBDrun = false
end

function antiPaintF(state)
    local function setParts(canTouch)
        local char = plr.Character
        if not char then return end
        local parts = {
            "Head",
            "HumanoidRootPart",
            "Torso",
            "Left Arm",
            "Right Arm",
            "Left Leg",
            "Right Leg"
        }
        for _, partName in ipairs(parts) do
            local part = char:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                part.CanTouch = canTouch
            end
        end
    end

    if state == true then
        task.spawn(function()
            while AntiPaintT do
                setParts(false)
                task.wait(0.1)
            end
        end)
    else
        setParts(true)
    end
end

function AntiKickF()
    local plr = game.Players.LocalPlayer
    local char = plr.Character
    if not char then return end

    if AntiGrabTP_Active then
        return
    end

    local inv = workspace:WaitForChild(plr.Name .. "SpawnedInToys")
    local rs = game:GetService("ReplicatedStorage")
    local StickyPartEvent = rs.PlayerEvents.StickyPartEvent
    local SetNetworkOwner = rs.GrabEvents.SetNetworkOwner
    local SpawnToyRemoteFunction = rs.MenuToys.SpawnToyRemoteFunction
    local DestroyToy = rs.MenuToys.DestroyToy

    local function findMyPO()
        local myDisplayName = plr.DisplayName
        local myUserName = plr.Name
        local myPOIdentifier = string.format("[ %s ] ( @%s )", myDisplayName, myUserName)
        
        for _, obj in pairs(workspace:GetChildren()) do
            if obj.Name == "PlayerCharacterLocationDetector" then
                for _, child in pairs(obj:GetChildren()) do
                    if child:IsA("BoolValue") and child.Name == myPOIdentifier then
                        return obj
                    end
                end
            end
        end
        return nil
    end

    while AntiKickT and char and char.Parent do
        if AntiGrabTP_Active then break end
        task.wait()

        local hrp = char:FindFirstChild("HumanoidRootPart")
        local torso = char:FindFirstChild("Torso")
        if not hrp or not torso then continue end

        local myPO = findMyPO()
        --local referencePosition = hrp.Position
        if myPO then referencePosition = myPO.Position end

        local ragdollHitbox = hrp:FindFirstChild("RagdollTouchedHitbox")
        if not ragdollHitbox then continue end

        local stickyPartName = "NinjaShuriken"
        local targetValue = CFrame.new(0.05, -0.3, 0) * CFrame.Angles(190, 0, 0)

        local stickyPartFolder = inv:FindFirstChild(stickyPartName)
        local stickyPart = stickyPartFolder and stickyPartFolder:FindFirstChild("StickyPart")
        local soundPart = stickyPartFolder and stickyPartFolder:FindFirstChild("SoundPart")

        if not stickyPart then
            local success = pcall(function()
            task.spawn(function()
                SpawnToyRemoteFunction:InvokeServer(stickyPartName, SCF.CFrame, Vector3.new(0, 0, 0))
            end)
            end)

            if not success then continue end

            for _ = 0, 10 do
                task.wait(0.05)
                stickyPartFolder = inv:FindFirstChild(stickyPartName)
                if stickyPartFolder then break end
            end

            if not stickyPartFolder then continue end

            stickyPart = stickyPartFolder:FindFirstChild("StickyPart")
            soundPart = stickyPartFolder:FindFirstChild("SoundPart")

            if stickyPart then stickyPart.CanQuery = false end
            if soundPart then soundPart.CanQuery = false end

            if not stickyPart then continue end
        end

        pcall(function()
            SetNetworkOwner:FireServer(stickyPart, stickyPart.CFrame)
            DestroyGrabLine:FireServer(stickyPart)
        end)

        local distance = (referencePosition - stickyPart.Position).Magnitude
        if distance > 8 then
            pcall(function()
                DestroyToy:FireServer(stickyPartFolder)
            end)
            continue
        end

        local partOwner = stickyPart:FindFirstChild("PartOwner")
        if partOwner then
            pcall(function()
                DestroyToy:FireServer(stickyPartFolder)
            end)
            continue
        end

        local stickyWeld = stickyPart:FindFirstChild("StickyWeld")

        if not stickyWeld or stickyWeld.Part1 ~= ragdollHitbox then
            StickyPartEvent:FireServer(stickyPart, ragdollHitbox, targetValue)

            for _ = 0, 10 do
                task.wait(0.05)
                stickyWeld = stickyPart:FindFirstChild("StickyWeld")
                if stickyWeld and stickyWeld.Part1 == ragdollHitbox then
                    break
                end
            end
        end

        if stickyWeld and stickyWeld.Part1 == ragdollHitbox then
            while stickyWeld and stickyWeld.Part1 == ragdollHitbox and ragdollHitbox.Parent do
                if not AntiKickT or AntiGrabTP_Active then break end
                task.wait(0.05)

                local currentFolder = inv:FindFirstChild(stickyPartName)
                if not currentFolder then break end

                local currentStickyPart = currentFolder:FindFirstChild("StickyPart")
                if not currentStickyPart then break end

                stickyWeld = currentStickyPart:FindFirstChild("StickyWeld")
                if not stickyWeld or stickyWeld.Part1 ~= ragdollHitbox then
                    break
                end
            end
        end

        if not AntiKickT or AntiGrabTP_Active then
            if stickyPartFolder and stickyPartFolder.Parent then
                pcall(function()
                    DestroyToy:FireServer(stickyPartFolder)
                end)
            end
            break
        end
    end

    if not AntiKickT then
        local shurikenFolder = inv:FindFirstChild("NinjaShuriken")
        if shurikenFolder then
            pcall(function()
                DestroyToy:FireServer(shurikenFolder)
            end)
        end
    end
end

plr.CharacterAdded:Connect(function(newChar)
    newChar:WaitForChild("Humanoid")
    newChar:WaitForChild("HumanoidRootPart")
    task.wait(0.2)
    if AntiKickT and not AntiGrabTP_Active then
        AntiKickF()
    end
end)

Plots = workspace:WaitForChild("Plots")
function BarrierCanCollideF()
    if BarrierCanCollideT then
        for i = 1, 5 do
            local plot = Plots:FindFirstChild("Plot"..i)
            if plot and plot:FindFirstChild("Barrier") then
                for _, barrier in ipairs(plot.Barrier:GetChildren()) do
                    if barrier:IsA("BasePart") then
                        barrier.CanCollide = false
                    end
                end
            end
        end
    else
        for i = 1, 5 do
            local plot = Plots:FindFirstChild("Plot"..i)
            if plot and plot:FindFirstChild("Barrier") then
                for _, barrier in ipairs(plot.Barrier:GetChildren()) do
                    if barrier:IsA("BasePart") then
                        barrier.CanCollide = true
                    end
                end
            end
        end
    end
end

function AntiExplosionF()
    if AntiExplosionC then
        AntiExplosionC:Disconnect()
        AntiExplosionC = nil
    end
    if AntiExplosionH then
        AntiExplosionH:Disconnect()
        AntiExplosionH = nil
    end

    if not AntiExplosionT then 
        return 
    end

    local char = plr.Character
    if not char then 
        return 
    end

    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")

    AntiExplosionC = workspace.ChildAdded:Connect(function(model)
        if not char or not hrp or not hum then
            return
        end
        
        if model:IsA("BasePart") and (model.Position - hrp.Position).Magnitude <= 20 then
            if hum.SeatPart ~= nil then
                hrp.Anchored = true
                task.wait(0.03)
                hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                hrp.Anchored = false
            else
            if model:IsA("BasePart") and (model.Position - hrp.Position).Magnitude <= 20 then
                hrp.Anchored = true
                task.wait()
                hum:ChangeState(Enum.HumanoidStateType.Running)
                hrp.Anchored = false
                hum.AutoRotate = true

                for _, limb in ipairs(char:GetDescendants()) do
                    if limb:IsA("BasePart") and limb.Name == "RagdollLimbPart" then
                        limb.CanCollide = false
                        end
                    end
                end
            end
        end
    end)
end

plr.CharacterAdded:Connect(function(char)
    char:WaitForChild("Humanoid")
    char:WaitForChild("HumanoidRootPart")
    task.wait(0.2)
    if AntiExplosionT then
        AntiExplosionF()
    end
end)

function isSelected(option)
    if not AutoAttackerV then return false end
    for _, v in ipairs(AutoAttackerV) do
        if v == option then return true end
    end
    return false
end

function AutoAttackF()
    task.spawn(function()
        local savedTargets = {}
        local invName = plr.Name.."SpawnedInToys"
        local lastNotifiedOwner = ""

        while AutoAttackT do
            rs2.Heartbeat:Wait()

            local myChar = plr.Character
            local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
            local myTorso = myChar and myChar:FindFirstChild("Torso")
            local myAttach = myHRP and myHRP:FindFirstChild("RootAttachment")

            if not (myChar and myHRP and myAttach) then continue end

            if isSelected("ì•Œë¦¼") then
                local myHead = myChar:FindFirstChild("Head")
                local myOwnerVal = myHead and myHead:FindFirstChild("PartOwner")
                if myOwnerVal and myOwnerVal.Value ~= "" then
                    if lastNotifiedOwner ~= myOwnerVal.Value then
                        local attacker = game.Players:FindFirstChild(myOwnerVal.Value)
                        local displayName = attacker and attacker.DisplayName or "Unknown"
                        Rayfield:Notify({Title = "[ âš”ï¸ ]",Content = myOwnerVal.Value .. " [" .. displayName .. "] ë‹˜ì´ ìž¡ì•˜ìŠµë‹ˆë‹¤.",Duration = 3,Image = 0})
                        lastNotifiedOwner = myOwnerVal.Value
                    end
                else
                    lastNotifiedOwner = ""
                end
            end

            for _, player in ipairs(game.Players:GetPlayers()) do
                if player == plr then continue end

                local tChar = player.Character
                local tHead = tChar and tChar:FindFirstChild("Head")
                local tOwner = tHead and tHead:FindFirstChild("PartOwner")

                local myHead = myChar and myChar:FindFirstChild("Head")
                local myHeadOwner = myHead and myHead:FindFirstChild("PartOwner")

                if myHeadOwner and myHeadOwner.Value == player.Name then
                    local found = false
                    for _, v in ipairs(savedTargets) do
                        if v == player then
                            found = true
                            break
                        end
                    end
                    if not found then
                        table.insert(savedTargets, player)
                    end
                end
            end

            for i = #savedTargets, 1, -1 do
                local target = savedTargets[i]
                
                if not target then
                    table.remove(savedTargets, i)
                    continue
                end

                local tChar = target.Character
                local hum = tChar and tChar:FindFirstChildOfClass("Humanoid")
                local torso = tChar and tChar:FindFirstChild("Torso")

                if not (tChar and hum and torso and hum.Health > 0) then
                    table.remove(savedTargets, i)
                    continue
                end

                local distance = (torso.Position - myTorso.Position).Magnitude
                if distance > 30 then
                    table.remove(savedTargets, i)
                    continue
                end

                if WhiteListMode and Whitelist then
                    local whitelisted = false
                    for _, allowed in ipairs(Whitelist) do
                        if allowed == target.Name then
                            whitelisted = true
                            break
                        end
                    end
                    if whitelisted then
                        continue
                    end
                end

                local myHead = myChar and myChar:FindFirstChild("Head")
                local myHeadOwner = myHead and myHead:FindFirstChild("PartOwner")

                if not (myHeadOwner and myHeadOwner.Value == target.Name) then
                    table.remove(savedTargets, i)
                    continue
                end

                if isSelected("ê³µí—ˆ ì´ë™") then
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                    local FallenY = workspace.FallenPartsDestroyHeight
                    local targetY = (FallenY <= -50000 and -49999) or (FallenY <= -100 and -99) or -77777
                    torso.CFrame = CFrame.new(99999, targetY, 99999)
                    rs.GrabEvents.DestroyGrabLine:FireServer(torso)
                    table.remove(savedTargets, i)
                    continue
                end

                if isSelected("ê°ì˜¥ ì´ë™") then
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                    torso.CFrame = CFrame.new(590, 153, -100)
                    rs.GrabEvents.DestroyGrabLine:FireServer(torso)
                    table.remove(savedTargets, i)
                    continue
                end

                if isSelected("ë‚ ë¦¬ê¸°") then
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                    task.spawn(function()
                    local pushDir = (torso.Position - myTorso.Position).Unit
                    torso.Velocity = (pushDir * 35) + Vector3.new(0, 50, 0)
                    rs.GrabEvents.DestroyGrabLine:FireServer(torso)
                    end)
                    table.remove(savedTargets, i)
                    continue
                end

                if isSelected("ì£½ì´ê¸°") then
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                    task.spawn(function()
                        if hum then
                            hum.BreakJointsOnDeath = false
                            hum:ChangeState(Enum.HumanoidStateType.Dead)
                        end
                    rs.GrabEvents.DestroyGrabLine:FireServer(torso)
                    end)
                    table.remove(savedTargets, i)
                    continue
                end

                if isSelected("ìœ„í—˜êµ¬ì—­ ì´ë™") then
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))

        torso.CFrame = CFrame.new(torso.Position.X, 100, torso.Position.Z)

        local targetPos = Vector3.new(60, -50, 270)
        local startPos = torso.Position

        local duration = 2
        local startTime = tick()
        local elapsed = 0

        repeat
            elapsed = tick() - startTime
            local alpha = math.min(elapsed / duration, 1)
            local easedAlpha = alpha < 0.5 and 2 * alpha * alpha or 1 - math.pow(-2 * alpha + 2, 2) / 2
            local interpolatedPos = startPos:Lerp(targetPos, easedAlpha)

            torso.CFrame = CFrame.new(interpolatedPos)

            task.wait()
        until alpha >= 1 or not torso

        if torso then
            rs.GrabEvents.DestroyGrabLine:FireServer(torso)
        end
                    table.remove(savedTargets, i)
                    continue
                end

                if isSelected("ìŠ¤í° ì´ë™") then
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))

        torso.CFrame = CFrame.new(torso.Position.X, 100, torso.Position.Z)

        local targetPos = Vector3.new(0, -7, 0)
        local startPos = torso.Position

        local duration = 2
        local startTime = tick()
        local elapsed = 0

        repeat
            elapsed = tick() - startTime
            local alpha = math.min(elapsed / duration, 1)
            local easedAlpha = alpha < 0.5 and 2 * alpha * alpha or 1 - math.pow(-2 * alpha + 2, 2) / 2
            local interpolatedPos = startPos:Lerp(targetPos, easedAlpha)

            torso.CFrame = CFrame.new(interpolatedPos)

            task.wait()
        until alpha >= 1 or not torso

        if torso then
            rs.GrabEvents.DestroyGrabLine:FireServer(torso)
        end
                    table.remove(savedTargets, i)
                    continue
                end

                if isSelected("ë°”ë‹¤ ì´ë™") then
                    task.spawn(function()
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))
                rs.GrabEvents.SetNetworkOwner:FireServer(torso, CFrame.lookAt(myTorso.Position, torso.Position))

        torso.CFrame = CFrame.new(torso.Position.X, 100, torso.Position.Z)

        local targetPos = Vector3.new(-843, 100, -29)
        local startPos = torso.Position

        local duration = 2
        local startTime = tick()
        local elapsed = 0

        repeat
            elapsed = tick() - startTime
            local alpha = math.min(elapsed / duration, 1)
            local easedAlpha = alpha < 0.5 and 2 * alpha * alpha or 1 - math.pow(-2 * alpha + 2, 2) / 2
            local interpolatedPos = startPos:Lerp(targetPos, easedAlpha)

            torso.CFrame = CFrame.new(interpolatedPos)

            task.wait()
        until alpha >= 1 or not torso

        if torso then
            rs.GrabEvents.DestroyGrabLine:FireServer(torso)
        end
    end)
                    table.remove(savedTargets, i)
                    continue
                end

                table.remove(savedTargets, i)
            end
        end
    end)
end

plr.CharacterAdded:Connect(function(char)
    char:WaitForChild("Humanoid")
    char:WaitForChild("HumanoidRootPart")
    task.wait(0.2)
    if AutoAttackT then
        AutoAttackF()
    end
end)

function RagdollWalk()
    task.spawn(function()
        local jointCoroutineRunning = false

        while RagdollWalkT do
            local char = plr.Character
            local hum = char and char:FindFirstChild("Humanoid")
            local torso = char and char:FindFirstChild("Torso")
            local leftArm = char and char:FindFirstChild("Left Arm")
            local leftLeg = char and char:FindFirstChild("Left Leg")
            local rightLeg = char and char:FindFirstChild("Right Leg")
            local ragdoll = hum and hum:FindFirstChild("Ragdolled")
            local limb = leftArm and leftArm:FindFirstChild("RagdollLimbPart")

            if limb and limb:IsA("BasePart") and limb.CanCollide then
                hum.AutoRotate = true

                for _, leg in ipairs({leftLeg, rightLeg}) do
                    local part = leg and leg:FindFirstChild("RagdollLimbPart")
                    if part then part.CanCollide = false end
                end

                if ragdoll then ragdoll.Value = false end

                if not jointCoroutineRunning then
                    jointCoroutineRunning = true
                    coroutine.wrap(function()
                        while RagdollWalkT and limb.CanCollide do
                            for _, jointName in ipairs({"Left Hip", "Left Shoulder", "Neck", "Right Hip", "Right Shoulder"}) do
                                local joint = torso and torso:FindFirstChild(jointName)
                                if joint then joint.Enabled = false end
                            end
                            task.wait(0.05)
                            for _, jointName in ipairs({"Left Hip", "Left Shoulder", "Neck", "Right Hip", "Right Shoulder"}) do
                                local joint = torso and torso:FindFirstChild(jointName)
                                if joint then joint.Enabled = true end
                            end
                            task.wait(0.05)
                        end
                        jointCoroutineRunning = false
                    end)()
                end
            end

            task.wait(0.001)
        end
    end)
end

plr.CharacterAdded:Connect(function()
    task.wait(0.2)
    if RagdollWalkT then
        RagdollWalk()
    end
end)

function flyF()
    if not flyT then return end
    
    local Players = game:GetService("Players")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")

    local plr = Players.LocalPlayer
    local char = plr.Character or plr.CharacterAdded:Wait()
    local humanoid = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart")

    local BV = Instance.new("BodyVelocity")
    local BG = Instance.new("BodyGyro")

    BG.P = 9e4
    BG.Parent = hrp
    BV.Parent = hrp
    BG.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    BG.CFrame = hrp.CFrame
    BV.Velocity = Vector3.new(0,0,0)
    BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)

    local CONTROL = {F=0,B=0,L=0,R=0}
    local lCONTROL = {F=0,B=0,L=0,R=0}
    local SPEED = flyV

    if flyKeyDown then flyKeyDown:Disconnect() end
    if flyKeyUp then flyKeyUp:Disconnect() end
    if flyConnection then flyConnection:Disconnect() end

    flyKeyDown = UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.KeyCode == Enum.KeyCode.W then
            CONTROL.F = 1
        elseif input.KeyCode == Enum.KeyCode.S then
            CONTROL.B = -1
        elseif input.KeyCode == Enum.KeyCode.A then
            CONTROL.L = -1
        elseif input.KeyCode == Enum.KeyCode.D then
            CONTROL.R = 1
        end
    end)

    flyKeyUp = UserInputService.InputEnded:Connect(function(input, processed)
        if input.KeyCode == Enum.KeyCode.W then
            CONTROL.F = 0
        elseif input.KeyCode == Enum.KeyCode.S then
            CONTROL.B = 0
        elseif input.KeyCode == Enum.KeyCode.A then
            CONTROL.L = 0
        elseif input.KeyCode == Enum.KeyCode.D then
            CONTROL.R = 0
        end
    end)

    flyConnection = RunService.Heartbeat:Connect(function()
        if not flyT then
            flyConnection:Disconnect()
            if flyKeyDown then flyKeyDown:Disconnect() end
            if flyKeyUp then flyKeyUp:Disconnect() end
            BV:Destroy()
            BG:Destroy()
            humanoid.PlatformStand = false
            return
        end
        
        local camera = workspace.CurrentCamera
        SPEED = flyV
        
        if CONTROL.F + CONTROL.B ~= 0 or CONTROL.L + CONTROL.R ~= 0 then
            BV.Velocity = ((camera.CFrame.LookVector * (CONTROL.F + CONTROL.B)) + 
                ((camera.CFrame * CFrame.new(CONTROL.L + CONTROL.R, 0, 0).p) - camera.CFrame.p)) * SPEED
            lCONTROL = {F=CONTROL.F,B=CONTROL.B,L=CONTROL.L,R=CONTROL.R}
        else
            BV.Velocity = Vector3.new(0,0,0)
        end
        BG.CFrame = camera.CFrame
    end)
end

plr.CharacterAdded:Connect(function()
    task.wait(0.2)
    if flyT then
        flyF()
    end
end)

function AntiStruggleGrabF()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local SetNetworkOwner = ReplicatedStorage.GrabEvents.SetNetworkOwner
    local DestroyGrabLine = ReplicatedStorage.GrabEvents.DestroyGrabLine
    local CreateGrabLine = ReplicatedStorage.GrabEvents.CreateGrabLine
    local Players = game:GetService("Players")

    if not AntiStruggleGrabT then return end

    task.spawn(function()
        while AntiStruggleGrabT do
            local grabParts = workspace:FindFirstChild("GrabParts")
            if not grabParts then
                task.wait()
                continue
            end

            local gp = grabParts:FindFirstChild("GrabPart")
            local weld = gp and gp:FindFirstChildOfClass("WeldConstraint")
            local part1 = weld and weld.Part1

            if part1 then
                local ownerPlayer = nil
                for _, pl in ipairs(Players:GetPlayers()) do
                    if pl.Character and part1:IsDescendantOf(pl.Character) then
                        ownerPlayer = pl
                        break
                    end
                end

                while AntiStruggleGrabT and workspace:FindFirstChild("GrabParts") do
                    if ownerPlayer then
                        local tgtTorso = ownerPlayer.Character:FindFirstChild("HumanoidRootPart") 
                        local tgtHum = ownerPlayer.Character:FindFirstChild("Humanoid")
                        local tgtHead = ownerPlayer.Character:FindFirstChild("Head")
                        local myTorso = plr.Character:FindFirstChild("HumanoidRootPart") 

                        if tgtTorso and myTorso and tgtHead then
                            local ownerValue = tgtHead:FindFirstChild("PartOwner")
                            if tgtTorso then --not ownerValue or ownerValue.Value ~= plr.Name then
                                SetNetworkOwner:FireServer(tgtTorso, CFrame.lookAt(myTorso.Position, tgtTorso.Position))
                            end
                        end
                    else
                        if part1.Parent then
                            local myTorso = plr.Character:FindFirstChild("HumanoidRootPart")
                            if myTorso then
                                SetNetworkOwner:FireServer(part1, CFrame.lookAt(myTorso.Position, part1.Position))
                            end
                        end
                    end
                    task.wait()
                end
            end
            task.wait()
        end
    end)
end

TpKLG = false
function KillGrabF()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    if not KillGrabT then return end

    local localPlayer = Players.LocalPlayer
    if not localPlayer or not localPlayer.Character then return end

    local connection
    connection = RunService.Heartbeat:Connect(function()
        if not KillGrabT then
            connection:Disconnect()
            return
        end

        local myCharacter = localPlayer.Character
        local myTorso = myCharacter:FindFirstChild("Torso") or myCharacter:FindFirstChild("HumanoidRootPart")
        if not myTorso then return end

        local grabParts = workspace:FindFirstChild("GrabParts")
        if not grabParts then return end

        for _, grabPart in ipairs(grabParts:GetChildren()) do
            if grabPart.Name == "GrabPart" then
                local weld = grabPart:FindFirstChildOfClass("WeldConstraint")
                if not weld then continue end

                local originalPart1 = weld.Part1
                if not originalPart1 then continue end

                local ownerPlayer
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= localPlayer and player.Character and originalPart1:IsDescendantOf(player.Character) then
                        ownerPlayer = player
                        break
                    end
                end

                if not ownerPlayer then continue end
                local tgtTorso = ownerPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not tgtTorso then continue end

                    if TpKLG then weld.Part1 = tgtTorso end

                if KillGrabT then
                    local tgtHum = ownerPlayer.Character:FindFirstChild("Humanoid")
                    if not tgtHum then continue end

                if tgtHum.BreakJointsOnDeath and tgtHum.SeatPart == nil then tgtHum.BreakJointsOnDeath = false end
                if tgtHum.SeatPart == nil then tgtHum:ChangeState(Enum.HumanoidStateType.Dead) end

                    FallenY = workspace.FallenPartsDestroyHeight
                    targetY = (FallenY <= -50000 and -49999.50) or (FallenY <= -100 and -99.50) or -100
                    if TpKLG then tgtTorso.CFrame = CFrame.new(9999, targetY, 9999) end

                    rs.GrabEvents.SetNetworkOwner:FireServer(tgtTorso, CFrame.lookAt(myTorso.Position, tgtTorso.Position))
                    rs.GrabEvents.DestroyGrabLine:FireServer(tgtTorso)
                end
            end
        end
    end)
end

AnhKick = false
function KickGrabF()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    if not KickGrabT then return end

    local localPlayer = Players.LocalPlayer
    if not localPlayer or not localPlayer.Character then return end

    local connection
    connection = RunService.Heartbeat:Connect(function()
        if not KickGrabT then
            connection:Disconnect()
            return
        end

        local myCharacter = localPlayer.Character
        local myTorso = myCharacter:FindFirstChild("Torso") or myCharacter:FindFirstChild("HumanoidRootPart")
        if not myTorso then return end

        local grabParts = workspace:FindFirstChild("GrabParts")
        if not grabParts then return end

        for _, grabPart in ipairs(grabParts:GetChildren()) do
            if grabPart.Name == "GrabPart" then
                local weld = grabPart:FindFirstChildOfClass("WeldConstraint")
                if not weld then continue end

                local originalPart1 = weld.Part1
                if not originalPart1 then continue end

                local ownerPlayer
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= localPlayer and player.Character and originalPart1:IsDescendantOf(player.Character) then
                        ownerPlayer = player
                        break
                    end
                end

                if not ownerPlayer then continue end
                local tgtTorso = ownerPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not tgtTorso then continue end

                weld.Part1 = tgtTorso

                if AnhKick then
                    local tgtHum = ownerPlayer.Character:FindFirstChild("Humanoid")
                    if not tgtHum then continue end

                    if not tgtHum.Sit then ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(tgtTorso, CFrame.lookAt(myTorso.Position, tgtTorso.Position)) end
                    if tgtHum.Sit then ReplicatedStorage.GrabEvents.DestroyGrabLine:FireServer(tgtTorso) end
                    if ownerPlayer.IsHeld then ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(tgtTorso, CFrame.lookAt(myTorso.Position, tgtTorso.Position)) end
                    if tgtHum.Sit then ReplicatedStorage.GrabEvents.DestroyGrabLine:FireServer(tgtTorso) end
                else
                    ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(tgtTorso, CFrame.lookAt(myTorso.Position, tgtTorso.Position))
                    ReplicatedStorage.GrabEvents.DestroyGrabLine:FireServer(tgtTorso)
                end
            end
        end
    end)
end

function MasslessGrabF()
    while MasslessGrabT and task.wait() do
        local grabParts = workspace:FindFirstChild("GrabParts")
        
        if grabParts then
            local dragParts = {grabParts:FindFirstChild("DragPart"), grabParts:FindFirstChild("DragPart1")}
            
            for _, dragPart in pairs(dragParts) do
                if dragPart then
                    local alignOrientation = dragPart:FindFirstChildOfClass("AlignOrientation")
                    if alignOrientation then
                        alignOrientation.MaxAngularVelocity = math.huge
                        alignOrientation.MaxTorque = math.huge
                        alignOrientation.Responsiveness = 200
                    end
                    
                    local alignPosition = dragPart:FindFirstChildOfClass("AlignPosition")
                    if alignPosition then
                        alignPosition.MaxAxesForce = Vector3.new(math.huge, math.huge, math.huge)
                        alignPosition.MaxForce = math.huge
                        alignPosition.MaxVelocity = math.huge
                        alignPosition.Responsiveness = 200
                    end
                end
            end
        end
    end
end

function NoClipGrabF()
    local trackedTargets = {}
    local playerCheckCooldown = 0
    
    local function findAllParts(object, partsList)
        if object:IsA("BasePart") then
            partsList[object] = object.CanCollide
        end
        
        for _, child in ipairs(object:GetChildren()) do
            findAllParts(child, partsList)
        end
    end
    
    local function setPartsCollision(partsList, enable)
        for part, originalValue in pairs(partsList) do
            if part and part.Parent then
                if enable then
                    part.CanCollide = originalValue
                else
                    part.CanCollide = false
                end
            end
        end
    end
    
    while NoClipGrabT and task.wait() do
        local grabParts = workspace:FindFirstChild("GrabParts")
        
        if grabParts then
            local currentTargets = {}
            
            for _, grabPart in ipairs(grabParts:GetChildren()) do
                if grabPart.Name == "GrabPart" then
                    local weldConstraint = grabPart:FindFirstChildOfClass("WeldConstraint")
                    
                    if weldConstraint and weldConstraint.Part1 then
                        local target = weldConstraint.Part1
                        currentTargets[target] = true
                        
                        if not trackedTargets[target] then
                            local partsToDisable = {}
                            local isPlayer = false
                            
                            if target.Parent then
                                findAllParts(target.Parent, partsToDisable)
                                local humanoid = target.Parent:FindFirstChildOfClass("Humanoid")
                                if humanoid then
                                    isPlayer = true
                                end
                            else
                                if target:IsA("BasePart") then
                                    partsToDisable[target] = target.CanCollide
                                end
                            end
                            
                            setPartsCollision(partsToDisable, false)
                            
                            local connection
                            connection = weldConstraint.Destroying:Connect(function()
                                setPartsCollision(partsToDisable, true)
                                trackedTargets[target] = nil
                                if connection then
                                    connection:Disconnect()
                                end
                            end)
                            
                            trackedTargets[target] = {
                                target = target,
                                connection = connection,
                                partsToDisable = partsToDisable,
                                isPlayer = isPlayer,
                                lastPlayerCheck = os.clock()
                            }
                        else
                            trackedTargets[target].lastPlayerCheck = os.clock()
                        end
                    end
                end
            end
            
            playerCheckCooldown = playerCheckCooldown + task.wait()
            if playerCheckCooldown >= 0.01 then
                playerCheckCooldown = 0
                
                for target, data in pairs(trackedTargets) do
                    if data.isPlayer then
                        local newParts = {}
                        findAllParts(target.Parent, newParts)
                        
                        for part, originalValue in pairs(newParts) do
                            if not data.partsToDisable[part] then
                                data.partsToDisable[part] = originalValue
                            end
                            if part.CanCollide then
                                part.CanCollide = false
                            end
                        end
                    end
                end
            end
            
            for target, data in pairs(trackedTargets) do
                if not currentTargets[target] then
                    setPartsCollision(data.partsToDisable, true)
                    
                    if data.connection then
                        data.connection:Disconnect()
                    end
                    trackedTargets[target] = nil
                end
            end
        else
            for target, data in pairs(trackedTargets) do
                setPartsCollision(data.partsToDisable, true)
                
                if data.connection then
                    data.connection:Disconnect()
                end
            end
            trackedTargets = {}
        end
    end
    
    for target, data in pairs(trackedTargets) do
        setPartsCollision(data.partsToDisable, true)
        
        if data.connection then
            data.connection:Disconnect()
        end
    end
end

function ViewToolF()
    local Tools = {
        "NinjaKunai",
        "NinjaShuriken",
        "NinjaKatana",
        "ToolCleaver",
        "ToolDiggingForkRusty",
        "ToolPencil",
        "ToolPickaxe",
        "AG",
    }

    local Cpf = { "Campfire" }
    local AG = { "AG" }

    local function addView(item, partName, multiple, onlyView1, highTransparency)
        if onlyView1 then return end

        local function createHighlight(part, index)
            if not item:FindFirstChild("Highlight_" .. index) then
                local highlight = Instance.new("Highlight")
                highlight.Name = "Highlight_" .. index
                highlight.Adornee = item
                highlight.FillColor = Color3.fromRGB(255, 0, 0)
                highlight.FillTransparency = 1

                if item.Name == "Campfire" then
                    highlight.OutlineColor = Color3.fromRGB(105, 102, 92)
                elseif item.Name == "AG" then
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 0)
                else
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                end

                highlight.FillTransparency = 1
                highlight.OutlineTransparency = 0
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.Parent = item
            end
        end

        if multiple and partName then
            local count = 0
            for _, part in ipairs(item:GetDescendants()) do
                if part:IsA("BasePart") and part.Name == partName then
                    count += 1
                    createHighlight(part, count)
                end
            end
        elseif partName then
            local part = item:FindFirstChild(partName, true)
            if part and part:IsA("BasePart") then
                createHighlight(part, partName)
            end
        end
    end

    local function checkAndHighlightItem(item)
        if item:IsA("Model") then
            if table.find(Tools, item.Name) then
                addView(item, "StickyPart")
            elseif table.find(Cpf, item.Name) then
                addView(item, "FirePlayerPart")
            elseif table.find(AG, item.Name) then
                addView(item, nil, false, false)
            end
        end
    end

    task.spawn(function()
        while ViewToolT and task.wait(0.2) do
            for _, folder in ipairs(workspace:GetChildren()) do
                if folder:IsA("Folder") and folder.Name:match("SpawnedInToys$") then
                    for _, item in ipairs(folder:GetChildren()) do
                        checkAndHighlightItem(item)
                    end
                end
            end

            if workspace:FindFirstChild("PlotItems") then
                local plotItems = workspace.PlotItems
                for i = 1, 5 do
                    local plotName = "Plot" .. i
                    local plot = plotItems:FindFirstChild(plotName)
                    if plot then
                        for _, item in ipairs(plot:GetChildren()) do
                            checkAndHighlightItem(item)
                        end
                    end
                end
            end
        end

        for _, folder in ipairs(workspace:GetChildren()) do
            if folder:IsA("Folder") and folder.Name:match("SpawnedInToys$") then
                for _, item in ipairs(folder:GetChildren()) do
                    for _, v in ipairs(item:GetChildren()) do
                        if v.Name:match("^Highlight_") then
                            v:Destroy()
                        end
                    end
                end
            end
        end

        if workspace:FindFirstChild("PlotItems") then
            local plotItems = workspace.PlotItems
            for i = 1, 5 do
                local plotName = "Plot" .. i
                local plot = plotItems:FindFirstChild(plotName)
                if plot then
                    for _, item in ipairs(plot:GetChildren()) do
                        for _, v in ipairs(item:GetChildren()) do
                            if v.Name:match("^Highlight_") then
                                v:Destroy()
                            end
                        end
                    end
                end
            end
        end
    end)
end

function ViewAuraF()
    local targetNames = { 
        "NinjaKunai", "NinjaShuriken", "NinjaKatana", 
        "ToolCleaver", "ToolDiggingForkRusty", 
        "ToolPencil", "ToolPickaxe" 
    }

    task.spawn(function()
        while ViewAuraT and task.wait(0.03) do
            local character = plr.Character
            if not character then continue end

            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then continue end

            for _, folder in ipairs(workspace:GetChildren()) do
                if folder:IsA("Folder") and folder.Name:match("SpawnedInToys$") then
                    if folder.Name ~= (plr.Name .. "SpawnedInToys") then
                        for _, item in ipairs(folder:GetChildren()) do
                            if table.find(targetNames, item.Name) and item:FindFirstChild("StickyPart") then
                                local sticky = item.StickyPart

                                local basePart = item.PrimaryPart or sticky
                                local dist = (basePart.Position - hrp.Position).Magnitude

                                if dist <= 30 then -- and sticky:FindFirstChild("PartOwner").Value ~= plr.Name then
                                    pcall(function()
                                        rs.GrabEvents.SetNetworkOwner:FireServer(sticky, CFrame.lookAt(hrp.Position, sticky.Position))
                                    end)
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end

function AntiSeatedF()
    task.spawn(function()
        while AntiSeatedT and task.wait() do
            local character = plr.Character
            if not character then continue end
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then continue end

            for _, otherPlr in ipairs(game.Players:GetPlayers()) do
                if otherPlr == plr then continue end
                local otherChar = otherPlr.Character
                if not otherChar then continue end
                local otherHrp = otherChar:FindFirstChild("HumanoidRootPart")
                if not otherHrp then continue end
                local otherHum = otherChar:FindFirstChild("Humanoid")
                if not otherHum then continue end

                if otherHum.SeatPart then
                    local dist = (otherHrp.Position - hrp.Position).Magnitude
                    if dist <= 30 then
                        rs.GrabEvents.SetNetworkOwner:FireServer(otherHrp, CFrame.lookAt(hrp.Position, otherHrp.Position))
                    end
                end
            end
        end
    end)
end

function AntiBananaAuraF()
    local targetNames = {"FoodBanana"}

    task.spawn(function()
        while AntiBananaAuraT and task.wait() do
            local character = plr.Character
            if not character then continue end

            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then continue end

            for _, folder in ipairs(workspace:GetChildren()) do
                if folder:IsA("Folder") and folder.Name:match("SpawnedInToys$") then
                    if folder.Name ~= (plr.Name .. "SpawnedInToys") then
                        for _, item in ipairs(folder:GetChildren()) do
                            if table.find(targetNames, item.Name) and item:FindFirstChild("SoundPart") then
                                local Spart = item.SoundPart

                                local basePart = item.PrimaryPart or Spart
                                local PartOwner = Spart:FindFirstChild("PartOwner")
                                local dist = (basePart.Position - hrp.Position).Magnitude

                                if dist <= 30 and not PartOwner then rs.GrabEvents.SetNetworkOwner:FireServer(Spart, CFrame.lookAt(hrp.Position, Spart.Position)) end
                            end
                        end
                    end
                end
            end
        end
    end)
end

function AntiBoxF()
    local targetNames = AntiBoxV

    local nameMapping = {
        ["MidiMaker"] = "MidiMaker",
        ["SoundWaveMaker"] = "SoundWaveMaker",
        ["Boombox"] = "Boombox",
        ["JukeboxðŸŸ¦"] = "JukeboxBlue",
        ["JukeboxðŸŸ§"] = "JukeboxOrange"
    }

    local partNameMapping = {
        ["SoundWaveMaker"] = "DownA",
        ["MidiMaker"] = nil,
        ["Boombox"] = nil,
        ["JukeboxBlue"] = nil,
        ["JukeboxOrange"] = nil
    }

    local actualTargetNames = {}
    for _, displayName in ipairs(targetNames) do
        if nameMapping[displayName] then
            table.insert(actualTargetNames, nameMapping[displayName])
        end
    end

    task.spawn(function()
        while AntiBoxT and task.wait(0.1) do
            local character = plr.Character
            if not character then continue end

            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then continue end

            for _, folder in ipairs(workspace:GetChildren()) do
                if folder:IsA("Folder") and folder.Name:match("SpawnedInToys$") then
                    if folder.Name ~= (plr.Name .. "SpawnedInToys") then
                        for _, item in ipairs(folder:GetChildren()) do
                            if table.find(actualTargetNames, item.Name) then

                                local targetPart = nil
                                local specificPartName = partNameMapping[item.Name]

                                if specificPartName then
                                    targetPart = item:FindFirstChild(specificPartName, true)
                                else
                                    for _, descendant in ipairs(item:GetDescendants()) do
                                        if descendant:IsA("BasePart") and descendant.CanQuery then
                                            targetPart = descendant
                                            break
                                        end
                                    end
                                end

                                if targetPart then
                                    local basePart = item.PrimaryPart or targetPart
                                    local PartOwner = targetPart:FindFirstChild("PartOwner")
                                    local dist = (basePart.Position - hrp.Position).Magnitude

                                    local FallenY = workspace.FallenPartsDestroyHeight
                                    local targetY = (FallenY <= -50000 and -49950) or (FallenY <= -100 and -50) or -77777

                                    if dist <= 30 then
                                        if PartOwner and PartOwner.Value == plr.Name then
                                            targetPart.CFrame = CFrame.new(0, targetY, 9999)
                                        else
                                            rs.GrabEvents.SetNetworkOwner:FireServer(targetPart, CFrame.lookAt(hrp.Position, targetPart.Position))
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end

function AntiDeathF()
    local connection
    connection = rs2.Heartbeat:Connect(function()
        if not AntiDeathT then
            connection:Disconnect()
            return
        end

        local Character = plr.Character
        if not Character then return end

        local donut = inv:FindFirstChild("InstrumentPianoKeyboard")

        if not donut then
            pcall(function()
                rs.MenuToys.SpawnToyRemoteFunction:InvokeServer("InstrumentPianoKeyboard", CFrame.new(0,0,0), Vector3.new(0,0,0))
            end)
            return
        end

        if not donut:FindFirstChild("HoldPart") then return end

        local HoldItemRemoteFunction = donut.HoldPart:FindFirstChild("HoldItemRemoteFunction")
        local DropItemRemoteFunction = donut.HoldPart:FindFirstChild("DropItemRemoteFunction")

        if HoldItemRemoteFunction and DropItemRemoteFunction then
            HoldItemRemoteFunction:InvokeServer(donut, Character)
            DropItemRemoteFunction:InvokeServer(donut, CFrame.new(99999, 99999, 99999), Vector3.new(99999, 99999, 99999))
        end
    end)
end

function AntiBananaF()
    local dropPos = CFrame.new(0, -999999999, 0)
    local dropVec = Vector3.new(0, -999999999, 0)
    local plr = game.Players.LocalPlayer

    local targetItemsDict = {
        ["CupMugWhite"] = true, ["CupMugBrown"] = true, ["FoodBanana"] = true, 
        ["FoodBread"] = true, ["FoodBroccoli"] = true, ["FoodCakePink"] = true, 
        ["FoodCoconut"] = true, ["FoodDippyEgg"] = true, ["FoodDonut"] = true, 
        ["FoodFrenchFries"] = true, ["FoodHamburger"] = true, ["FoodHotdog"] = true, 
        ["FoodMayonnaise"] = true, ["FoodMeatStick"] = true, ["FoodMushroomPoison"] = true, 
        ["FoodPizzaCheese"] = true, ["FoodPizzaPepperoni"] = true, ["FoodSodaCan"] = true, 
        ["PoopPile"] = true, ["PoopPileSparkle"] = true, ["InstrumentBrassBugle"] = true, 
        ["InstrumentBrassTrumpet"] = true, ["InstrumentDrumBongos"] = true, 
        ["InstrumentDrumSnare"] = true, ["InstrumentGuitarAcoustic"] = true, 
        ["InstrumentGuitarBanjo"] = true, ["InstrumentGuitarLyre"] = true, 
        ["InstrumentGuitarUkulele"] = true, ["InstrumentGuitarViolin"] = true, 
        ["InstrumentPianoKeyboard"] = true, ["InstrumentPianoMelodica"] = true, 
        ["InstrumentVoiceMicrophone"] = true, ["InstrumentWoodwindOcarina"] = true, 
        ["InstrumentWoodwindSaxophone"] = true, ["InstrumentBrassVuvuzela"] = true
    }

    local processedItems = {} 

    local function GetMyPlotNumber()
        local plots = workspace:FindFirstChild("Plots")
        if not plots then return nil end

        for i = 1, 5 do
            local plot = plots:FindFirstChild("Plot" .. i)
            if plot then
                local plotSign = plot:FindFirstChild("PlotSign")
                if plotSign then
                    local owners = plotSign:FindFirstChild("ThisPlotsOwners")
                    if owners then
                        local ownerVal = owners:FindFirstChildOfClass("StringValue")
                        if ownerVal and ownerVal.Value == plr.Name then
                            return i
                        end
                    end
                end
            end
        end
        return nil
    end

    local function ProcessItem(item)
        if not item or not item.Parent then return end
        if processedItems[item] then return end

        local holdPart = item:FindFirstChild("HoldPart")
        if not holdPart then return end

        local holdRemote = holdPart:FindFirstChild("HoldItemRemoteFunction")
        local dropRemote = holdPart:FindFirstChild("DropItemRemoteFunction")

        if holdRemote and dropRemote then
            processedItems[item] = true

            task.spawn(function()
                local char = plr.Character
                if not char then 
                    processedItems[item] = nil 
                    return 
                end

                local success, err = pcall(function()
                    holdRemote:InvokeServer(item, char)
                    dropRemote:InvokeServer(item) --dropPos, dropVec)
                end)

                if not success or item.Parent then
                    task.wait(1)
                    if item.Parent then
                        processedItems[item] = nil
                    end
                end
            end)
        end
    end

    while AntiBananaT do
        task.wait()

        local char = plr.Character
        if not char or not char.Parent then continue end

        local myPlotNumber = GetMyPlotNumber()
        local itemsToProcess = {}

        for _, player in ipairs(game.Players:GetPlayers()) do
            if player == plr then continue end

            if WhiteListMode then
                local isWhitelisted = false
                for _, whiteName in ipairs(Whitelist) do
                    if player.Name == whiteName then
                        isWhitelisted = true
                        break
                    end
                end
                if isWhitelisted then continue end
            end

            local folder = workspace:FindFirstChild(player.Name .. "SpawnedInToys")
            if folder then
                for _, item in ipairs(folder:GetChildren()) do
                    if targetItemsDict[item.Name] then
                        table.insert(itemsToProcess, item)
                    end
                end
            end
        end

        local plotItems = workspace:FindFirstChild("PlotItems")
        if plotItems then
            for i = 1, 5 do
                if i == myPlotNumber then continue end
                local plot = plotItems:FindFirstChild("Plot" .. i)
                if plot then
                    for _, item in ipairs(plot:GetChildren()) do
                        if targetItemsDict[item.Name] then
                            table.insert(itemsToProcess, item)
                        end
                    end
                end
            end
        end

        for _, item in ipairs(itemsToProcess) do
            if not AntiBananaT then break end
            ProcessItem(item)
        end

        for item, _ in pairs(processedItems) do
            if not item.Parent then
                processedItems[item] = nil
            end
        end
    end
end

ifKickThenT = true
local anchoredCache = {}

function ifKickThenF()
    Players.PlayerAdded:Connect(function(plr)
        plr.CharacterAdded:Connect(function(char)
            local hrp = char:WaitForChild("HumanoidRootPart", 1)
            if hrp then
                anchoredCache[plr] = false
            end
        end)
    end)

    Players.PlayerRemoving:Connect(function(plr)
        if anchoredCache[plr] == true then
            local DISP = plr.DisplayName
            local NAP = plr.Name
            Rayfield:Notify({
                Title = "[ Kick ]", 
                Content = NAP .. " [ " .. DISP ..  " ]", 
                Duration = 7, 
                Image = 0
            })
        end
        anchoredCache[plr] = nil
    end)

    task.spawn(function()
        while ifKickThenT do
            for _, plr in ipairs(Players:GetPlayers()) do
                local char = plr.Character
                if char then
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        anchoredCache[plr] = hrp.Anchored == true
                    end
                end
            end
            task.wait()
        end
    end)
end
ifKickThenF()

local mouse = plr:GetMouse()
function tpF()
    local char = plr.Character
    if not char then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local hum = char:FindFirstChild("Humanoid")
    local ragdolled = hum:FindFirstChild("Ragdolled")

    local target = mouse.Target
    if not target then return end

    local currentCFrame = hrp.CFrame
    local currentRotation = CFrame.new(Vector3.zero, currentCFrame.LookVector)

    local parts = {"Head", "Torso", "Left Leg", "Right Leg", "Left Arm", "Right Arm"}
    for _, name in ipairs(parts) do
        local part = char:FindFirstChild(name)
        if part and part:IsA("BasePart") then
            part.Transparency = 0
        end
    end

    for _, obj in ipairs(char:GetChildren()) do
        if obj:IsA("Accessory") and obj.Name ~= "TypingKeyboardMyWorld" then
            for _, v in ipairs(obj:GetChildren()) do
                if v:IsA("BasePart") then
                    v.Transparency = 0
                end
            end
        end
    end

    local mouseHit = mouse.Hit
    local targetPos = mouseHit.Position + Vector3.new(0, 5, 0)
    local newCFrame = CFrame.new(targetPos) * currentRotation

    if ragdolled.Value == true then
        char:PivotTo(newCFrame)
    else
        hrp.CFrame = newCFrame
    end
end

function AntiBlobUseF()
    task.spawn(function()
        local FallenY = workspace.FallenPartsDestroyHeight
        local targetY = (FallenY <= -50000 and -49999) or (FallenY <= -100 and -99) or -77777
        local dropPos = CFrame.new(0, targetY, 9999)
        local plr = game.Players.LocalPlayer
        local targetItems = {"CreatureBlobman", "TractorRed", "TractorOrange", "TractorGreen", "SantaSleigh"}

        local processedBlobs = {}
        local cleanupInterval = 2

        while AntiBlobUseT do
            task.wait(0.1)

            local char = plr.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")

            if not char or not root or not hum then continue end

            local myPlotNumber = nil
            local plots = workspace:FindFirstChild("Plots")
            if plots then
                for i = 1, 5 do
                    local plot = plots:FindFirstChild("Plot" .. i)
                    local plotSign = plot and plot:FindFirstChild("PlotSign")
                    local owners = plotSign and plotSign:FindFirstChild("ThisPlotsOwners")
                    local ownerVal = owners and owners:FindFirstChildOfClass("StringValue")
                    if ownerVal and ownerVal.Value == plr.Name then
                        myPlotNumber = i
                        break
                    end
                end
            end

            local function collectItemsFromFolder(folder)
                local items = {}
                for _, item in ipairs(folder:GetChildren()) do
                    if item:IsA("Model") and table.find(targetItems, item.Name) then
                        if item:FindFirstChild("VehicleSeat") then
                            local vs = item:FindFirstChildOfClass("VehicleSeat")
                            if vs and vs.Occupant then 
                                if vs.Occupant == hum then
                                    table.insert(items, item)
                                end
                                continue 
                            end

                            local itemId = tostring(item:GetDebugId())
                            if not processedBlobs[itemId] then
                                table.insert(items, item)
                            end
                        end
                    end
                end
                return items
            end

            local allItems = {}
            for _, player in ipairs(game.Players:GetPlayers()) do
                if player == plr then continue end
                if WhiteListMode then
                    local inWhitelist = false
                    for _, whiteName in ipairs(Whitelist) do 
                        if player.Name == whiteName then 
                            inWhitelist = true 
                            break 
                        end 
                    end
                    if inWhitelist then continue end
                end
                local folder = workspace:FindFirstChild(player.Name .. "SpawnedInToys")
                if folder then 
                    for _, item in ipairs(collectItemsFromFolder(folder)) do 
                        table.insert(allItems, item) 
                    end 
                end
            end

            local plotItems = workspace:FindFirstChild("PlotItems")
            if plotItems then
                for i = 1, 5 do
                    if i == myPlotNumber then continue end
                    local plot = plotItems:FindFirstChild("Plot" .. i)
                    if plot then 
                        for _, item in ipairs(collectItemsFromFolder(plot)) do 
                            table.insert(allItems, item) 
                        end 
                    end
                end
            end

            for _, item in ipairs(allItems) do
                if not AntiBlobUseT then break end

                local itemId = tostring(item:GetDebugId())

                if processedBlobs[itemId] then
                    continue
                end

                local char = plr.Character
                local root = char and char:FindFirstChild("HumanoidRootPart")
                local hum = char and char:FindFirstChildOfClass("Humanoid")

                if not char or not root or not hum then break end

                local vs = item:FindFirstChildOfClass("VehicleSeat")

                if vs then
                    if vs.Occupant and vs.Occupant ~= hum then 
                        continue 
                    end

                    root.Anchored = true
                    vs:Sit(hum)

                    if hum and vs then
                    task.wait(0.1)
                    hum:ChangeState(Enum.HumanoidStateType.Running)
                    task.wait()
                    if item.PrimaryPart then item:SetPrimaryPartCFrame(dropPos) end
                    root.Anchored = false

                        if root and vs then
                            local connection
                            connection = vs.AncestryChanged:Connect(function()
                                if not vs or not vs.Parent then
                                    if connection then
                                        connection:Disconnect()
                                    end
                                    processedBlobs[itemId] = true

                                    task.delay(cleanupInterval, function()
                                        processedBlobs[itemId] = nil
                                    end)
                                end
                            end)

                            task.delay(2, function()
                                if connection then
                                    connection:Disconnect()
                                end
                                processedBlobs[itemId] = true

                                task.delay(cleanupInterval, function()
                                    processedBlobs[itemId] = nil
                                end)
                            end)
                        end
                    end

                    task.wait(0.01)
                end

                break
            end
        end
    end)
end

local TARGET_INDEX = 1

local Remotes = {
    Spawn = rs:FindFirstChild("MenuToys"):FindFirstChild("SpawnToyRemoteFunction"),
    SetOwner = rs:FindFirstChild("GrabEvents"):FindFirstChild("SetNetworkOwner"),
    Extend = rs:FindFirstChild("GrabEvents"):FindFirstChild("ExtendGrabLine"),
    Explode = rs:FindFirstChild("BombEvents"):FindFirstChild("BombExplode")
}

function LoopSnowBallF()
    if SnowballLoopThread and coroutine.status(SnowballLoopThread) ~= "dead" then
        return
    end

    if not playersInLoop1V or type(playersInLoop1V) ~= "table" then
        playersInLoop1V = {}
    end

    SnowballLoopThread = coroutine.create(function()
        while LoopSnowBallT do
            task.wait(0.1)

            local myHrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if not myHrp then
                continue
            end

            local ball = inv:FindFirstChild("BallSnowball")
            if not ball then
                task.spawn(function()
                    Remotes.Spawn:InvokeServer("BallSnowball", myHrp.CFrame * CFrame.new(0, 10, 20), Vector3.new(0, 0, 0))
                end)
                task.wait(0.15)
                continue
            end

            if #playersInLoop1V == 0 then
                task.wait(0.1)
                continue
            end

            TARGET_INDEX = TARGET_INDEX > #playersInLoop1V and 1 or TARGET_INDEX
            local targetName = playersInLoop1V[TARGET_INDEX]
            local targetPlayer = game.Players:FindFirstChild(targetName)

            if not targetPlayer or targetPlayer == plr or not targetPlayer.Character then
                table.remove(playersInLoop1V, TARGET_INDEX)
                if TARGET_INDEX > #playersInLoop1V then
                    TARGET_INDEX = 1
                end
                continue
            end

            local targetHrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not targetHrp then
                table.remove(playersInLoop1V, TARGET_INDEX)
                if TARGET_INDEX > #playersInLoop1V then
                    TARGET_INDEX = 1
                end
                continue
            end

            TARGET_INDEX = TARGET_INDEX + 1
            if TARGET_INDEX > #playersInLoop1V then
                TARGET_INDEX = 1
            end

            local ballSPart = ball:FindFirstChild("SoundPart")
            if not ballSPart then
                task.wait(0.1)
                continue
            end

            Remotes.SetOwner:FireServer(ballSPart, ballSPart.CFrame)
            task.wait(0.05)
            ballSPart.CFrame = targetHrp.CFrame

            task.wait(0.05)
            Remotes.Explode:FireServer({
                Radius = 0, 
                Color = Color3.new(0, 0, 0), 
                TimeLength = 0, 
                Model = ball, 
                Type = "SnowPoof", 
                ExplodesByFire = false, 
                MaxForcePerStudSquared = 0, 
                Hitbox = ballSPart, 
                ImpactSpeed = 0, 
                ExplodesByPointy = false, 
                DestroysModel = true, 
                PositionPart = ballSPart
            }, Vector3.new(0, 0, 0))

            task.wait(0.15)
        end

        SnowballLoopThread = nil
    end)

    coroutine.resume(SnowballLoopThread)
end

espEnabled = false
espObjects = {}
connections = {}

function PlrEspF()
    espEnabled = not espEnabled

    if espEnabled then
        for player, esp in pairs(espObjects) do
            esp:Destroy()
        end
        espObjects = {}

        for _, conn in pairs(connections) do
            conn:Disconnect()
        end
        connections = {}

        local function updateESPVisibility(player, esp)
            if not esp or not esp.Parent then return end

            if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    esp.Enabled = true
                    esp.Adornee = player.Character.HumanoidRootPart
                    if esp:FindFirstChild("bg") then
                        esp.bg.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
                    end
                else
                    esp.Enabled = false
                end
            else
                esp.Enabled = false
            end
        end

        local heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function()
            for player, esp in pairs(espObjects) do
                updateESPVisibility(player, esp)
            end
        end)
        table.insert(connections, heartbeatConnection)

        local function createESPForPlayer(player)
            if player == plr then return end

            if espObjects[player] then
                espObjects[player]:Destroy()
            end

            local billboard = Instance.new("BillboardGui")
            billboard.Name = "ProfileESP"
            billboard.Size = UDim2.new(0, 170, 0, 55)
            billboard.StudsOffset = Vector3.new(0, 4, 0)
            billboard.AlwaysOnTop = true
            billboard.Enabled = false
            billboard.Parent = game:GetService("CoreGui")

            espObjects[player] = billboard

            local bg = Instance.new("Frame")
            bg.Name = "bg"
            bg.Size = UDim2.new(1, 0, 1, 0)
            bg.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
            bg.BackgroundTransparency = 0.7
            bg.Parent = billboard

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = bg

            local shadow = Instance.new("UIStroke")
            shadow.Color = Color3.fromRGB(0, 0, 0)
            shadow.Thickness = 2
            shadow.Transparency = 0.7
            shadow.Parent = bg

            local profile = Instance.new("ImageLabel")
            profile.Size = UDim2.new(0, 45, 0, 45)
            profile.Position = UDim2.new(0, 5, 0, 5)
            profile.BackgroundTransparency = 1
            profile.Parent = billboard

            local profileCorner = Instance.new("UICorner")
            profileCorner.CornerRadius = UDim.new(1, 0)
            profileCorner.Parent = profile

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(255, 255, 255)
            stroke.Thickness = 2
            stroke.Parent = profile

            spawn(function()
                local ok, img = pcall(function()
                    return game:GetService("Players"):GetUserThumbnailAsync(
                        player.UserId,
                        Enum.ThumbnailType.HeadShot,
                        Enum.ThumbnailSize.Size100x100
                    )
                end)
                profile.Image = ok and img or "rbxasset://textures/ui/GuiImagePlaceholder.png"
            end)

            local displayName = Instance.new("TextLabel")
            displayName.Size = UDim2.new(0, 115, 0, 22)
            displayName.Position = UDim2.new(0, 55, 0, 7)
            displayName.BackgroundTransparency = 1
            displayName.Text = "[ " .. (player.DisplayName or player.Name) .. " ]"
            displayName.TextColor3 = Color3.fromRGB(255, 255, 255)
            displayName.TextSize = 17
            displayName.Font = Enum.Font.GothamBold
            displayName.TextXAlignment = Enum.TextXAlignment.Left
            displayName.TextStrokeTransparency = 0.3
            displayName.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            displayName.Parent = billboard

            local userName = Instance.new("TextLabel")
            userName.Size = UDim2.new(0, 115, 0, 18)
            userName.Position = UDim2.new(0, 55, 0, 25)
            userName.BackgroundTransparency = 1
            userName.Text = "( @" .. player.Name .. " )"
            userName.TextColor3 = Color3.fromRGB(220, 220, 220)
            userName.TextSize = 15
            userName.Font = Enum.Font.Gotham
            userName.TextXAlignment = Enum.TextXAlignment.Left
            userName.TextStrokeTransparency = 0.4
            userName.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            userName.Parent = billboard

            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                billboard.Adornee = player.Character.HumanoidRootPart
                updateESPVisibility(player, billboard)
            end
        end

        for _, player in pairs(game:GetService("Players"):GetPlayers()) do
            if player ~= plr then
                createESPForPlayer(player)
            end
        end

        local newPlayerConnection = game:GetService("Players").PlayerAdded:Connect(function(newPlayer)
            wait(0.5)
            if espEnabled and newPlayer ~= plr then
                createESPForPlayer(newPlayer)
            end
        end)
        table.insert(connections, newPlayerConnection)

        local playerRemovingConnection = game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
            if espObjects[leavingPlayer] then
                espObjects[leavingPlayer]:Destroy()
                espObjects[leavingPlayer] = nil
            end
        end)
        table.insert(connections, playerRemovingConnection)

        for _, player in pairs(game:GetService("Players"):GetPlayers()) do
            if player ~= plr then
                local charAddedConnection = player.CharacterAdded:Connect(function()
                    wait(0.5)
                    if espEnabled and espObjects[player] then
                        local hrp = player.Character:WaitForChild("HumanoidRootPart", 2)
                        if hrp then
                            espObjects[player].Adornee = hrp
                        end
                    end
                end)
                table.insert(connections, charAddedConnection)

                local charRemovingConnection = player.CharacterRemoving:Connect(function()
                    if espEnabled and espObjects[player] then
                        espObjects[player].Enabled = false
                    end
                end)
                table.insert(connections, charRemovingConnection)
            end
        end

    else
        for player, esp in pairs(espObjects) do
            esp:Destroy()
        end
        espObjects = {}
        
        for _, conn in pairs(connections) do
            conn:Disconnect()
        end
        connections = {}
    end
end

function AntiPCLDF()
    targetValueName = "[ " .. plr.DisplayName .. " ] ( @" .. plr.Name .. " )"
        while AntiPCLDT do
            task.wait()
            if not hasDetectedFirstTime and AntiPCLDT then
                for _, item in ipairs(workspace:GetChildren()) do
                    if item.Name == "PlayerCharacterLocationDetector" then
                        for _, child in ipairs(item:GetChildren()) do
                            if child:IsA("BoolValue") and child.Name == targetValueName then
                                plr.Character.HumanoidRootPart.CFrame = CFrame.new(0,999999,0)
                                task.wait(0.1)
                                plr.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Dead)
                                plr.Character:BreakJoints()
                                plr.Character.Humanoid.Health = 0
                                hasDetectedFirstTime = true
                            end
                        end
                    end
                end
            else
                if AntiPCLDT and hasDetectedFirstTime and plr.Character.Humanoid.Died:Connect() then
                if not AntiPCLDT then hasDetectedFirstTime = false end

                character = plr.Character or plr.CharacterAdded:Wait()
                CF = character:WaitForChild("Torso").CFrame
                char = plr.CharacterAdded:Wait()
                char:WaitForChild("Humanoid"):ChangeState(Enum.HumanoidStateType.Dead)
                char:BreakJoints()
                char:WaitForChild("Humanoid").Health = 0
                char:WaitForChild("Torso").CFrame = CF
                task.wait(5)

                if not AntiPCLDT then hasDetectedFirstTime = false end
            end
        end
    end
end

function TrSw()
char = plr.Character
hrp = char.HumanoidRootPart
hum = char.Humanoid

hrp.CFrame = workspace.Map.AlwaysHereTweenedObjects.Train.Object.ObjectModel.Seat.CFrame
repeat task.wait() until hum.SeatPart ~= nil

if not inv:FindFirstChild("InstrumentGuitarLyre") then
task.spawn(function()
rs.MenuToys.SpawnToyRemoteFunction:InvokeServer("InstrumentGuitarLyre", CFrame.new(0,99999,0), Vector3.new(0,99999,0))
end)
end

HPT = inv:WaitForChild("InstrumentGuitarLyre"):WaitForChild("HoldPart"):WaitForChild("RigidConstraint")

repeat
task.wait()
if inv:FindFirstChild("InstrumentGuitarLyre") then
task.spawn(function()
inv:FindFirstChild("InstrumentGuitarLyre"):FindFirstChild("HoldPart"):FindFirstChild("HoldItemRemoteFunction"):InvokeServer(inv:FindFirstChild("InstrumentGuitarLyre"), char)
end)
end
until HPT.Attachment1 ~= nil

task.wait(0.7)

if inv:FindFirstChild("InstrumentGuitarLyre") then
rs.MenuToys.DestroyToy:FireServer(inv:FindFirstChild("InstrumentGuitarLyre"))
end
end

LineLagV = 50
function LineLagF()
for i, e in game.Players:GetPlayers() do
if table.find(Whitelist, e.Name) then return end
end

while wait(0.5) and LineLagT do
for a = 0, LineLagV do
for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
if player.Character and player.Character:FindFirstChild("Torso") then
local torso = player.Character.Torso
rs.GrabEvents.CreateGrabLine:FireServer(torso, torso.CFrame)
end
end
end
end
end

RunService = game:GetService("RunService")
isvs = false

function AntiGrabTEST(enable)
    if antiGrabConn then
        antiGrabConn:Disconnect()
        antiGrabConn = nil
    end

    if not enable then 
        local char = plr.Character
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChild("Humanoid")

        if hrp and hrp.Anchored then hrp.Anchored = false end
        if hum then
            hum.RequiresNeck = true
            hum.Sit = false
            hum:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
        return 
    end

    local lastHeldState = false
    local sitHoldTimer = 0
    local shouldKeepSit = false
    local wasHeld = false
    local lastRagdollTime = 0
    local ragdollDuration = 0.48

    antiGrabConn = RunService.Heartbeat:Connect(function(deltaTime)
        local char = plr.Character
        if not char then return end

        local hum = char:FindFirstChild("Humanoid")
        isvs = hum and hum.SeatPart ~= nil

        local isHeld = plr:FindFirstChild("IsHeld")
        if not isHeld then return end

        local head = char:FindFirstChild("Head")
        local POR = head and head:FindFirstChild("PartOwner")
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hrp2 = char:FindFirstChild("Torso")
        if not hum then return end

        local FPDH = workspace.FallenPartsDestroyHeight
        local DY = (FPDH <= -50000 and -49999) or (FPDH <= -100 and -99) or -100
        local now = tick()

        if hum then
            hum.RequiresNeck = false
            hum.AutoRotate = true
        end

        if isvs and POR then
        task.wait(0.3)
        end

        if POR and POR.Value then
            local attackerName = POR.Value

            if attackerName and WhiteListMode then
                local inWhitelist = false
                for _, whiteName in ipairs(Whitelist) do
                    if whiteName == attackerName then
                        inWhitelist = true
                        break
                    end
                end
                if inWhitelist then 
                    return 
                end
            end
        end

        if isvs then task.wait(0.3) end

        local rag = hum:FindFirstChild("Ragdolled")
        if isHeld.Value == true and rag and rag.Value == true then
            for _, limbName in ipairs({"Head", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}) do
                local limb = char:FindFirstChild(limbName)
                if limb then
                    local ragdollPart = limb:FindFirstChild("RagdollLimbPart")
                    local ragdollCons = limb:FindFirstChild("BallSocketConstraint")
                    if ragdollCons then ragdollCons.Enabled = false end
                    if ragdollPart then ragdollPart.CanCollide = false end
                end
            end
        end

        if hum.Health <= 0 then
            lastHeldState = false
            shouldKeepSit = false
            sitHoldTimer = 0
            wasHeld = false
            hum.Sit = false
            hum.AutoRotate = true
        end

        if not hrp or hum.Health <= 0 then
            hum:ChangeState(Enum.HumanoidStateType.Dead)
            char:BreakJoints()
            --rs.CharacterEvents.Struggle:FireServer()
            --if hrp2 then hrp2.CFrame = CFrame.new(9999, DY, 9999) end
        end

        if isHeld.Value == true then
            if hum.MoveDirection.Magnitude > 0 then
                local moveSpeed = 10
                local moveVector = hum.MoveDirection * deltaTime * moveSpeed

                hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)

                moveVector = Vector3.new(moveVector.X, 0, moveVector.Z)
                hrp.CFrame = hrp.CFrame + moveVector
                hrp2.CFrame = hrp2.CFrame + moveVector
            end
        end

        if isHeld.Value ~= lastHeldState then
            if isHeld.Value == true then
                wasHeld = true
                shouldKeepSit = true
                sitHoldTimer = 0.3
                hum:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
                hum.Sit = true
                hum.AutoRotate = true

                lastRagdollTime = now
                if POR and hrp then
                    rs.CharacterEvents.Struggle:FireServer()
                    rs.CharacterEvents.RagdollRemote:FireServer(hrp, 0)
                end

                if hrp then
                    setRagdollF(true)
                end
            else
                if wasHeld then
                    shouldKeepSit = true
                    sitHoldTimer = 0.3
                end
            end
            lastHeldState = isHeld.Value
        end

        if lastRagdollTime > 0 and now - lastRagdollTime >= ragdollDuration then
            setRagdollF(false)
            lastRagdollTime = 0
        end

        if isHeld.Value == true and lastRagdollTime > 0 and now - lastRagdollTime < ragdollDuration then
            if hrp then 
                setRagdollF(true)
            end
        end

        if sitHoldTimer > 0 then
            sitHoldTimer = sitHoldTimer - deltaTime

            if isHeld.Value == true or POR or (rag and rag.Value == true) then
                shouldKeepSit = true
                sitHoldTimer = 0.3
                hum.Sit = true
                if isHeld.Value == true then
                    hum:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
                end
            else
                hum.Sit = true
            end
        end

        if sitHoldTimer <= 0 and shouldKeepSit then
            local currentRagdolled = hum:FindFirstChild("Ragdolled")
            if not currentRagdolled or currentRagdolled.Value == false then
                hum.Sit = false
                hum:ChangeState(Enum.HumanoidStateType.Running)
                shouldKeepSit = false
                wasHeld = false
            else
                sitHoldTimer = 0.3
            end
        end

        if shouldKeepSit then
            hum.Sit = true
        end

        if POR then
            local attackerName = POR.Value

            if attackerName and WhiteListMode then
                local inWhitelist = false
                for _, whiteName in ipairs(Whitelist) do
                    if whiteName == attackerName then
                        inWhitelist = true
                        break
                    end
                end
                if inWhitelist then 
                    return 
                end
            end

            rs.CharacterEvents.Struggle:FireServer()
            rs.CharacterEvents.RagdollRemote:FireServer(hrp, 0)
            shouldKeepSit = true
            sitHoldTimer = 0.3
            hum.Sit = true
            hum.AutoRotate = true
            lastRagdollTime = now
            if hrp then
                setRagdollF(true)
            end
        end
    end)
end

function DeleteLocalF()
    function DeleteLocalL()
        local char = plr.Character
        if not char then return false end

        local targets = {}

        for _, option in ipairs(AutoDeletePartV) do
            if option == "Leg/ì™¼ìª½" then
                local part = char:FindFirstChild("Left Leg")
                if part then table.insert(targets, part) end
            elseif option == "Leg/ì˜¤ë¥¸ìª½" then
                local part = char:FindFirstChild("Right Leg")
                if part then table.insert(targets, part) end
            elseif option == "Arm/ì™¼ìª½" then
                local part = char:FindFirstChild("Left Arm")
                if part then table.insert(targets, part) end
            elseif option == "Arm/ì˜¤ë¥¸ìª½" then
                local part = char:FindFirstChild("Right Arm")
                if part then table.insert(targets, part) end
            end
        end

        setRagdollF(true)
        task.wait(0.3)

        local success = false
        for _, part in ipairs(targets) do
            if part then
                part.CFrame = CFrame.new(0, -99999, 0)
                success = true
            end
        end

        task.wait(0.1)
        local torso = char:FindFirstChild("Torso")
        if torso then 
            rs.GrabEvents.SetNetworkOwner:FireServer(torso, torso.CFrame) 
        end

        return success
    end

    if not DeleteLocalT then return end

    task.spawn(function()
        while DeleteLocalT do 
            local success = false
            local startTime = tick()

            while tick() - startTime < 4 and not success and DeleteLocalT do
                success = DeleteLocalL()
                if not success then
                    task.wait(0.5)
                end
            end

            local humanoid = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and DeleteLocalT then
                humanoid.Died:Wait()
            end

            if DeleteLocalT then
                plr.CharacterAdded:Wait()
                task.wait(1)
            end
        end
    end)
end

plr.CharacterAdded:Connect(function(char)
    char:WaitForChild("Humanoid")
    char:WaitForChild("HumanoidRootPart")
    task.wait(0.2)
    if DeleteLocalT then
        DeleteLocalF()
    end
end)

function DeletePlayers()
    local grabParts = workspace:FindFirstChild("GrabParts")
    if not grabParts then return end

    local target = grabParts:FindFirstChild("GrabPart")
    if not target then return end

    local weldConstraint = target:FindFirstChild("WeldConstraint")
    if not weldConstraint or not weldConstraint.Part1 then return end

    local part1 = weldConstraint.Part1
    local character = part1.Parent

    if not character or character.ClassName ~= "Model" then return end

    local player = Players:GetPlayerFromCharacter(character)
    if not player then return end

    local targetParts = {}
    local partMapping = {
        ["Leg/ì™¼ìª½"] = "Left Leg",
        ["Leg/ì˜¤ë¥¸ìª½"] = "Right Leg", 
        ["Arm/ì™¼ìª½"] = "Left Arm",
        ["Arm/ì˜¤ë¥¸ìª½"] = "Right Arm"
    }

    if type(DeletePartV) == "table" then
        for _, option in ipairs(DeletePartV) do
            local partName = partMapping[option]
            if partName then
                local part = character:FindFirstChild(partName)
                if part then
                    table.insert(targetParts, part)
                end
            end
        end
    end

    for _, part in ipairs(targetParts) do
        if part then 
            part.CFrame = CFrame.new(0, -99999, 0)
        end
    end

    task.wait(0.3)

    local torso = character:FindFirstChild("Torso")
    if torso then
        torso.CFrame = CFrame.new(0, -99999, 0)
        --UnOwner:FireServer(torso)
    end
end

function DefalutSky()
Lighting = game:GetService("Lighting")

for _, obj in ipairs(Lighting:GetChildren()) do
    if obj:IsA("Sky") or obj:IsA("Atmosphere") 
    or obj:IsA("BloomEffect") or obj:IsA("ColorCorrectionEffect") 
    or obj:IsA("SunRaysEffect") then
        obj:Destroy()
    end
end

Lighting.Ambient = Color3.fromRGB(120, 120, 120)
Lighting.Brightness = 2
Lighting.ColorShift_Bottom = Color3.fromRGB(0, 0, 0)
Lighting.ColorShift_Top = Color3.fromRGB(0, 0, 0)
Lighting.EnvironmentDiffuseScale = 0
Lighting.EnvironmentSpecularScale = 0.25
Lighting.GlobalShadows = true
Lighting.OutdoorAmbient = Color3.fromRGB(200, 200, 200)
Lighting.ShadowSoftness = 0.2
Lighting.Technology = Enum.Technology.Future
Lighting.ClockTime = 14
Lighting.GeographicLatitude = 41.735
Lighting.FogColor = Color3.fromRGB(192, 192, 192)
Lighting.FogEnd = 100000
Lighting.FogStart = 0

sky = Instance.new("Sky")
sky.Parent = Lighting
sky.CelestialBodiesShown = true
sky.MoonAngularSize = 0
sky.MoonTextureId = "rbxasset://sky/moon.jpg"
sky.SkyboxBk = "rbxassetid://8995816670"
sky.SkyboxDn = "rbxassetid://8995686153"
sky.SkyboxFt = "rbxassetid://8995816670"
sky.SkyboxLf = "rbxassetid://8995816670"
sky.SkyboxRt = "rbxassetid://8995816670"
sky.SkyboxUp = "rbxassetid://8995814929"
sky.StarCount = 3000
sky.SunAngularSize = 30
sky.SunTextureId = "rbxassetid://8923082571"
end

-- =============== [ ë³´í˜¸ ëŒ€ìƒ ëª©ë¡ ] ==
local GF = {"1ove0_9"}

local Owner = {"TSB_01223", "TSB_V00V", "TSB_0VV0", "TSB_Z00Z", "TSB_0ZZ0", "Diwno2f", "Diwno2ff", "Diwno2fff", "TESTPLAYACCOUNT01", "TESTPLAYACCOUNT02", "Dhd9021el", "DM209jfda", "DJHaoidhw2dlk", "DJ029djoia", "D210ela", "iufsd2ee"}
local Overseer = {""}
local CoOwner = {""}
local HeadAdmin = {""}
local Admin = {""}
local Mod = {""}

local Ranks = {
    Owner = 7,
    GF = 6,
    Overseer = 5,
    CoOwner = 4,
    HeadAdmin = 3,
    Admin = 2,
    Mod = 1,
    User = 0
}
-- =============== ---------------- ==

local function Notify(type, playerName)
    playerName = playerName or ""
    local title = ""
    local content = ""

    if type == "Added" then
        title = "[â˜‘ï¸ ]"; content = playerName.." - ì¶”ê°€"
    elseif type == "Removed" then
        title = "[ â˜‘ï¸ ]"; content = playerName.." - ì œê±°"
    elseif type == "Self" then
        title = "[ âš ï¸ ]"; content = "ìžì‹ ì€ ì¶”ê°€ë  ìˆ˜ ì—†ì–´ìš”!"
    elseif type == "Already" then
        title = "[ ðŸ’  ]"; content = playerName.." - ì´ë¯¸ ì¶”ê°€ëì–´ìš”"
    elseif type == "NotFound" then
        title = "[ âŒ ]"; content = "ì°¾ì„ ìˆ˜ ì—†ì–´ìš”!"
    elseif type == "HigherRank" then
        title = "[ â›” ]"; content = "ê¶Œí•œì´ ë¶€ì¡±í•´ìš”!"
    elseif type == "GFE" then
        title = "[ â›” ]"; content = "ì¶”ê°€ë  ìˆ˜ ì—†ì–´ìš”!"
    end

    if Rayfield then
        Rayfield:Notify({Title = title, Content = content, Duration = 2})
    end
end

local function GetPlayerRank(playerName)
    if table.find(Owner, playerName) then return Ranks.Owner end
    if table.find(GF, playerName) then return Ranks.GF end
    if table.find(Overseer, playerName) then return Ranks.Overseer end
    if table.find(CoOwner, playerName) then return Ranks.CoOwner end
    if table.find(HeadAdmin, playerName) then return Ranks.HeadAdmin end
    if table.find(Admin, playerName) then return Ranks.Admin end
    if table.find(Mod, playerName) then return Ranks.Mod end
    return Ranks.User
end

local function findPlayer(Value)
    if not Value or Value == "" then return nil end
    Value = Value:lower()

    for _, p in ipairs(game.Players:GetPlayers()) do
        if p.Name:lower() == Value or (p.DisplayName and p.DisplayName:lower() == Value) then
            return p
        end
    end

    local matches = {}
    for _, p in ipairs(game.Players:GetPlayers()) do
        local playerNameLower = p.Name:lower()
        if playerNameLower:sub(1, #Value) == Value then
            table.insert(matches, p)
        elseif p.DisplayName then
            local displayNameLower = p.DisplayName:lower()
            if displayNameLower:sub(1, #Value) == Value then
                table.insert(matches, p)
            end
        end
    end

    if #matches == 0 then
        return nil
    elseif #matches == 1 then
        return matches[1]
    else
        return matches[1]
    end
end

local function checkPermissions(targetPlayer)
    local localPlayer = game.Players.LocalPlayer
    local myRank = GetPlayerRank(localPlayer.Name)
    local targetRank = GetPlayerRank(targetPlayer.Name)

    if targetPlayer == localPlayer then return false, "Self" end

    if myRank == Ranks.Owner then return true end

    if myRank == Ranks.Overseer and targetRank == Ranks.Owner then
        return true
    end

    if myRank == Ranks.CoOwner and targetRank == Ranks.Owner then
        return true
    end

    if targetRank == Ranks.User then
        return true
    end

    if targetRank == Ranks.GF then
        return false, "GFE"
    end

    if myRank > targetRank then
        return true
    else
        return false, "HigherRank"
    end
end

local function addToList(listTable, dropdown, inputValue, useRankCheck)
    local target = findPlayer(inputValue)
    if not target then Notify("NotFound"); return end

    if useRankCheck then
        local allowed, errorType = checkPermissions(target)
        if not allowed then Notify(errorType, target.Name); return end
    end

    if table.find(listTable, target.Name) then Notify("Already", target.Name); return end

    table.insert(listTable, target.Name)
    if dropdown then dropdown:Refresh(listTable, true) end
    Notify("Added", target.Name)
end

local function removeFromList(listTable, dropdown, inputValue, useRankCheck)
    local foundName, foundIndex = nil, nil
    inputValue = inputValue:lower()

    for i, name in ipairs(listTable) do
        if name:lower():find(inputValue, 1, true) then
            foundName = name; foundIndex = i; break
        end
    end

    if not foundName then Notify("NotFound"); return end

    if useRankCheck then
        local targetRank = GetPlayerRank(foundName)
        local localPlayer = game.Players.LocalPlayer
        local myRank = GetPlayerRank(localPlayer.Name)

        if foundName == localPlayer.Name then Notify("Self"); return end

        if myRank == Ranks.Owner then
        elseif targetRank == Ranks.User then
        elseif myRank <= targetRank then
            Notify("HigherRank", foundName); return
        end
    end

    table.remove(listTable, foundIndex)
    if dropdown then dropdown:Refresh(listTable, true) end
    Notify("Removed", foundName)
end

function AntiVoidF()
    task.spawn(function()
        while AntiVoidT do
            if not AntiNAAN then 
                workspace.FallenPartsDestroyHeight = -50000 
            else
                workspace.FallenPartsDestroyHeight = 0/0 
            end
            task.wait()
        end
        workspace.FallenPartsDestroyHeight = -100
    end)
end

function LoopAuraF()
    task.spawn(function()
        while LoopAuraT and task.wait(0.01) do
            local character = plr.Character
            if not character then continue end
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then continue end

            for _, otherPlr in ipairs(game.Players:GetPlayers()) do
                if otherPlr == plr then continue end
                local otherChar = otherPlr.Character
                if not otherChar then continue end
                local otherHrp = otherChar:FindFirstChild("HumanoidRootPart")
                if not otherHrp then continue end
                if not otherHrp.CanQuery then continue end
                local dist = (otherHrp.Position - hrp.Position).Magnitude
                if dist <= 30 then
                    rs.GrabEvents.SetNetworkOwner:FireServer(otherHrp, CFrame.lookAt(hrp.Position, otherHrp.Position))
                end
            end

            for _, folder in ipairs(workspace:GetChildren()) do
                if folder:IsA("Folder") and folder.Name:match("SpawnedInToys$") then
                    if folder.Name ~= (plr.Name .. "SpawnedInToys") then
                        for _, item in ipairs(folder:GetChildren()) do
                            if item:FindFirstChild("SoundPart") then
                                local Spart = item.SoundPart
                                local basePart = item.PrimaryPart or Spart
                                local PartOwner = Spart:FindFirstChild("PartOwner")
                                local dist = (basePart.Position - hrp.Position).Magnitude
                                if dist <= 30 and not PartOwner and Spart.CanQuery then
                                    rs.GrabEvents.SetNetworkOwner:FireServer(Spart, CFrame.lookAt(hrp.Position, Spart.Position))
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end

-- ====================================== [ ë ˆì´í•„ë“œ UI ] ì‹œìž‘
local NP = {
    TextColor = Color3.fromRGB(255,255,255),

    Background = Color3.fromRGB(20,20,20),
    Topbar = Color3.fromRGB(30,30,30),
    Shadow = Color3.fromRGB(15,15,15),

    NotificationBackground = Color3.fromRGB(25,25,25),
    NotificationActionsBackground = Color3.fromRGB(40,40,40),

    TabBackground = Color3.fromRGB(40,40,40),
    TabStroke = Color3.fromRGB(70,70,70),
    TabTextColor = Color3.fromRGB(100,100,100),
    TabBackgroundSelected = Color3.fromRGB(65,65,65),
    SelectedTabTextColor = Color3.fromRGB(255,255,255),

    ElementBackground = Color3.fromRGB(35,35,35),
    ElementBackgroundHover = Color3.fromRGB(50,50,50),
    SecondaryElementBackground = Color3.fromRGB(25,25,25),
    ElementStroke = Color3.fromRGB(60,60,60),
    SecondaryElementStroke = Color3.fromRGB(45,45,45),

    SliderBackground = Color3.fromRGB(60,60,60),
    SliderProgress = Color3.fromRGB(0,170,255),
    SliderStroke = Color3.fromRGB(0,120,200),

    ToggleBackground = Color3.fromRGB(30,30,30),

    ToggleEnabled = Color3.fromRGB(255,255,255),
    ToggleEnabledStroke = Color3.fromRGB(255,255,255),
    ToggleEnabledOuterStroke = Color3.fromRGB(255,255,255),

    ToggleDisabled = Color3.fromRGB(100, 100, 100),
    ToggleDisabledStroke = Color3.fromRGB(125, 125, 125),
    ToggleDisabledOuterStroke = Color3.fromRGB(65, 65, 65),

    DropdownSelected = Color3.fromRGB(80,80,80),
    DropdownUnselected = Color3.fromRGB(25,25,25),

    InputBackground = Color3.fromRGB(25,25,25),
    InputStroke = Color3.fromRGB(45,45,45),
    PlaceholderColor = Color3.fromRGB(150,150,150),
}

local Window = Rayfield:CreateWindow({Name = "Ftap | Np", Icon = 0, Theme = NP, ToggleUIKeybind = "T"})

-- ====================================== [ ë©”ì¸ íƒ­ ]
local Main = Window:CreateTab("ë©”ì¸", 0)

Main:CreateSection("Humanoid")

Main:CreateToggle({
    Name = "Walk Speed",
    CurrentValue = false,
    Callback = function(Value)
        walkSpeedT = Value 
        updateWalkSpeedF()
    end
})

walkSpeedV = 16
Main:CreateInput({
    Name = "â”— Value",
    CurrentValue = 16,
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        walkSpeedV = Value
        updateWalkSpeedF()
    end
})

Main:CreateToggle({
    Name = "Jump Power",
    CurrentValue = false,
    Callback = function(Value)
        jumpPowerT = Value
        updateJumpPowerF()
    end
})

jumpPowerV = 24
Main:CreateInput({
    Name = "â”— Value",
    CurrentValue = 24,
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        jumpPowerV = Value
        updateJumpPowerF()
    end
})

Main:CreateSection("Other")
Main:CreateToggle({
    Name = "Noclip",
    CurrentValue = false,
    Callback = function(Value)
        noClipT = Value
        updateNoClipF()
    end
})

Main:CreateToggle({
    Name = "Infinite jump",
    CurrentValue = false,
    Callback = function(Value)
        infJumpT = Value
        updateInfJumpF()
    end
})

Main:CreateToggle({ 
    Name = "Fly", 
    CurrentValue = false,
    Callback = function(Value)
        flyT = Value
        flyF()
    end
})

flyV = 50
Main:CreateInput({
    Name = "â”— Value",
    CurrentValue = "50",
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        flyV = Value
    end
})

-- ====================================== [ ë³´ì•ˆ íƒ­ ]
local Security = Window:CreateTab("ë³´ì•ˆ", 0)

Security:CreateSection("Friendly | Toggle")

Security:CreateToggle({
    Name = "WhiteList Mode",
    CurrentValue = false,
    Callback = function(Value)
        ForWhiteList(Value)
    end
})

Security:CreateSection("Teleport | Toggle")

Security:CreateToggle({
    Name = "Void TP - Random",
    CurrentValue = false,
    Flag = "Void TP Toggle",
    Callback = function(Value)
        if Value then
             char = game.Players.LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                originalPosition = char.HumanoidRootPart.Position
            end

            AntiGrabTP_ActiveV1 = true

            task.spawn(function()
                while AntiGrabTP_ActiveV1 and task.wait() do
                     char = game.Players.LocalPlayer.Character
                    if not char then continue end
                     hrp = char:FindFirstChild("HumanoidRootPart")
                    if not hrp then continue end

                     randomX = math.random(-999999, 999999)
                     randomZ = math.random(-999999, 999999)

                    hrp.CFrame = CFrame.new(randomX, 999999, randomZ)
                end

                if originalPosition then
                     char = game.Players.LocalPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        char.HumanoidRootPart.CFrame = CFrame.new(originalPosition)
                    end
                    originalPosition = nil
                end
            end)
        else
            AntiGrabTP_ActiveV1 = false
        end
    end
})

Security:CreateToggle({
    Name = "Loop TP - Random",
    CurrentValue = false,
    Flag = "Loop TP Toggle",
    Callback = function(Value)
        if Value then
             char = game.Players.LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                originalPosition = char.HumanoidRootPart.Position
            end

            AntiGrabTP_ActiveV2 = true

            task.spawn(function()
                while AntiGrabTP_ActiveV2 and task.wait() do
                     char = game.Players.LocalPlayer.Character
                    if not char then continue end
                     hrp = char:FindFirstChild("HumanoidRootPart")
                    if not hrp then continue end

                     randomX = math.random(-500, 500)
                     randomY = math.random(0, 500)
                     randomZ = math.random(-500, 500)

                    hrp.CFrame = CFrame.new(randomX, randomY, randomZ)
                end

                if originalPosition then
                     char = game.Players.LocalPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        char.HumanoidRootPart.CFrame = CFrame.new(originalPosition)
                    end
                    originalPosition = nil
                end
            end)
        else
            AntiGrabTP_ActiveV2 = false
        end
    end
})

Security:CreateSection("Grab | Toggle")

local AntiGrab = Security:CreateToggle({
    Name = "Anti-Grab",
    CurrentValue = false,
    Flag = "Anti-Grab Toggle",
    Callback = function(Value)
        AntiGrabF(Value)
    end
})
if _G.AntiGrab then AntiGrab:Set(true) end

local AntiRelease = Security:CreateToggle({
    Name = "Anti-Release",
    CurrentValue = false,
    Flag = "Anti-Release Toggle",
    Callback = function(Value)
        AntiDeathT = Value
        task.spawn(AntiDeathF)
    end
})
if _G.AntiRelease then AntiRelease:Set(true) end

local AutoGucci = Security:CreateToggle({
    Name = "Auto-Gucci",
    CurrentValue = false,
    Flag = "Auto-Gucci Toggle",
    Callback = function(Value)
        AutoGucciT = Value
        if AutoGucciT then
            task.spawn(AutoGucciF)
        else
            if plr.Character.Humanoid then
                plr.Character.Humanoid.Sit = true
                task.wait(0.15)
                plr.Character.Humanoid.Sit = false
            end

            sitJumpT = false

            if blobmanInstanceS then
                RepStorage.MenuToys.DestroyToy:FireServer(blobmanInstanceS)
                blobmanInstanceS = nil
            end
        end
    end
})
if _G.AutoGucci then AutoGucci:Set(true) end

Security:CreateToggle({
    Name = "Train Gucci",
    CurrentValue = false,
    Flag = "Train-Gucci Toggle",
    Callback = function(Value)
        AutoGucciTV2 = Value
        if AutoGucciTV2 then
            task.spawn(AutoGucciFV2)
        else
            char = plr.Character
            if char then
                hum = char:FindFirstChild("Humanoid")
                if hum then
                    hum.Sit = true
                    task.wait(0.15)
                    hum.Sit = false
                end
            end
            sitJumpT = false
        end
    end
})

Security:CreateSection("Blob | Toggle")
local AntiBlob = Security:CreateToggle({
    Name = "Anti-Blob",
    CurrentValue = false,
    Flag = "Anti-Blob Toggle",
    Callback = function(Value)
        AntiBlobT = Value
        AntiBlobF()
    end
})
if _G.AntiBlob then AntiBlob:Set(true) end

local AntiMassless = Security:CreateToggle({
    Name = "Anti-Massless",
    CurrentValue = false,
    Flag = "Anti-Massless Toggle",
    Callback = function(Value)
        masslessT = Value
        masslessF()
    end
})
if _G.AntiMassless then AntiMassless:Set(true) end

Security:CreateSection("Plot | Toggle")
local AntiInPlots = Security:CreateToggle({
    Name = "Anti-InPlots",
    CurrentValue = false,
    Flag = "Anti-InPlots Toggle",
    Callback = function(Value)
        antiInPlotsEnabled = Value
        task.spawn(antiInPlotsLoop)
    end
})
if _G.AntiInPlot then AntiInPlots:Set(true) end

Security:CreateSection("Game | Toggle")
local AntiVoid = Security:CreateToggle({
    Name = "Anti-Void",
    CurrentValue = false,
    Flag = "Anti-Void Toggle",
    Callback = function(Value)
        AntiVoidT = Value
        AntiVoidF()
    end
})
if _G.AntiVoid then AntiVoid:Set(true) end

local AntiVoidNAN = Security:CreateToggle({
    Name = "â”— [ NaN ]",
    CurrentValue = false,
    Flag = "Anti-Void NaN Mode Toggle",
    Callback = function(Value)
        AntiNAAN = Value
    end
})
if _G.AntiVoidNaN then AntiVoidNAN:Set(true) end

local AntiExplosion = Security:CreateToggle({
    Name = "Anti-Explosion",
    CurrentValue = false,
    Flag = "Anti-Explosion Toggle",
    Callback = function(Value)
        AntiExplosionT = Value
        if Value then
            AntiExplosionF()
        elseif AntiExplosionC then
            AntiExplosionC:Disconnect()
            AntiExplosionC = nil
        end
    end
})
if _G.AntiExplosion then AntiExplosion:Set(true) end

local AntiBurn = Security:CreateToggle({
    Name = "Anti-Burn",
    CurrentValue = false,
    Flag = "Anti-Burn Toggle",
    Callback = function(Value)
        AntiBurnV = Value
        AntiBurn()
    end
})
if _G.AntiBurn then AntiBurn:Set(true) end

local AntiPaint = Security:CreateToggle({
    Name = "Anti-Paint",
    CurrentValue = false,
    Flag = "Anti-Paint Toggle",
    Callback = function(Value)
        AntiPaintT = Value
        antiPaintF(Value)
    end
})
if _G.AntiPaint then AntiPaint:Set(true) end

if _G.AntiLagAutoMode then antiLagMode = true end

local AntiLag = Security:CreateToggle({
    Name = "Anti-Lag",
    CurrentValue = false,
    Flag = "Anti-Lag Toggle",
    Callback = function(Value)
        antiLagEnabled = Value
        AntiLagF()
    end
})
if _G.AntiLag then AntiLag:Set(true) end

local AntiLagAutoMode = Security:CreateToggle({
    Name = "â”— [ Auto Mode ]",
    CurrentValue = false,
    Flag = "Anti-Lag Auto Mode Toggle",
    Callback = function(Value)
        antiLagMode = Value
        AntiLagF()
    end
})
if _G.AntiLagAutoMode then AntiLagAutoMode:Set(true) end

local AutoAttack = Security:CreateToggle({
    Name = "Auto-Attacker",
    CurrentValue = false,
    Flag = "Auto-Attacker Toggle",
    Callback = function(Value)
        AutoAttackT = Value
        AutoAttackF()
    end
})
if _G.AutoAttacker then AutoAttack:Set(true) end

Security:CreateDropdown({
    Name = "â”— Select",
    Options = {"ì•Œë¦¼", "ë‚ ë¦¬ê¸°", "ì£½ì´ê¸°", "ê³µí—ˆ ì´ë™",  "ìŠ¤í° ì´ë™", "ë°”ë‹¤ ì´ë™", "ìœ„í—˜êµ¬ì—­ ì´ë™", "ê°ì˜¥ ì´ë™", "ê° ë””ë¡œ ì¶”ê°€í•˜ê³  ì‹¶ì€ê±° ìžˆìœ¼ë©´ ì•Œë ¤ì£¼ì„¸ìš”."},
    MultipleOptions = true,
    Callback = function(Value)
        AutoAttackerV = Value
    end
})

local AntiHoldPart = Security:CreateToggle({
    Name = "Anti-HoldPart",
    CurrentValue = false,
    Flag = "Anti-HoldPart Toggle",
    Callback = function(Value)
        AntiBananaT = Value
        task.spawn(AntiBananaF)
    end
})
if _G.AntiHoldPart then AntiHoldPart:Set(true) end

local AntiVehicleToy = Security:CreateToggle({
    Name = "Anti-Vehicle Toy",
    CurrentValue = false,
    Flag = "Anti-Vehicle Toy Toggle",
    Callback = function(Value)
        AntiBlobUseT = Value
        AntiBlobUseF()
    end
})
if _G.AntiVehicleToy then AntiVehicleToy:Set(true) end

Security:CreateSection("Kick | Toggle")

local FlyingReset = Security:CreateToggle({
    Name = "Anti-Flying { Reset }",
    CurrentValue = false,
    Flag = "Anti-Fling Toggle",
    Callback = function(Value)
        if Value then
            rs.GameCorrectionEvents.GameCorrectionsNotify.OnClientEvent:Connect(function(Type)
                if Type == "Flying" then
                    char = plr.Character
                    hum = char:FindFirstChildOfClass("Humanoid")
                    hrp = char:FindFirstChildOfClass("HumanoidRootPart")

                    rs.CharacterEvents.Struggle:FireServer()
                    hum.Health = 0
                    hum:ChangeState(Enum.HumanoidStateType.Dead)
                    char:BreakJoints()
                end
            end)
        end
    end
})
if _G.AntiFlying then FlyingReset:Set(true) end

local AntiKickStickyPart = Security:CreateToggle({
    Name = "Anti-Kick { StickyPart }",
    CurrentValue = false,
    Flag = "Anti-Kick StickyPart Toggle",
    Callback = function(Value)
        AntiKickT = Value
        task.spawn(AntiKickF)
    end
})

if _G.AntiKickStickyPart then AntiKickStickyPart:Set(true) end

Security:CreateButton({
    Name = "Anti-Kick { StickyPart House }",
    Callback = function()
        House()

        plotItemsFolder = workspace.PlotItems:FindFirstChild("Plot"..Plot)
        TP = workspace.Plots["Plot"..Plot].PlotArea
        targetCFrame = CFrame.new(TP.Position)

        char = plr.Character
        if not char then return end

        hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        ragdollHitbox = hrp:FindFirstChild("RagdollTouchedHitbox")
        if ragdollHitbox then
            hrp = ragdollHitbox
        end

        originalPosition = hrp.CFrame

        targetValue = CFrame.new(0.05, -0.3, 0.3) * CFrame.Angles(190, 0, 0)
        stickyPartName = "NinjaShuriken"

        if plotItemsFolder then
            closestShuriken = nil
            closestDistance = math.huge

            for _, item in pairs(plotItemsFolder:GetChildren()) do
                if item.Name == "NinjaShuriken" then
                    stickyPart = item:FindFirstChild("StickyPart")
                    if stickyPart then
                        distance = (hrp.Position - stickyPart.Position).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestShuriken = item
                        end
                    end
                end
            end

            if closestShuriken and closestDistance <= 30 then
                stickyPart = closestShuriken:FindFirstChild("StickyPart")
                if stickyPart then
                    FIND2 = stickyPart:FindFirstChild("StickyWeld")

                    if not FIND2 or (FIND2 and FIND2.Part1 ~= hrp) then
                        if not plr.InPlot.Value then
                            hrp.CFrame = targetCFrame
                            task.wait(0.5)
                        end

                        pcall(function()
                            SetOwner:FireServer(stickyPart, stickyPart.CFrame)
                        end)

                        pcall(function()
                            StickyPartEvent:FireServer(stickyPart, hrp, targetValue)
                        end)

                        hrp.CFrame = originalPosition
                    end
                end
            else
                if not plr.InPlot.Value then
                    hrp.CFrame = targetCFrame
                    task.wait(0.5)
                end

                task.spawn(function()
                    SpawnToy:InvokeServer(stickyPartName, hrp.CFrame * CFrame.new(0,20,15), Vector3.new(0,0,0))
                end)

                task.wait(0.15)

                newFind = plotItemsFolder:FindFirstChild("NinjaShuriken")
                if newFind then
                    stickyPart = newFind:FindFirstChild("StickyPart")
                    if stickyPart then
                        pcall(function()
                            SetOwner:FireServer(stickyPart, stickyPart.CFrame)
                        end)

                        pcall(function()
                            StickyPartEvent:FireServer(stickyPart, hrp, targetValue)
                        end)
                    end
                end
            end

            hrp.CFrame = originalPosition
        end
    end
})

local AntiKickPCLD = Security:CreateToggle({
    Name = "Anti-Kick { PCLD }",
    CurrentValue = false,
    Flag = "Anti-Kick PCLD Toggle",
    Callback = function(Value)
        AntiPCLDT = Value
        task.spawn(AntiPCLDF)
    end
})
if _G.AntiKickPCLD then AntiKickPCLD:Set(true) end

Security:CreateSection("Ragdoll | Toggle")

Security:CreateToggle({
    Name = "Ragdoll",
    CurrentValue = false,
    Flag = "Ragdoll Toggle",
    Callback = function(Value)
        permRagdollT = Value
        if permRagdollT and not permRagdollRunningS then
            coroutine.wrap(permRagdollLoopF)()
        elseif not permRagdollT then
            permRagdollRunningS = false
        end
    end
})

Security:CreateToggle({
    Name = "Ragdoll Value",
    CurrentValue = false,
    Flag = "Ragdoll Value Toggle",
    Callback = function(Value)
        ragdollRunning = Value
        task.spawn(ragdollLoopF2)
    end
})

Security:CreateToggle({
    Name = "Ragdoll Walk",
    CurrentValue = false,
    Flag = "Ragdoll Walk Toggle",
    Callback = function(Value)
        RagdollWalkT = Value
        RagdollWalk()
    end
})

Security:CreateSection("Delete | Toggle")

Security:CreateToggle({
    Name = "Auto-HipHeight",
    CurrentValue = false,
    Flag = "Auto-HipHeight Toggle",
    Callback = function(Value)
        ToggleActive = Value
        StartMonitoring()
    end
})

Security:CreateToggle({
    Name = "Delete { Local }",
    CurrentValue = false,
    Flag = "Auto-Delete Toggle",
    Callback = function(Value)
        DeleteLocalT = Value
        DeleteLocalF()
    end
})

Security:CreateDropdown({
    Name = "â”— Select",
    Options = {"Leg/ì™¼ìª½", "Leg/ì˜¤ë¥¸ìª½", "Arm/ì™¼ìª½", "Arm/ì˜¤ë¥¸ìª½"},
    MultipleOptions = true,
    Callback = function(Value)
        AutoDeletePartV = Value
    end
})

-- ====================================== [ ê·¸ëž© íƒ­ ]
local Grab = Window:CreateTab("ê·¸ëž©", 0)

Grab:CreateSection("Grab")

Grab:CreateToggle({
    Name = "Fling",
    CurrentValue = false,
    Callback = function(Value)
        flingT = Value
        flingF()
    end
})

Grab:CreateInput({
    Name = "â”— Strength",
    CurrentValue = "",
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        strengthV = Value
    end
})

Grab:CreateToggle({
    Name = "Extend Line",
    CurrentValue = false,
    Callback = function(Value)
        infLineExtendT = Value
        infLineExtendF()
    end
})

Grab:CreateInput({
    Name = "â”— Extend Speed",
    CurrentValue = "",
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        increaseLineExtendV = Value
    end
})

Grab:CreateSection("Other")

Grab:CreateKeybind({
    Name = "Delete { Players }",
    CurrentKeybind = "Q",
    HoldToInteract = false,
    Callback = function()
        DeletePlayers()
    end
})

Grab:CreateDropdown({
    Name = "â”— Select",
    Options = {"Leg/ì™¼ìª½", "Leg/ì˜¤ë¥¸ìª½", "Arm/ì™¼ìª½", "Arm/ì˜¤ë¥¸ìª½"},
    MultipleOptions = true,
    Callback = function(Value)
        DeletePartV = Value
    end
})

Grab:CreateToggle({
    Name = "Loop Grab",
    CurrentValue = false,
    Callback = function(Value)
        AntiStruggleGrabT = Value
        AntiStruggleGrabF()
    end
})

Grab:CreateToggle({
    Name = "Ragdoll Grab",
    CurrentValue = false,
    Callback = function(Value)
        RagdollGrabT = Value
        RagdollGrabF()
    end
})

Grab:CreateToggle({ 
    Name = "Massless Grab", 
    CurrentValue = false,
    Callback = function(Value)
        MasslessGrabT = Value
        MasslessGrabF()
    end
})

Grab:CreateToggle({ 
    Name = "Noclip Grab", 
    CurrentValue = false,
    Callback = function(Value)
        NoClipGrabT = Value
        NoClipGrabF()
    end
})

Grab:CreateToggle({ 
    Name = "Kill Grab", 
    CurrentValue = false,
    Callback = function(Value)
        KillGrabT = Value
        KillGrabF()
    end
})

Grab:CreateToggle({
    Name = "â”— [ Void ]",
    CurrentValue = false,
    Callback = function(Value)
        TpKLG = Value
    end
})

Grab:CreateToggle({
    Name = "Kick Grab",
    CurrentValue = false,
    Callback = function(Value)
        KickGrabT = Value
        KickGrabF()
    end
})

Grab:CreateToggle({
    Name = "â”— [ Anchored ]",
    CurrentValue = false,
    Callback = function(Value)
        AnhKick = Value
    end
})

-- ====================================== [ ì•„ìš°ë¼ íƒ­ ]
local Aura = Window:CreateTab("ì•„ìš°ë¼", 0)

Aura:CreateToggle({
    Name = "Loop Grab Aura",
    CurrentValue = false,
    Callback = function(Value)
        LoopAuraT = Value
        LoopAuraF()
    end
})

Aura:CreateToggle({
    Name = "Anti-Sound Toy Aura",
    CurrentValue = false,
    Callback = function(Value)
        AntiBoxT = Value
        if Value then
            AntiBoxF()
        end
    end
})

Aura:CreateDropdown({
    Name = "â”— Select",
    Options = {"MidiMaker", "SoundWaveMaker", "Boombox", "JukeboxðŸŸ¦", "JukeboxðŸŸ§"},
    MultipleOptions = true,
    Callback = function(Value)
        AntiBoxV = Value
    end
})

Aura:CreateToggle({
    Name = "Anti-Banana Aura",
    CurrentValue = false,
    Callback = function(Value)
        AntiBananaAuraT = Value
        AntiBananaAuraF()
    end
})

Aura:CreateToggle({
    Name = "Anti-StickyPart Aura",
    CurrentValue = false,
    Callback = function(Value)
        ViewAuraT = Value
        ViewAuraF()
    end
})

Aura:CreateToggle({
    Name = "Anti-Seated Aura",
    CurrentValue = false,
    Callback = function(Value)
        AntiSeatedT = Value
        AntiSeatedF()
    end
})

-- ====================================== [ ë¦¬ìŠ¤íŠ¸ íƒ­ ]
local List = Window:CreateTab("ë¦¬ìŠ¤íŠ¸", 0)

local Dropdown = List:CreateDropdown({
    Name = "White List",
    Options = Whitelist,
    MultipleOptions = true,
    Callback = function(Options)
        Whitelist = Options
    end
})

List:CreateInput({
    Name = "â”— Add",
    PlaceholderText = "...",
    RemoveTextAfterFocusLost = true,
    Callback = function(Value)
        addToList(Whitelist, Dropdown, Value, false) 
    end
})

List:CreateInput({
    Name = "â”— Remove",
    PlaceholderText = "...",
    RemoveTextAfterFocusLost = true,
    Callback = function(Value)
        removeFromList(Whitelist, Dropdown, Value)
    end
})

List:CreateSection("")

local DropdownV1 = List:CreateDropdown({
    Name = "Loop List",
    Options = playersInLoop1V,
    MultipleOptions = true,
    Callback = function(Options)
        playersInLoop1V = Options
    end
})

List:CreateInput({
    Name = "â”— Add",
    PlaceholderText = "...",
    RemoveTextAfterFocusLost = true,
    Callback = function(Value)
        addToList(playersInLoop1V, DropdownV1, Value, true)
    end
})

List:CreateInput({
    Name = "â”— Remove",
    PlaceholderText = "...",
    RemoveTextAfterFocusLost = true,
    Callback = function(Value)
        removeFromList(playersInLoop1V, DropdownV1, Value)
    end
})

-- ====================================== [ ì‹¤í–‰ íƒ­ ]
local Exec = Window:CreateTab("ì‹¤í–‰", 0)

Exec:CreateSection("Bring")
Exec:CreateButton({
    Name = "Bring { Blobman }",
    Callback = function()
        UpdateCurrentBlobman()
         processedHumanoids = {}

         function processPlayer(player)
            if not player then return false end

            local character, hrp, head = safeGetCharacterParts(player)
            if not hrp or not head then return false end

            local myChar = plr.Character
            local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if not myHrp then return false end
            local originCF = myHrp.CFrame

        TP(player)
        task.wait(0.25)
        BlobGrab(currentBlobS, hrp, "Right")
        BlobRelease(currentBlobS, hrp, "Right")

        task.wait(0.15)

        if originCF then
            hrp.CFrame = originCF * CFrame.new(0,5,0)
            myHrp.CFrame = originCF
        end

        task.wait(0.3)

        rs.GrabEvents.SetNetworkOwner:FireServer(hrp, hrp.CFrame)
        rs.GrabEvents.DestroyGrabLine:FireServer(hrp, hrp.CFrame)

            if originCF then BACK(originCF) end
            return true
        end

        table.clear(playersInLoop2V)
        for i, e in ipairs(playersInLoop1V) do
             nameOnly = e:match("^(.-) %(") or e
            table.insert(playersInLoop2V, nameOnly)
        end

        for _, name in ipairs(playersInLoop2V) do
             player = game.Players:FindFirstChild(name)
            if player and not table.find(Whitelist, player.Name) then
                 character = player.Character
                 humanoid = character and character:FindFirstChildOfClass("Humanoid")
                if PPs:FindFirstChild(name) then continue end

                if humanoid and humanoid.Health > 0 then
                    if processedHumanoids[player] ~= humanoid then
                         success = processPlayer(player)
                        if success then
                            processedHumanoids[player] = humanoid
                        end
                    end
                else
                    processedHumanoids[player] = nil
                end
                task.wait()
            end
        end
    end
})

Exec:CreateButton({
    Name = "Bring { Owner }",
    Callback = function()
        UpdateCurrentBlobman()
         processedHumanoids = {}
         activeThreads = {}

         function processPlayer(player)
            if not player then return false end

            local myChar = plr.Character
            local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
            local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
            if not myChar or not myHrp or not myHum or myHum.Health <= 0 then
                return false
            end

            local character, hrp, head = safeGetCharacterParts(player)
            if not hrp or not head then return false end

             characterParts = {}

            table.insert(characterParts, hrp)

            if character:FindFirstChild("Head") then
                table.insert(characterParts, character.Head)
            end

             torsoParts = {"Torso"}
            for _, partName in ipairs(torsoParts) do
                 part = character:FindFirstChild(partName)
                if part then
                    table.insert(characterParts, part)
                end
            end

             armParts = {
                "Left Arm", "Right Arm"
            }
            for _, partName in ipairs(armParts) do
                 part = character:FindFirstChild(partName)
                if part then
                    table.insert(characterParts, part)
                end
            end

             legParts = {
                "Left Leg", "Right Leg"
            }
            for _, partName in ipairs(legParts) do
                 part = character:FindFirstChild(partName)
                if part then
                    table.insert(characterParts, part)
                end
            end

             originCF = myHrp.CFrame

             tpRunning = true
             tpThread = task.spawn(function()
                while tpRunning do
                    if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") or 
                       (plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").Health <= 0) then
                        break
                    end

                     ok, cf = TP(player)
                    if ok and cf then
                        CF = cf
                    end
                    task.wait()
                end
            end)
            table.insert(activeThreads, tpThread)

             success = false
             startTime = tick()
             timeout = 10

            while tpRunning and tick() - startTime < timeout do
                if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") or 
                   (plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").Health <= 0) then
                    break
                end

                if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") or 
                   (player.Character:FindFirstChildOfClass("Humanoid") and player.Character:FindFirstChildOfClass("Humanoid").Health <= 0) then
                    break
                end

                for _, part in ipairs(characterParts) do
                    if part and part.Parent then
                        rs.GrabEvents.SetNetworkOwner:FireServer(part, part.CFrame)
                    end
                end
                
                 ownerTag = head:FindFirstChild("PartOwner")
                if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                    success = true
                    break
                end
                task.wait()
            end

            tpRunning = false

            for _, thread in ipairs(activeThreads) do
                if coroutine.status(thread) ~= "dead" then
                    task.cancel(thread)
                end
            end
            table.clear(activeThreads)

            if originCF and myHrp and myHrp.Parent then
                myHrp.CFrame = originCF
                task.wait()
            end

            if success then
                for _, part in ipairs(characterParts) do
                    if part and part.Parent and myHrp and myHrp.Parent then
                        part.CFrame = myHrp.CFrame
                    end
                end
            end

            if originCF and myHrp and myHrp.Parent then 
                BACK(originCF) 
            end
            
            return success
        end

        table.clear(playersInLoop2V)
        for i, e in ipairs(playersInLoop1V) do
             nameOnly = e:match("^(.-) %(") or e
            table.insert(playersInLoop2V, nameOnly)
        end

        for _, name in ipairs(playersInLoop2V) do
             myChar = plr.Character
             myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
            if not myChar or not myHum or myHum.Health <= 0 then
                break
            end

             player = game.Players:FindFirstChild(name)
            if player and not table.find(Whitelist, player.Name) then
                 character = player.Character
                 humanoid = character and character:FindFirstChildOfClass("Humanoid")
                if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end

                if humanoid and humanoid.Health > 0 then
                    if processedHumanoids[player] ~= humanoid then
                         success = processPlayer(player)
                        if success then
                            processedHumanoids[player] = humanoid
                        end
                    end
                else
                    processedHumanoids[player] = nil
                end
                task.wait(0.003)
            end
        end
    end
})

Exec:CreateSection("Owner Kick")

Exec:CreateInput({
    Name = "X Y Z",
    CurrentValue = "0,20,0",
    PlaceholderText = "",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
         x, y, z = string.match(Value, "([%d.-]+),([%d.-]+),([%d.-]+)")
        if x and y and z then
            OLTPValue = Vector3.new(tonumber(x), tonumber(y), tonumber(z))
        else
        end
    end
})

Exec:CreateToggle({
    Name = "Loop Owner Kick",
    CurrentValue = false,
    Callback = function(Value)
        blobLoopT4 = Value
        if blobLoopT4 then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                 nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerBlobF4()
        else
            blobLoopT4 = false
            table.clear(playersInLoop2V)
        end
    end
})

Exec:CreateToggle({
    Name = "â”£ [ No Anchored ]",
    CurrentValue = false,
    Callback = function(Value)
        OwnerKickMODED = Value
    end
})

Exec:CreateToggle({
    Name = "â”£ [ Loop Bring ]",
    CurrentValue = false,
    Callback = function(Value)
        OnlyOwner = Value
    end
})

Exec:CreateToggle({
    Name = "â”£ [ Torso Anchored ]",
    CurrentValue = false,
    Callback = function(Value)
        SkipOL = Value
    end
})

Exec:CreateToggle({
    Name = "â”— [ Sit ]",
    CurrentValue = false,
    Callback = function(Value)
        SitMODED = Value
    end
})

Exec:CreateSection("Blobman")

Exec:CreateButton({
    Name = "Massless = false [ 1 ]",
    Callback = function()

        Players = game:GetService("Players")

        if #playersInLoop1V == 0 then return end

         Tname = playersInLoop1V[1]
         Tplr = Players:FindFirstChild(Tname)
        if not Tplr or not Tplr.Character then return end

         Tchar = Tplr.Character
         THRP = Tchar:FindFirstChild("HumanoidRootPart")
        if not THRP then return end

        if THRP.Massless then THRP.Massless = false end

    end
})

Exec:CreateToggle({
    Name = "Loop Kick { Blobman }",
    CurrentValue = false,
    Callback = function(Value)
        blobLoopT = Value
        if blobLoopT then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                 nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerBlobF()
        else
            blobLoopT = false
            table.clear(playersInLoop2V)

            for _, player in ipairs(game.Players:GetPlayers()) do
                if player.Character then
                     head = player.Character:FindFirstChild("Head")
                    if head then
                         kick = head:FindFirstChild("Kick")
                        if kick and kick:IsA("BodyPosition") then
                            kick:Destroy()
                        end
                    end
                end
            end
        end
    end
})

Exec:CreateToggle({
    Name = "Loop Kill { Blobman }",
    CurrentValue = false,
    Callback = function(Value)
        blobLoopT3 = Value
        if blobLoopT3 then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                 nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerBlobF3()
        else
            blobLoopT3 = false
            table.clear(playersInLoop2V)
        end
    end
})

Exec:CreateToggle({
    Name = "Loop Grab { Blobman }",
    CurrentValue = false,
    Callback = function(Value)
        blobLoopT2 = Value
        if blobLoopT2 then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                 nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerBlobF2()
        else
            blobLoopT2 = false
            table.clear(playersInLoop2V)
        end
    end
})

Exec:CreateToggle({
    Name = "â”£ [ Sit ]",
    CurrentValue = false,
    Callback = function(Value)
        LoopBringMODED = Value
    end
})

Exec:CreateToggle({
    Name = "â”— [ Anti-InPlots ]",
    CurrentValue = false,
    Callback = function(Value)
        LoopReleaseMODED = Value
    end
})

Exec:CreateSection("Owner")

Exec:CreateToggle({
    Name = "Loop Kill { Owner }",
    CurrentValue = false,
    Callback = function(Value)
        loopPlayerT = Value
        if loopPlayerT then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                 nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerF()
        else
            loopPlayerT = false
            table.clear(playersInLoop2V)
        end
    end
})

Exec:CreateToggle({
    Name = "Loop Kick { Owner }",
    CurrentValue = false,
    Callback = function(Value)
        loopPlayerT2 = Value
        if loopPlayerT2 then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                 nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerF2()
        else
            loopPlayerT2 = false
            table.clear(playersInLoop2V)
        end
    end
})

Exec:CreateSection("Fun")
Exec:CreateToggle({
    Name = "Explode { SnowBall }",
    CurrentValue = false,
    Callback = function(Value)
        LoopSnowBallT = Value
        LoopSnowBallF()
    end
})

Exec:CreateButton({
    Name = "BlackHole { NinjaKunai }",
    Callback = function()
         Players = game:GetService("Players")
         plr = Players.LocalPlayer

        if #playersInLoop1V == 0 then
            return
        end

         targetPlayerName = playersInLoop1V[1]
         targetPlayer = Players:FindFirstChild(targetPlayerName)

        if not targetPlayer or not targetPlayer.Character then
            return
        end

         targetCharacter = targetPlayer.Character
         targetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")

        if not targetHRP then
            return
        end

         ragdollHitbox = targetHRP:FindFirstChild("RagdollTouchedHitbox")
        if not ragdollHitbox then
            ragdollHitbox = targetHRP
            for _, child in ipairs(targetHRP:GetChildren()) do
                if child.Name:find("Hitbox") or child.Name:find("Attachment") or child:IsA("Attachment") then
                    ragdollHitbox = child
                    break
                end
            end
        end

         character = plr.Character or plr.CharacterAdded:Wait()
         hrp = character:WaitForChild("HumanoidRootPart")
         torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")

        if not torso then
            return
        end

        function GetPlotNumber()
             char = plr.Character
            if not char then return nil end

            if char.Parent == workspace then 
                return nil
            elseif char.Parent.Name == "PlayersInPlots" then
                for _, plot in workspace.Plots:GetChildren() do
                     plotSign = plot:FindFirstChild("PlotSign")
                    if plotSign and plotSign:FindFirstChild("ThisPlotsOwners") then
                        for _, owner in plotSign.ThisPlotsOwners:GetChildren() do
                            if owner.Value == plr.Name then
                                if plot.Name == "Plot1" then
                                    return 1
                                elseif plot.Name == "Plot2" then
                                    return 2
                                elseif plot.Name == "Plot3" then
                                    return 3
                                elseif plot.Name == "Plot4" then
                                    return 4
                                elseif plot.Name == "Plot5" then
                                    return 5
                                end
                            end
                        end
                    end
                end
            end
            return nil
        end

        function GetInventory()
             plotNumber = GetPlotNumber()

            if plotNumber then
                 plotItems = workspace:FindFirstChild("PlotItems")
                if plotItems then
                     plotFolder = plotItems:FindFirstChild("Plot" .. plotNumber)
                    if plotFolder then
                        return plotFolder
                    end
                end
            end
            
             defaultInv = workspace:FindFirstChild(plr.Name .. "SpawnedInToys")
            if defaultInv then
                return defaultInv
            end
            
            return nil
        end

        function createAndAttachKunai()
            while not plr.CanSpawnToy.Value do 
                task.wait(0.1) 
            end

             position = hrp.CFrame

            local success, result = pcall(function()
                return task.spawn(function()
                    return SpawnToy:InvokeServer("NinjaKunai", hrp.CFrame * CFrame.new(0, 5, 15), Vector3.new(0, 0, 0))
                end)
            end)
            
            if not success then
                return nil
            end

            task.wait(0.2)

             inv = GetInventory()
            if not inv then
                return nil
            end

            local kunai
             children = inv:GetChildren()
            for i = #children, 1, -1 do
                if children[i].Name == "NinjaKunai" then
                    kunai = children[i]
                    break
                end
            end

            if not kunai then 
                return nil 
            end

             stickyPart = kunai:WaitForChild("StickyPart")
             SoundPart = kunai:WaitForChild("SoundPart")

            if stickyPart and SoundPart then
                pcall(function()
                    SetOwner:FireServer(SoundPart, CFrame.lookAt(torso.Position, SoundPart.Position))
                end)
            end

            if stickyPart then
                 attachPosition = ragdollHitbox.CFrame
                 relativeCF = ragdollHitbox.CFrame:ToObjectSpace(attachPosition)

                pcall(function()
                    StickyPartEvent:FireServer(stickyPart, ragdollHitbox, CFrame.new(0,50,0)* CFrame.Angles(190, 0, 0))
                end)
            end

            task.wait(0.1)
            return kunai
        end

        for i = 1, 12 do
            createAndAttachKunai()
            task.wait(0.15)
        end
    end
})

-- ====================================== [ ê¸°íƒ€ íƒ­ ]
local Misc = Window:CreateTab("ê¸°íƒ€", 0)

Misc:CreateSection("TP")

Value = nil
Misc:CreateInput({
   Name = "Set Y",
   CurrentValue = "",
   PlaceholderText = "Value",
   RemoveTextAfterFocusLost = false,
   Callback = function(Text)
      num = tonumber(Text)
      if num then
         Value = num
      else
         Value = nil
      end
   end
})

Misc:CreateButton({
   Name = "â”— Teleport",
   Callback = function()
      if not Value then return end
      hrp = plr.Character:WaitForChild("HumanoidRootPart")
      pos = hrp.Position
      hrp.CFrame = CFrame.new(pos.X, Value, pos.Z)
   end
})

teleportLocations = {
    ["ìŠ¤í°"] = {0, -7, 0},
    ["ìŠ¤í°ì‚°"] = {494, 163, 175},
    ["ì„¤ì‚°"] = {-394, 230, 509},
    ["í—›ê°„(ë†ì§€)"] = {-156, 59, -291},
    ["ìœ„í—˜êµ¬ì—­"] = {125, -7, 241},
    ["í•˜ëŠ˜ì„¬"] = {63, 346, 309},
    ["í°ë™êµ´"] = {-240, 29, 554},
    ["ìž‘ì€ë™êµ´"] = {-84, 14, -310},
    ["ì—´ì°¨ë™êµ´"] = {602, 45, -175},
    ["ê´‘ì‚°"] = {-308, -7, 506},
    ["ì´ˆë¡ì§‘"] = {-352, 98, 353},
    ["(ì´ˆë¡ì§‘)"] = {-532, -7, 92},
    ["(ë¶„í™ì§‘)"] = {-484, -7, -165},
    ["(ë³´ë¼ì§‘)"] = {249, -7, 461},
    ["(íŒŒëž‘ì§‘)"] = {513, 83, -341},
    ["(ë¹¨ê°•ì§‘)"] = {551, 123, -73},
}

Misc:CreateDropdown({
    Name = "Select Zone",
    Options = {"ìŠ¤í°","ìŠ¤í°ì‚°","ê´‘ì‚°","í°ë™êµ´","ìž‘ì€ë™êµ´","ì—´ì°¨ë™êµ´","ìœ„í—˜êµ¬ì—­","ì„¤ì‚°","í—›ê°„(ë†ì§€)","í•˜ëŠ˜ì„¬","ì´ˆë¡ì§‘","(ì´ˆë¡ì§‘)","(ë¶„í™ì§‘)","(ë³´ë¼ì§‘)","(íŒŒëž‘ì§‘)","(ë¹¨ê°•ì§‘)"},
    MultipleOptions = false,
    Callback = function(Value)
        if typeof(Value) == "table" then
            selectedLocation = Value[1] or "ìŠ¤í°"
        else
            selectedLocation = Value
        end
    end
})

Misc:CreateButton({
    Name = "â”— Teleport",
    Callback = function()
         plr = game.Players.LocalPlayer
         char = plr.Character or plr.CharacterAdded:Wait()
         hrp = char:WaitForChild("Torso")

         pos = teleportLocations[selectedLocation]
        if not pos then
            return
        end

        hrp.CFrame = CFrame.new(pos[1], pos[2], pos[3])
    end,
})

Misc:CreateSection("Lag")

Misc:CreateToggle({
    Name = "Line Lag",
    CurrentValue = false,
    Callback = function(Value)
        LineLagT = Value
        LineLagF()
    end
})

Misc:CreateInput({
    Name = "â”— Lines",
    CurrentValue = 30,
    PlaceholderText = "Lines",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        LineLagV = Value
    end
})

local SoftLockT = Misc:CreateToggle({
    Name = "Soft Lock",
    CurrentValue = false,
    Callback = function(Value)
        SoftLockV = Value
        if SoftLockV then
            task.spawn(function()
                local char = plr.Character
                local heartbeat = game:GetService("RunService").Heartbeat
                if char then
                    local hum = char:FindFirstChild("Humanoid")
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    local seat = workspace.Map.AlwaysHereTweenedObjects.Train.Object.ObjectModel.Seat

                    if hum and seat then
                        seat:Sit(hum)
                    end

                    sitJumpT = true

                    if hum then
                        task.spawn(ragdollLoopF)
                    end
                end

                task.wait(4)

                while SoftLockV do
                    char = plr.Character
                    if char then
                        hum = char:FindFirstChild("Humanoid")
                        hrp = char:FindFirstChild("HumanoidRootPart")

                        local shouldStop = false

                        if not SoftLockV then
                            shouldStop = true
                        end

                        if plr:FindFirstChild("IsHeld") and plr.IsHeld.Value then
                            shouldStop = true
                        end

                        if hum and hum:FindFirstChild("Ragdolled") and hum.Ragdolled.Value then
                            shouldStop = true
                        end

                        if not hum or hum.Health <= 0 then
                            shouldStop = true
                        end

                        if shouldStop then
                            SoftLockT:Set(false)
                            break
                        end

                        if hrp then
                            rs.CharacterEvents.RagdollRemote:FireServer(hrp, 0)
                        end
                    end
                    heartbeat:Wait()
                end
            end)
        else
        sitJumpT = false
            char = plr.Character
            if char then
                hum = char:FindFirstChild("Humanoid")
                if hum then
                    hum.Sit = true
                    task.wait(0.2)
                    hum.Sit = false
                end
            end
        end
    end
})

Misc:CreateSection("Penis")

input = Misc:CreateInput({
   Name = "ToolPencil",
   CurrentValue = "",
   PlaceholderText = "Value",
   RemoveTextAfterFocusLost = false,
   Callback = function(Text)
   end
})

Misc:CreateButton({
   Name = "â”— Create",
   Callback = function()
        pencilCountText = input.CurrentValue
        TNUM = tonumber(pencilCountText)

       if not TNUM or TNUM <= 0 then
           warn("Please enter a valid number!")
           Rayfield:Notify({Title = "[ âœï¸ ]", Content = "Nil Value", Duration = 3, Image = 0})
           return
       end

local sno = rs:FindFirstChild("GrabEvents"):FindFirstChild("SetNetworkOwner")
local spe = rs:FindFirstChild("PlayerEvents"):FindFirstChild("StickyPartEvent")
local character = plr.Character
local hrp = character:FindFirstChild("HumanoidRootPart")

function GetPlotNumber()
    local char = plr.Character
    if not char or char.Parent == workspace then
        return nil
    end

    if char.Parent.Name == "PlayersInPlots" then
        for _, plot in ipairs(workspace.Plots:GetChildren()) do
            for _, owner in ipairs(plot.PlotSign.ThisPlotsOwners:GetChildren()) do
                if owner.Value == plr.Name then
                    return tonumber(plot.Name:match("%d+"))
                end
            end
        end
    end

    return nil
end

function GetInventory()
    local plotNumber = GetPlotNumber()

    if plotNumber then
        local plotItems = workspace:FindFirstChild("PlotItems")
        if plotItems then
            local plotFolder = plotItems:FindFirstChild("Plot" .. plotNumber)
            if plotFolder then
                return plotFolder
            end
        end
    end

    return workspace:WaitForChild(plr.Name .. "SpawnedInToys")
end

function createPencil(index)
    while not plr.CanSpawnToy.Value do
        task.wait()
    end

    task.spawn(function()
        SpawnToy:InvokeServer(
            "ToolPencil",
            hrp.CFrame * CFrame.new(0, 5, 15),
            Vector3.new(0, 0, 0)
        )
    end)

    task.wait(0.3)

    local inv = GetInventory()
    local pencil

    for i = #inv:GetChildren(), 1, -1 do
        local obj = inv:GetChildren()[i]
        if obj.Name == "ToolPencil" then
            pencil = obj
            break
        end
    end

    if not pencil then
        warn("Pencil not found in inventory")
        return nil
    end

    local stickyPart = pencil:WaitForChild("StickyPart")
    local soundPart = pencil:WaitForChild("SoundPart")

    sno:FireServer(soundPart, soundPart.CFrame)
    sno:FireServer(soundPart, character.Torso.CFrame)

    if soundPart:FindFirstChild("PartOwner") then
        soundPart.CFrame = CFrame.new(0, 599999, 999)
    end

    stickyPart.Name = "w" .. index

    for _, part in ipairs(pencil:GetDescendants()) do
        if part:IsA("BasePart") and part.Color == Color3.fromRGB(158, 108, 141) then
            part.Name = "a" .. index
        end
    end

    return pencil
end

local pencils = {}

for i = 1, TNUM do
    local pencil = createPencil(i)
    if pencil then
        table.insert(pencils, pencil)
    end
    task.wait(0.1)
end

for i = 1, #pencils - 1 do
    local current = pencils[i]
    local nextOne = pencils[i + 1]

    if current and nextOne then
        local attachFrom = current:FindFirstChild("w" .. i)
        local attachTo = nextOne:FindFirstChild("a" .. (i + 1))

        if attachFrom and attachTo then
            spe:FireServer(
                attachFrom,
                attachTo,
                CFrame.Angles(0, math.rad(-90), 0)
            )
        end
    end

    task.wait()
end

local torsoHitbox = hrp:WaitForChild("RagdollTouchedHitbox")

if torsoHitbox and #pencils >= TNUM then
    local lastPencil = pencils[TNUM]
    local wLast = lastPencil and lastPencil:FindFirstChild("w" .. TNUM)

    if wLast then
        local attachPosition =
            torsoHitbox.CFrame *
            CFrame.new(0, -1.1, 0.1) *
            CFrame.Angles(0, math.rad(180), 0)

        local relativeCF = torsoHitbox.CFrame:ToObjectSpace(attachPosition)

        spe:FireServer(wLast, torsoHitbox, relativeCF)
    end
end
   end
})

Misc:CreateSection("StickyEvent")

Inputt = Misc:CreateInput({
   Name = "NinjaKunai",
   CurrentValue = "",
   PlaceholderText = "Value",
   RemoveTextAfterFocusLost = false,
   Callback = function(Text)
   end
})

Misc:CreateButton({
   Name = "â”— Create { Grab The Part }",
   Callback = function()
        kunaiCountText = Inputt.CurrentValue
        TNUM = tonumber(kunaiCountText)

       if not TNUM or TNUM <= 0 or TNUM > 100 then
           Rayfield:Notify({Title = "[ ðŸ¥· ]", Content = "Invalid Value", Duration = 3, Image = 0})
           return
       end

        character = plr.Character or plr.CharacterAdded:Wait()
        hrp = character:WaitForChild("HumanoidRootPart")
        torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
       
       if not torso then
           return
       end

       function GetTargetPartFromGrabParts()
            grabPartsModel = workspace:FindFirstChild("GrabParts")
           if not grabPartsModel then return nil end

            grabPart = grabPartsModel:FindFirstChild("GrabPart")
           if not grabPart then return nil end

            weldConstraint = grabPart:FindFirstChild("WeldConstraint")
           if not weldConstraint or not weldConstraint:IsA("WeldConstraint") then return nil end

           if not weldConstraint.Part1 then return nil end

           return weldConstraint.Part1
       end

       function GetPlotNumber()
            char = plr.Character
           if not char then return nil end

           if char.Parent == workspace then 
               return nil
           elseif char.Parent.Name == "PlayersInPlots" then
               for _, plot in workspace.Plots:GetChildren() do
                    plotSign = plot:FindFirstChild("PlotSign")
                   if plotSign and plotSign:FindFirstChild("ThisPlotsOwners") then
                       for _, owner in plotSign.ThisPlotsOwners:GetChildren() do
                           if owner.Value == plr.Name then
                               if plot.Name == "Plot1" then
                                   return 1
                               elseif plot.Name == "Plot2" then
                                   return 2
                               elseif plot.Name == "Plot3" then
                                   return 3
                               elseif plot.Name == "Plot4" then
                                   return 4
                               elseif plot.Name == "Plot5" then
                                   return 5
                               end
                           end
                       end
                   end
               end
           end
           return nil
       end

       function GetInventory()
            plotNumber = GetPlotNumber()

           if plotNumber then
                plotItems = workspace:FindFirstChild("PlotItems")
               if plotItems then
                    plotFolder = plotItems:FindFirstChild("Plot" .. plotNumber)
                   if plotFolder then
                       return plotFolder
                   end
               end
           end
           
            defaultInv = workspace:FindFirstChild(plr.Name .. "SpawnedInToys")
           if defaultInv then
               return defaultInv
           end
           
           return nil
       end

        targetPart = GetTargetPartFromGrabParts()
       if not targetPart then
           return
       end

       function createAndAttachKunai()
           while not plr.CanSpawnToy.Value do 
               task.wait(0.1) 
           end

            position = hrp.CFrame

           local success, result = pcall(function()
 task.spawn(function()
               return SpawnToy:InvokeServer("NinjaKunai", hrp.CFrame * CFrame.new(0,5,15), Vector3.new(0, 0, 0))
           end)
           end)
           
           if not success then
               return nil
           end

           task.wait(0.2)

            inv = GetInventory()
           if not inv then
               return nil
           end

           local kunai
            children = inv:GetChildren()
           for i = #children, 1, -1 do
               if children[i].Name == "NinjaKunai" then
                   kunai = children[i]
                   break
               end
           end

           if not kunai then 
               return nil 
           end

            stickyPart = kunai:WaitForChild("StickyPart")
            SoundPart = kunai:WaitForChild("SoundPart")

           if stickyPart and SoundPart then
               pcall(function()
                   SetOwner:FireServer(SoundPart, CFrame.lookAt(torso.Position, SoundPart.Position))
               end)
           end

           if stickyPart then
                attachPosition = targetPart.CFrame
                relativeCF = targetPart.CFrame:ToObjectSpace(attachPosition)

               pcall(function()
                   StickyPartEvent:FireServer(stickyPart, targetPart, relativeCF)
               end)
           end

           task.wait(0.1)
           return kunai
       end

       for i = 1, TNUM do
           createAndAttachKunai()
           task.wait(0.1)
       end
   end
})

-- ====================================== [ ì„¤ì • íƒ­ ]
local Setting = Window:CreateTab("ì„¤ì •", 0)

Setting:CreateSection("Shader")

Setting:CreateButton({
    Name = "Default",
    Callback = DefalutSky
})

Setting:CreateButton({
    Name = "Day Time",
    Callback = function()
    DefalutSky()
        local Lighting = game:GetService("Lighting")

        Lighting.Ambient = Color3.fromRGB(0, 0, 0)
        Lighting.Brightness = 3.13
        Lighting.ColorShift_Bottom = Color3.fromRGB(0, 0, 0)
        Lighting.ColorShift_Top = Color3.fromRGB(188, 141, 1)
        Lighting.EnvironmentDiffuseScale = 0.583
        Lighting.EnvironmentSpecularScale = 1
        Lighting.GlobalShadows = true
        Lighting.OutdoorAmbient = Color3.fromRGB(145, 128, 95)
        Lighting.ShadowSoftness = 0.04
        Lighting.Technology = Enum.Technology.Future
        Lighting.ClockTime = 14.5
        Lighting.GeographicLatitude = 143
        Lighting.FogColor = Color3.fromRGB(146, 208, 255)
        Lighting.FogEnd = 3000
        Lighting.FogStart = 300

        local sky = Lighting:FindFirstChildOfClass("Sky") or Instance.new("Sky", Lighting)
        sky.CelestialBodiesShown = true
        sky.MoonAngularSize = 11
        sky.MoonTextureId = "rbxassetid://6444320592"
        sky.SkyboxBk = "rbxassetid://6444884337"
        sky.SkyboxDn = "rbxassetid://6444884785"
        sky.SkyboxFt = "rbxassetid://6444884337"
        sky.SkyboxLf = "rbxassetid://6444884337"
        sky.SkyboxRt = "rbxassetid://6444884337"
        sky.SkyboxUp = "rbxassetid://6412503613"
        sky.StarCount = 0
        sky.SunAngularSize = 11
        sky.SunTextureId = "rbxassetid://1084351190"

        local bloom = Lighting:FindFirstChildOfClass("BloomEffect") or Instance.new("BloomEffect", Lighting)
        bloom.Intensity = 1
        bloom.Size = 90
        bloom.Threshold = 2

        local cc = Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect", Lighting)
        cc.Brightness = 0.04
        cc.Contrast = 0.19
        cc.Saturation = 0.12
        cc.TintColor = Color3.fromRGB(255, 255, 255)
    end
})

Setting:CreateButton({
    Name = "Shore",
    Callback = function()
    DefalutSky()
        Lighting = game:GetService("Lighting")

        Lighting.Ambient = Color3.fromRGB(109, 117, 135)
        Lighting.Brightness = 1.921
        Lighting.ColorShift_Bottom = Color3.fromRGB(248, 165, 159)
        Lighting.ColorShift_Top = Color3.fromRGB(226, 75, 0)
        Lighting.EnvironmentDiffuseScale = 0.172
        Lighting.EnvironmentSpecularScale = 0.738
        Lighting.GlobalShadows = true
        Lighting.OutdoorAmbient = Color3.fromRGB(36, 47, 58)
        Lighting.ShadowSoftness = 0.25
        Lighting.Technology = Enum.Technology.Future
        Lighting.TimeOfDay = "-06:23:59"
        Lighting.GeographicLatitude = 0
        Lighting.FogColor = Color3.fromRGB(192, 192, 192)
        Lighting.FogEnd = 100000
        Lighting.FogStart = 0

        local atmosphere = Lighting:FindFirstChildOfClass("Atmosphere") or Instance.new("Atmosphere", Lighting)
        atmosphere.Density = 0.359
        atmosphere.Offset = 0
        atmosphere.Color = Color3.fromRGB(255, 216, 194)
        atmosphere.Decay = Color3.fromRGB(123, 151, 182)
        atmosphere.Glare = 2.97
        atmosphere.Haze = 1.52

        local sky = Lighting:FindFirstChildOfClass("Sky") or Instance.new("Sky", Lighting)
        sky.CelestialBodiesShown = true
        sky.MoonAngularSize = 0
        sky.MoonTextureId = "rbxasset://sky/moon.jpg"
        sky.SkyboxBk = "rbxassetid://88585370973398"
        sky.SkyboxDn = "rbxassetid://128014535205529"
        sky.SkyboxFt = "rbxassetid://85323615042244"
        sky.SkyboxLf = "rbxassetid://77415797450913"
        sky.SkyboxRt = "rbxassetid://127566931602371"
        sky.SkyboxUp = "rbxassetid://102320981098060"
        sky.StarCount = 5000
        sky.SunAngularSize = 4
        sky.SunTextureId = "rbxasset://sky/sun.jpg"

        local bloom = Lighting:FindFirstChildOfClass("BloomEffect") or Instance.new("BloomEffect", Lighting)
        bloom.Intensity = 1
        bloom.Size = 50
        bloom.Threshold = 2.291

        local blur = Lighting:FindFirstChildOfClass("BlurEffect") or Instance.new("BlurEffect", Lighting)
        blur.Enabled = false
        blur.Size = 4

        local cc = Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect", Lighting)
        cc.Brightness = 0
        cc.Contrast = 0.2
        cc.Saturation = 0
        cc.TintColor = Color3.fromRGB(255, 255, 255)

        local sunrays = Lighting:FindFirstChildOfClass("SunRaysEffect") or Instance.new("SunRaysEffect", Lighting)
        sunrays.Intensity = 0.024
        sunrays.Spread = 0.463
    end
})

Setting:CreateButton({
    Name = "Cloudy",
    Callback = function()
    DefalutSky()
        local Lighting = game:GetService("Lighting")

        Lighting.Ambient = Color3.fromRGB(0, 0, 0)
        Lighting.Brightness = 5.63
        Lighting.ColorShift_Bottom = Color3.fromRGB(0, 0, 0)
        Lighting.ColorShift_Top = Color3.fromRGB(207, 114, 0)
        Lighting.EnvironmentDiffuseScale = 0.583
        Lighting.EnvironmentSpecularScale = 1
        Lighting.GlobalShadows = true
        Lighting.OutdoorAmbient = Color3.fromRGB(89, 68, 47)
        Lighting.ShadowSoftness = 0.04
        Lighting.Technology = Enum.Technology.Future
        Lighting.ClockTime = 17.629
        Lighting.GeographicLatitude = 21.589
        Lighting.FogColor = Color3.fromRGB(146, 208, 255)
        Lighting.FogEnd = 3000
        Lighting.FogStart = 300

        local atmosphere = Lighting:FindFirstChildOfClass("Atmosphere") or Instance.new("Atmosphere", Lighting)
        atmosphere.Density = 0.357
        atmosphere.Offset = 0
        atmosphere.Color = Color3.fromRGB(165, 165, 165)
        atmosphere.Decay = Color3.fromRGB(16, 16, 16)
        atmosphere.Glare = 0.21
        atmosphere.Haze = 1.46

        local sky = Lighting:FindFirstChildOfClass("Sky") or Instance.new("Sky", Lighting)
        sky.CelestialBodiesShown = true
        sky.MoonAngularSize = 1.5
        sky.MoonTextureId = "rbxassetid://1075087760"
        sky.SkyboxBk = "rbxassetid://2177969403"
        sky.SkyboxDn = "rbxassetid://2177972406"
        sky.SkyboxFt = "rbxassetid://2177970251"
        sky.SkyboxLf = "rbxassetid://2177969836"
        sky.SkyboxRt = "rbxassetid://2177968823"
        sky.SkyboxUp = "rbxassetid://2177971305"
        sky.StarCount = 500
        sky.SunAngularSize = 3
        sky.SunTextureId = "rbxasset://sky/sun.jpg"

        local bloom = Lighting:FindFirstChildOfClass("BloomEffect") or Instance.new("BloomEffect", Lighting)
        bloom.Intensity = 1
        bloom.Size = 90
        bloom.Threshold = 2

        local cc = Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect", Lighting)
        cc.Brightness = 0.04
        cc.Contrast = 0.15
        cc.Saturation = 0.2
        cc.TintColor = Color3.fromRGB(255, 255, 255)

        local sunrays = Lighting:FindFirstChildOfClass("SunRaysEffect") or Instance.new("SunRaysEffect", Lighting)
        sunrays.Intensity = 0.004
        sunrays.Spread = 0.167
    end
})

Setting:CreateSection("Line")

AntiLagV = 30
Setting:CreateInput({
    Name = "Line Detect",
    CurrentValue = 30,
    PlaceholderText = "",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        AntiLagV = Value
    end
})

function jerk()
     v2 = game:GetService('Players').LocalPlayer
     v3 = (v2.Character or v2.CharacterAdded:Wait()):FindFirstChildOfClass('Humanoid')

    if not vu5 then
        local v4 = Instance.new('Animation')
        v4.AnimationId = 'rbxassetid://168268306'
        vu5 = (v3:FindFirstChildOfClass('Animator') or v3:WaitForChild('Animator')):LoadAnimation(v4)
    end
    
    vu6 = not vu6

    if vu6 then
        vu5:Play()
        task.wait(0.3)

        while vu6 do
            vu5.TimePosition = 0.3
            task.wait(0.1)
        end
    else
        vu5:Stop()
    end
end

Setting:CreateSection("Animation")
local Jerk = Setting:CreateKeybind({
    Name = "Jerk",
    CurrentKeybind = "Three",
    HoldToInteract = false,
    Callback = jerk
})

game:GetService('Players').LocalPlayer.CharacterAdded:Connect(function()
    vu5 = nil
    vu6 = false
end)

Setting:CreateSection("Mouse")

Setting:CreateKeybind({
    Name = "Teleport",
    CurrentKeybind = "Z",
    HoldToInteract = false,
    Callback = tpF
})

Thirdp = Setting:CreateToggle({
    Name = "3rd person",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            plr.CameraMode = Enum.CameraMode.Classic
            plr.CameraMaxZoomDistance = 100000
        else
            plr.CameraMode = Enum.CameraMode.LockFirstPerson
            plr.CameraMaxZoomDistance = 0.5
        end
    end
})
if _G.Thirdp then Thirdp:Set(true) end

Setting:CreateSection("Sit")
Setting:CreateToggle({
    Name = "Sit",
    CurrentValue = false,
    Callback = function(Value)
        AutoSitT = Value
        AutoSitF()
    end
})

Setting:CreateKeybind({
    Name = "Sit",
    CurrentKeybind = "X",
    HoldToInteract = false,
    Callback = function()
        BlobSit()
    end
})

Setting:CreateDropdown({
    Name = "â”— Select",
    Options = {"ë¸”ë¡­", "íŠ¸ëž™í„°ðŸŸ¥", "íŠ¸ëž™í„°ðŸŸ§", "íŠ¸ëž™í„°ðŸŸ©", "ì‚°íƒ€ì°ë§¤"},
    MultipleOptions = false,
    Callback = function(Value)
        SitV = Value
    end
})

Setting:CreateSection("Plot")

BarrierNoclip = Setting:CreateToggle({
    Name = "Barrier Noclip",
    CurrentValue = false,
    Callback = function(Value)
        BarrierCanCollideT = Value
        BarrierCanCollideF()
    end
})
if _G.BarrierNoclip then BarrierNoclip:Set(true) end

Setting:CreateKeybind({
    Name = "Brake Barrier { FoodBread }",
    CurrentKeybind = "Y",
    HoldToInteract = false,
    Callback = function()
        PlotBarrierDelete()
    end
})

Setting:CreateKeybind({
    Name = "House Grab",
    CurrentKeybind = "G",
    HoldToInteract = false,
    Callback = function()
        if isExecuting then
            return
        end

        isExecuting = true

        local char = plr.Character or plr.CharacterAdded:Wait()
        local torso = char:WaitForChild("Torso")

        local inPlot = plr:FindFirstChild("InPlot")
        if not inPlot or inPlot.Value == false then
            isExecuting = false
            return
        end

        House()
        plotItemsFolder = workspace.PlotItems:FindFirstChild("Plot"..Plot)
        TP = workspace.Plots["Plot"..Plot].PlotArea

        if not TP then
            isExecuting = false
            return
        end

        GrabParts = workspace:FindFirstChild("GrabParts")
        if GrabParts then
        mouse1click()
        end

        torso = char:WaitForChild("Torso")
        OCF = torso.CFrame
        torso.CFrame = TP.CFrame
        task.wait(0.15)
        torso.CFrame = OCF
        task.wait(0.15)
        mouse1click()
        isExecuting = false
    end
})

Setting:CreateSection("Owner")

Setting:CreateKeybind({
    Name = "Anchored",
    CurrentKeybind = "H",
    HoldToInteract = false,
    Callback = function()
			 original = workspace:FindFirstChild("GrabParts")
			if not original then return end

			 grabPart = original:FindFirstChild("GrabPart", true)
			if not grabPart or not grabPart:IsA("BasePart") then return end

			 wasCollide = grabPart.CanCollide
			grabPart.CanCollide = true
			task.wait(0.1)

			 targetModel = nil
			 touchingParts = grabPart:GetTouchingParts()

			if #touchingParts == 0 then
				grabPart.CanCollide = wasCollide
				return
			end

			for _, part in ipairs(touchingParts) do
				if not part:IsDescendantOf(original) then
					 current = part
					while current and current ~= workspace do
						if current:IsA("Model") then
							targetModel = current
							break
						end
						current = current.Parent
					end
					if targetModel then break end
				end
			end

			grabPart.CanCollide = wasCollide

			if not targetModel then return end

			if not targetModel.Parent then
				 found = false
				local connection
				connection = targetModel.AncestryChanged:Connect(function(_, parent)
					if parent then
						found = true
						connection:Disconnect()
					end
				end)

				 startTime = tick()
				while not found and tick() - startTime < 2 do
					task.wait(0.1)
				end

				if not found then return end
			end

			 existing = targetModel:FindFirstChild("Force")
			if existing then
				 existingHighlight = targetModel:FindFirstChild("AnchorHighlight")
				if existingHighlight then
					existingHighlight:Destroy()
				end
				existing:Destroy()
				return
			end

			 clone = original:Clone()
			clone.Name = "Force"

			for _, desc in ipairs(clone:GetDescendants()) do
				if desc:IsA("BasePart") then
					desc.Transparency = 1
					desc.CanCollide = false

					 beam = desc:FindFirstChild("GrabBeam")
					if beam then beam:Destroy() end

					for _, sName in ipairs({"AttachSound1", "AttachSound", "BeamSound", "BeamSound1"}) do
						 sound = desc:FindFirstChild(sName)
						if sound then sound:Destroy() end
					end
				end
			end

			clone.Parent = targetModel

			 hl = Instance.new("Highlight")
			hl.Name = "AnchorHighlight"
			hl.FillColor = Color3.fromRGB(0, 0, 255)
			hl.FillTransparency = 0.9
			hl.OutlineColor = Color3.fromRGB(0, 0, 255)
			hl.OutlineTransparency = 0.5
			hl.Adornee = targetModel
			hl.Parent = targetModel

			local connection
			connection = game:GetService("RunService").Heartbeat:Connect(function()
				if not clone or not clone.Parent or not targetModel or not targetModel.Parent then
					if connection then connection:Disconnect() end
					return
				end

				if hl and hl.Parent then
					hl.Adornee = targetModel
				else
					connection:Disconnect()
				end
			end)
    end
})

Setting:CreateSection("ESP")

PcldViewT = false
processed = {}
redBoxes = {}
descendantConn = nil

function PcldViewF()
    if descendantConn then
        descendantConn:Disconnect()
        descendantConn = nil
        workspace:SetAttribute("PcldViewDescendantConn", false)
    end

    if PcldViewT then
        for _, obj in ipairs(workspace:GetChildren()) do
            if (obj.Name == "PlayerCharacterLocationDetector" or obj.Name == "me") and obj:IsA("BasePart") then
                if not processed[obj] then
                    local box = Instance.new("SelectionBox")
                    box.Adornee = obj
                    box.LineThickness = 0.005
                    box.SurfaceTransparency = 1
                    box.SurfaceColor3 = Color3.fromRGB(255, 255, 255)
                    box.Color3 = Color3.fromRGB(255, 255, 255)
                    box.Parent = obj
                    processed[obj] = true
                    redBoxes[obj] = box
                end
            end
        end

        descendantConn = workspace.DescendantAdded:Connect(function(obj)
            if PcldViewT and (obj.Name == "PlayerCharacterLocationDetector" or obj.Name == "me") and obj:IsA("BasePart") then
                if not processed[obj] then
                    local box = Instance.new("SelectionBox")
                    box.Adornee = obj
                    box.LineThickness = 0.005
                    box.SurfaceTransparency = 1
                    box.SurfaceColor3 = Color3.fromRGB(255, 255, 255)
                    box.Color3 = Color3.fromRGB(255, 255, 255)
                    box.Parent = obj
                    processed[obj] = true
                    redBoxes[obj] = box
                end
            end
        end)

        workspace.DescendantRemoving:Connect(function(obj)
            if redBoxes[obj] then
                redBoxes[obj]:Destroy()
                redBoxes[obj] = nil
                processed[obj] = nil
            end
        end)

    else
        for obj, box in pairs(redBoxes) do
            if box then box:Destroy() end
        end
        redBoxes = {}
        processed = {}
    end
end

Setting:CreateToggle({
    Name = "Icon esp",
    CurrentValue = false,
    Callback = function(Value)
        PlrEspT = Value
        PlrEspF()
    end
})

PCLDVIEW = Setting:CreateToggle({
    Name = "PCLD ESP",
    CurrentValue = false,
    Callback = function(Value)
        PcldViewT = Value
        PcldViewF()
    end
})
if _G.PCLDESP then PCLDVIEW:Set(true) end

STICKYVIEW = Setting:CreateToggle({
    Name = "StickyPart ESP",
    CurrentValue = false,
    Callback = function(Value)
        ViewToolT = Value
        ViewToolF()
    end
})
if _G.PCLDESP then STICKYVIEW:Set(true) end

-- ====================================== [ í¬ëž˜ë”§ íƒ­ ]
local Credit = Window:CreateTab("í¬ëž˜ë”§", 0)

Credit:CreateLabel("Defiant", 96897864871400, Color3.fromRGB(255, 255, 255), false)
Credit:CreateParagraph({Title = "dsc - savior.liberty", Content = "Defiant"})

Credit:CreateLabel("Nether ( Dungi )", 0, Color3.fromRGB(255, 255, 255), false)
Credit:CreateParagraph({Title = "dsc - netherlandson_top0", Content = "Nether"})

Credit:CreateLabel("NoPe", 0, Color3.fromRGB(255, 255, 255), false)
Credit:CreateParagraph({Title = "dsc - fn.nope", Content = "FN(This Script) Owner"})

Credit:CreateLabel("Diro", 0, Color3.fromRGB(255, 255, 255), false)
Credit:CreateParagraph({Title = "dsc - wvvwwvwwvw", Content = "Best Friend"})

-- ====================================== [ ì‹¤í—˜ íƒ­ ]
local Dev = Window:CreateTab("ì‹¤í—˜", 0)

Dev:CreateSection("Gamepass")

Dev:CreateButton({
    Name = "Farther Reach",
    Callback = function()

     LimitedTime = rs.MenuToys.LimitedTimeToyEvent

    GrabScript = plr.Character:FindFirstChild("GrabbingScript")
    grbaparts = workspace:FindFirstChild("GrabParts")
    campart = plr.Character:FindFirstChild("CamPart")

    hookinstance(Reach, LimitedTime)
    GrabScript.Enabled = false
    if grbaparts then grbaparts:Destroy() end
    if campart then campart:Destroy() end
    GrabScript.Enabled = true
    LimitedTime:FireServer()

    end
})

Dev:CreateButton({
    Name = "Multi Color Line",
    Callback = function()

    ColorPicking = plr.PlayerGui.MenuGui.Menu.TabContents.Settings.Contents.LineFrame.ColorPicking

    hookinstance(Color, LimitedTime)
    ColorPicking.Enabled = false
    ColorPicking.Enabled = true
    task.wait(0.1)
    LimitedTime:FireServer()

    end
})

Dev:CreateSection("Game")

ifKickThenT = true
Dev:CreateToggle({
    Name = "Kick Notification",
    CurrentValue = true,
    Callback = function(Value)
        ifKickThenT = Value
        ifKickThenF()
    end
})
ifKickThenF()

headMatrix = {0,0,0,0,0,0,0,1,0}
torsoMatrix = {0,0,0,0,0,0,0,1,0}
rightArmMatrix = {0,0,2,0,0,0,0,0,1}

Dev:CreateSection("")

Dev:CreateToggle({ 
    Name = "Look", 
    CurrentValue = false,
    Callback = function(Value)
        isSpamming = Value

        if isSpamming then
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
            end

            heartbeatConnection = rs2.Heartbeat:Connect(function()
                rs.CharacterEvents.Look:FireServer(
                    CFrame.new(0, 0, 0, headMatrix[1], headMatrix[2], headMatrix[3], headMatrix[4], headMatrix[5], headMatrix[6], headMatrix[7], headMatrix[8], headMatrix[9]),
                    CFrame.new(0, 0, 0, torsoMatrix[1], torsoMatrix[2], torsoMatrix[3], torsoMatrix[4], torsoMatrix[5], torsoMatrix[6], torsoMatrix[7], torsoMatrix[8], torsoMatrix[9]),
                    CFrame.new(0, 0, 0, rightArmMatrix[1], rightArmMatrix[2], rightArmMatrix[3], rightArmMatrix[4], rightArmMatrix[5], rightArmMatrix[6], rightArmMatrix[7], rightArmMatrix[8], rightArmMatrix[9]),
                    "high"
                )
            end)
        else
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
                heartbeatConnection = nil
            end
        end
    end
})

HR = Dev:CreateInput({
    Name = "â”£ Head Rotation",
    CurrentValue = "0,0,0,0,0,0,0,1,0",
    PlaceholderText = "xx, xy, xz, yx, yy, yz, zx, zy, zz",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        numbers = {}
        for num in Value:gmatch("[^,]+") do
            table.insert(numbers, tonumber(num) or 0)
        end

        for i = 1, 9 do
            headMatrix[i] = numbers[i] or 0
        end
    end
})

TR = Dev:CreateInput({
    Name = "â”£ Torso Rotation",
    CurrentValue = "0,0,0,0,0,0,0,1,0",
    PlaceholderText = "xx, xy, xz, yx, yy, yz, zx, zy, zz",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        local numbers = {}
        for num in Value:gmatch("[^,]+") do
            table.insert(numbers, tonumber(num) or 0)
        end

        for i = 1, 9 do
            torsoMatrix[i] = numbers[i] or 0
        end
    end
})

ARA = Dev:CreateInput({
    Name = "â”£ Right Arm Rotation",
    CurrentValue = "0,0,2,0,0,0,0,0,1",
    PlaceholderText = "xx, xy, xz, yx, yy, yz, zx, zy, zz",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        local numbers = {}
        for num in Value:gmatch("[^,]+") do
            table.insert(numbers, tonumber(num) or 0)
        end

        for i = 1, 9 do
            rightArmMatrix[i] = numbers[i] or 0
        end
    end
})

Dev:CreateButton({
    Name = "â”— Reset",
    Callback = function()

headMatrix = {0,0,0,0,0,0,0,1,0}
torsoMatrix = {0,0,0,0,0,0,0,1,0}
rightArmMatrix = {0,0,2,0,0,0,0,0,1}

HR:Set("0,0,0,0,0,0,0,1,0")
TR:Set("0,0,0,0,0,0,0,1,0")
ARA:Set("0,0,2,0,0,0,0,0,1")

    end
})

Dev:CreateSection("Chat")

Dev:CreateToggle({
    Name = "Chat begin",
    CurrentValue = false,
    Callback = function(Value)
        LoopChat = Value
        while Value do
        task.wait(0.1)
        rs.CharacterEvents.ChatTyping:FireServer("begin")
        end
    end
})

Dev:CreateToggle({
    Name = "Chat end",
    CurrentValue = false,
    Callback = function(Value)
        LoopChatF = Value
        while Value do
        task.wait(0.1)
        rs.CharacterEvents.ChatTyping:FireServer("end")
        end
    end
})

Dev:CreateToggle({
    Name = "Toggle",
    CurrentValue = false,
    Callback = function(Value)
        spamming = Value

        if spamConnection then
            spamConnection:Disconnect()
            spamConnection = nil
        end

        if Value then
            local accumulator = 0

            spamConnection = RunService.Heartbeat:Connect(function(deltaTime)
                if not spamming then 
                    return 
                end

                accumulator = accumulator + deltaTime
                if accumulator >= SpeedSpam then
                    accumulator = 0

                    local success, errorMsg = pcall(function()
                        message = "/e " .. (spamText)
                        chat.TextChannels.RBXGeneral:SendAsync(message)
                    end)
                end
            end)
        end
    end
})

Dev:CreateInput({
    Name = "â”£ Speed",
    CurrentValue = "",
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        num = tonumber(Value)
        if num and num > 0 then
            SpeedSpam = num
        else
            SpeedSpam = 0.1
        end
    end
})

Dev:CreateInput({
    Name = "â”— Sound",
    CurrentValue = "",
    PlaceholderText = "Value",
    RemoveTextAfterFocusLost = false,
    Callback = function(Value)
        spamText = tostring(Value)
    end
})

Dev:CreateSection("Tweened Objects")

Dev:CreateButton({
    Name = "Train Control",
    Callback = TrSw
})

Dev:CreateSection("OWNER")

Dev:CreateToggle({
    Name = "PTM",
    CurrentValue = false,
    Callback = function(Value)
        loopPlayerT3 = Value
        if loopPlayerT3 then
            table.clear(playersInLoop2V)
            for i, e in ipairs(playersInLoop1V) do
                local nameOnly = e:match("^(.-) %(") or e
                table.insert(playersInLoop2V, nameOnly)
            end
            loopPlayerF3()
        else
            loopPlayerT3 = false
            table.clear(playersInLoop2V)
        end
    end
})

Dev:CreateButton({
    Name = "Kill { Owner }",
    Callback = function()
        table.clear(playersInLoop2V)
        for i, e in ipairs(playersInLoop1V) do
             nameOnly = e:match("^(.-) %(") or e
            table.insert(playersInLoop2V, nameOnly)
        end
        
        UpdateCurrentBlobman()
        
        for _, name in ipairs(playersInLoop2V) do
             player = game.Players:FindFirstChild(name)
            if player and not table.find(Whitelist, player.Name) then
                 character, hrp, head = safeGetCharacterParts(player)
                 humanoid = character and character:FindFirstChildOfClass("Humanoid")
                if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end
                
                if humanoid and humanoid.Health > 0 then
                     myChar = plr.Character
                     myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
                    if not myHrp then continue end
                    local originCF = myHrp.CFrame
                    
                    TP(player)
                    task.wait(0.1)
                    
                    while true do
                        rs.GrabEvents.SetNetworkOwner:FireServer(head, head.CFrame)
                         ownerTag = head:FindFirstChild("PartOwner")
                        if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                            break
                        end
                        task.wait()
                    end

                    if humanoid.BreakJointsOnDeath == true and humanoid.SeatPart == nil then humanoid.BreakJointsOnDeath = false end
                    if humanoid and humanoid.SeatPart == nil then humanoid:ChangeState(Enum.HumanoidStateType.Dead) end

                    if head:FindFirstChildOfClass("BallSocketConstraint") then head.BallSocketConstraint.Attachment0 = nil end

                     FallenY = workspace.FallenPartsDestroyHeight
                     targetY = (FallenY <= -50000 and -49999) or (FallenY <= -100 and -99) or -77777
                     storso = character:FindFirstChild("Torso")
                    if storso then
                        storso.CFrame = CFrame.new(storso.Position.X, targetY, storso.Position.Z)
                    end
                    
                    if originCF then BACK(originCF) end
                end
                task.wait(0.1)
            end
        end
    end
})

Dev:CreateButton({
    Name = "Fling { Owner }",
    Callback = function()
        table.clear(playersInLoop2V)
        for i, e in ipairs(playersInLoop1V) do
            local nameOnly = e:match("^(.-) %(") or e
            table.insert(playersInLoop2V, nameOnly)
        end
        
        UpdateCurrentBlobman()
        
        for _, name in ipairs(playersInLoop2V) do
             player = game.Players:FindFirstChild(name)
            if player and not table.find(Whitelist, player.Name) then
                 character, hrp, head = safeGetCharacterParts(player)
                if PPs:FindFirstChild(name) or inv:FindFirstChild(name) then continue end
                
                 myChar = plr.Character
                 myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
                if not myHrp then continue end
                 originCF = myHrp.CFrame
                
                 tpRunning = true
                task.spawn(function()
                    while tpRunning do
                        local ok, cf = TP(player)
                        if ok and cf then
                            CF = cf
                        end
                        task.wait()
                    end
                end)

                while true do
                    rs.GrabEvents.SetNetworkOwner:FireServer(hrp, hrp.CFrame)
                     ownerTag = head:FindFirstChild("PartOwner")
                    if ownerTag and ownerTag:IsA("StringValue") and ownerTag.Value == plr.Name then
                        break
                    end
                    task.wait()
                end

                tpRunning = false

                local targetNames = {
                    "NinjaKunai", "NinjaShuriken", "NinjaKatana",
                    "ToolCleaver", "ToolDiggingForkRusty",
                    "ToolPencil", "ToolPickaxe"
                }

                for _, child in ipairs(workspace:GetChildren()) do
                    if child:IsA("Folder") and child.Name:match("SpawnedInToys$") then
                        for _, item in ipairs(child:GetChildren()) do
                            if table.find(targetNames, item.Name) and item:FindFirstChild("StickyPart") then
                                 sticky = item.StickyPart
                                 weld = sticky:FindFirstChild("StickyWeld")
                                if weld and weld:IsA("WeldConstraint") and weld.Part1 then
                                    local targetParts = {
                                        character:FindFirstChild("Head"),
                                        character:FindFirstChild("Torso"),
                                        character:FindFirstChild("Left Arm"),
                                        character:FindFirstChild("Left Leg"),
                                        character:FindFirstChild("Right Arm"),
                                        character:FindFirstChild("Right Leg"),
                                        hrp:FindFirstChild("RagdollTouchedHitbox"),
                                        hrp:FindFirstChild("FirePlayerPart"),
                                    }
                                    for _, tPart in ipairs(targetParts) do
                                        if tPart and weld.Part1 == tPart then
                                             basePart = item.PrimaryPart or sticky
                                            if basePart and (basePart.Position - hrp.Position).Magnitude <= 10 then
                                                rs.GrabEvents.SetNetworkOwner:FireServer(sticky, sticky.CFrame)
                                                sticky.CFrame = CFrame.new(0,9999,0)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end

                rs.GrabEvents.DestroyGrabLine:FireServer(head, head.CFrame)
                hrp.CFrame = CFrame.new(99999999, 99999999, 99999999)

                if originCF then
                    BACK(originCF)
                end
                task.wait(0.1)
            end
        end
    end
})

Dev:CreateSection("BLOB")

Dev:CreateToggle({
    Name = "Loop WD",
    CurrentValue = false,
    Callback = function(Value)
        AntiStickyGBT = Value
        AntiStickyGBF()
    end
})

Dev:CreateButton({
    Name = "Release { Blobman }",
    Callback = function()
        table.clear(playersInLoop2V)
	for i, e in ipairs(playersInLoop1V) do
		local nameOnly = e:match("^(.-) %(") or e
		table.insert(playersInLoop2V, nameOnly)
	end
        BlobReleaseR()
    end
})

Dev:CreateButton({
    Name = "Massless { Blobman }",
    Callback = function()
        table.clear(playersInLoop2V)
	for i, e in ipairs(playersInLoop1V) do
		local nameOnly = e:match("^(.-) %(") or e
		table.insert(playersInLoop2V, nameOnly)
	end
        BlobMasslessR()
    end
})

Dev:CreateButton({
    Name = "Grab { Blobman }",
    Callback = function()
        table.clear(playersInLoop2V)
	for i, e in ipairs(playersInLoop1V) do
		local nameOnly = e:match("^(.-) %(") or e
		table.insert(playersInLoop2V, nameOnly)
	end
        BlobGrabR()
    end
})

Dev:CreateButton({
    Name = "Drop [ Blobman ]",
    Callback = function()
        table.clear(playersInLoop2V)
	for i, e in ipairs(playersInLoop1V) do
		local nameOnly = e:match("^(.-) %(") or e
		table.insert(playersInLoop2V, nameOnly)
	end
        BlobDropR()
    end
})

BlobGrabV = "Left"
Dev:CreateDropdown({
    Name = "â”— Select",
    Options = {"ì™¼ìª½", "ì˜¤ë¥¸ìª½"},
    CurrentOption = "ì™¼ìª½",
    MultipleOptions = false,
    Callback = function(Value)
        local selected = Value
        if typeof(Value) == "table" then
            selected = Value[1] or Value.Value or Value.Selected
        end

        if selected == "ì™¼ìª½" or selected == 1 then
            BlobGrabV = "Left"
        elseif selected == "ì˜¤ë¥¸ìª½" or selected == 2 then
            BlobGrabV = "Right"
        end
    end
})

-- ====================================== [ INFO íƒ­ ] -- ì •ë³´
local INFO = Window:CreateTab("â€‹ì •ë³´", 0)

local INFO_name = INFO:CreateLabel(plr.Name .." [ " .. plr.DisplayName .. " ]")
local INFO_health = INFO:CreateLabel("")

INFO:CreateSection("")

local INFO_massless = INFO:CreateLabel("")
local INFO_seatpart = INFO:CreateLabel("")

INFO:CreateSection("")

local INFO_isheld = INFO:CreateLabel("")
local INFO_inplot = INFO:CreateLabel("")

INFO:CreateSection("")

local INFO_ragdolled = INFO:CreateLabel("")
local INFO_paintdebounce = INFO:CreateLabel("")

local function GetCheckIcon(value)
    return value and "O" or "X"
end

task.spawn(function()
    while task.wait() do
        if plr and plr.Character then
            local char = plr.Character
            local hum = char:FindFirstChild("Humanoid")
            local root = char:FindFirstChild("HumanoidRootPart")

            if plr:FindFirstChild("IsHeld") then
                INFO_isheld:Set("Held : " .. GetCheckIcon(plr.IsHeld.Value))
            else
                INFO_isheld:Set("Held : nil")
            end

            if plr:FindFirstChild("InPlot") then
                INFO_inplot:Set("Plot : " .. GetCheckIcon(plr.InPlot.Value))
            else
                INFO_inplot:Set("Plot : nil")
            end

            if hum then
                if hum:FindFirstChild("Ragdolled") then
                    INFO_ragdolled:Set("Ragdoll : " .. GetCheckIcon(hum.Ragdolled.Value))
                else
                    INFO_ragdolled:Set("Ragdoll : nil")
                end

                if hum:FindFirstChild("TimesPainted") then
                    INFO_paintdebounce:Set("TimesPainted : " .. tostring(hum.TimesPainted.Value))
                else
                    INFO_paintdebounce:Set("TimesPainted : nil")
                end

                INFO_health:Set("Health : " .. math.floor(hum.Health) .. " / " .. math.floor(hum.MaxHealth))

                if hum.SeatPart then
                    local parentName = hum.SeatPart.Parent
                    if parentName.Name == "CreatureBlobman" then INFO_seatpart:Set("SeatPart : { ë¸”ë¡­ }") end
                    if parentName.Name == "SantaSleigh" then INFO_seatpart:Set("SeatPart : ì‚°íƒ€ì°ë§¤") end
                    if parentName.Name == "TractorGreen" then INFO_seatpart:Set("SeatPart : íŠ¸ëž™í„°ðŸŸ©") end
                    if parentName.Name == "TractorOrange" then INFO_seatpart:Set("SeatPart : íŠ¸ëž™í„°ðŸŸ§") end
                    if parentName.Name == "TractorRed" then INFO_seatpart:Set("SeatPart : íŠ¸ëž™ðŸŸ¥") end
                    if parentName.Name == "ObjectModel" then INFO_seatpart:Set("SeatPart : ê¸°ì°¨") end
                else
                    INFO_seatpart:Set("SeatPart : nil")
                end
            end

            if root then
                INFO_massless:Set("Massless : " .. GetCheckIcon(root.Massless))
            end
        end
    end
end)

game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)

vu = game:GetService("VirtualUser")
plr.Idled:Connect(function()
vu:CaptureController()
vu:ClickButton2(Vector2.new())
end)

for _, v in pairs(workspace.Map.AlwaysHereTweenedObjects:GetDescendants()) do
if v.Name == "FollowThisPart" then v:Destroy() end
if v:IsA("BasePart") then v.CustomPhysicalProperties = PhysicalProperties.new(0.35,0,0) end
end
